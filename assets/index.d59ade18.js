const jf=function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))n(r);new MutationObserver(r=>{for(const s of r)if(s.type==="childList")for(const a of s.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&n(a)}).observe(document,{childList:!0,subtree:!0});function e(r){const s={};return r.integrity&&(s.integrity=r.integrity),r.referrerpolicy&&(s.referrerPolicy=r.referrerpolicy),r.crossorigin==="use-credentials"?s.credentials="include":r.crossorigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function n(r){if(r.ep)return;r.ep=!0;const s=e(r);fetch(r.href,s)}};jf();function Vl(i,t){const e=Object.create(null),n=i.split(",");for(let r=0;r<n.length;r++)e[n[r]]=!0;return t?r=>!!e[r.toLowerCase()]:r=>!!e[r]}const Xf="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",Kf=Vl(Xf);function Jh(i){return!!i||i===""}function Ul(i){if(Ft(i)){const t={};for(let e=0;e<i.length;e++){const n=i[e],r=Ie(n)?Qf(n):Ul(n);if(r)for(const s in r)t[s]=r[s]}return t}else{if(Ie(i))return i;if(Ce(i))return i}}const Zf=/;(?![^(]*\))/g,zf=/:(.+)/;function Qf(i){const t={};return i.split(Zf).forEach(e=>{if(e){const n=e.split(zf);n.length>1&&(t[n[0].trim()]=n[1].trim())}}),t}function Pl(i){let t="";if(Ie(i))t=i;else if(Ft(i))for(let e=0;e<i.length;e++){const n=Pl(i[e]);n&&(t+=n+" ")}else if(Ce(i))for(const e in i)i[e]&&(t+=e+" ");return t.trim()}const Yt={},cr=[],en=()=>{},_f=()=>!1,Yf=/^on[^a-z]/,Ua=i=>Yf.test(i),Dl=i=>i.startsWith("onUpdate:"),we=Object.assign,Fl=(i,t)=>{const e=i.indexOf(t);e>-1&&i.splice(e,1)},$f=Object.prototype.hasOwnProperty,Gt=(i,t)=>$f.call(i,t),Ft=Array.isArray,$r=i=>Pa(i)==="[object Map]",tp=i=>Pa(i)==="[object Set]",Ht=i=>typeof i=="function",Ie=i=>typeof i=="string",Bl=i=>typeof i=="symbol",Ce=i=>i!==null&&typeof i=="object",Oh=i=>Ce(i)&&Ht(i.then)&&Ht(i.catch),ep=Object.prototype.toString,Pa=i=>ep.call(i),np=i=>Pa(i).slice(8,-1),ip=i=>Pa(i)==="[object Object]",Hl=i=>Ie(i)&&i!=="NaN"&&i[0]!=="-"&&""+parseInt(i,10)===i,ma=Vl(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),Da=i=>{const t=Object.create(null);return e=>t[e]||(t[e]=i(e))},rp=/-(\w)/g,fr=Da(i=>i.replace(rp,(t,e)=>e?e.toUpperCase():"")),sp=/\B([A-Z])/g,br=Da(i=>i.replace(sp,"-$1").toLowerCase()),Gh=Da(i=>i.charAt(0).toUpperCase()+i.slice(1)),so=Da(i=>i?`on${Gh(i)}`:""),cs=(i,t)=>!Object.is(i,t),ao=(i,t)=>{for(let e=0;e<i.length;e++)i[e](t)},Sa=(i,t,e)=>{Object.defineProperty(i,t,{configurable:!0,enumerable:!1,value:e})},ap=i=>{const t=parseFloat(i);return isNaN(t)?i:t};let Rc;const op=()=>Rc||(Rc=typeof globalThis!="undefined"?globalThis:typeof self!="undefined"?self:typeof window!="undefined"?window:typeof global!="undefined"?global:{});let kn;class lp{constructor(t=!1){this.active=!0,this.effects=[],this.cleanups=[],!t&&kn&&(this.parent=kn,this.index=(kn.scopes||(kn.scopes=[])).push(this)-1)}run(t){if(this.active)try{return kn=this,t()}finally{kn=this.parent}}on(){kn=this}off(){kn=this.parent}stop(t){if(this.active){let e,n;for(e=0,n=this.effects.length;e<n;e++)this.effects[e].stop();for(e=0,n=this.cleanups.length;e<n;e++)this.cleanups[e]();if(this.scopes)for(e=0,n=this.scopes.length;e<n;e++)this.scopes[e].stop(!0);if(this.parent&&!t){const r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.active=!1}}}function cp(i,t=kn){t&&t.active&&t.effects.push(i)}const ql=i=>{const t=new Set(i);return t.w=0,t.n=0,t},jh=i=>(i.w&ei)>0,Xh=i=>(i.n&ei)>0,up=({deps:i})=>{if(i.length)for(let t=0;t<i.length;t++)i[t].w|=ei},hp=i=>{const{deps:t}=i;if(t.length){let e=0;for(let n=0;n<t.length;n++){const r=t[n];jh(r)&&!Xh(r)?r.delete(i):t[e++]=r,r.w&=~ei,r.n&=~ei}t.length=e}},rl=new WeakMap;let Xr=0,ei=1;const sl=30;let gn;const Ai=Symbol(""),al=Symbol("");class Jl{constructor(t,e=null,n){this.fn=t,this.scheduler=e,this.active=!0,this.deps=[],this.parent=void 0,cp(this,n)}run(){if(!this.active)return this.fn();let t=gn,e=Qn;for(;t;){if(t===this)return;t=t.parent}try{return this.parent=gn,gn=this,Qn=!0,ei=1<<++Xr,Xr<=sl?up(this):Ec(this),this.fn()}finally{Xr<=sl&&hp(this),ei=1<<--Xr,gn=this.parent,Qn=e,this.parent=void 0}}stop(){this.active&&(Ec(this),this.onStop&&this.onStop(),this.active=!1)}}function Ec(i){const{deps:t}=i;if(t.length){for(let e=0;e<t.length;e++)t[e].delete(i);t.length=0}}let Qn=!0;const Kh=[];function Tr(){Kh.push(Qn),Qn=!1}function Mr(){const i=Kh.pop();Qn=i===void 0?!0:i}function Je(i,t,e){if(Qn&&gn){let n=rl.get(i);n||rl.set(i,n=new Map);let r=n.get(e);r||n.set(e,r=ql()),Zh(r)}}function Zh(i,t){let e=!1;Xr<=sl?Xh(i)||(i.n|=ei,e=!jh(i)):e=!i.has(gn),e&&(i.add(gn),gn.deps.push(i))}function Nn(i,t,e,n,r,s){const a=rl.get(i);if(!a)return;let o=[];if(t==="clear")o=[...a.values()];else if(e==="length"&&Ft(i))a.forEach((l,c)=>{(c==="length"||c>=n)&&o.push(l)});else switch(e!==void 0&&o.push(a.get(e)),t){case"add":Ft(i)?Hl(e)&&o.push(a.get("length")):(o.push(a.get(Ai)),$r(i)&&o.push(a.get(al)));break;case"delete":Ft(i)||(o.push(a.get(Ai)),$r(i)&&o.push(a.get(al)));break;case"set":$r(i)&&o.push(a.get(Ai));break}if(o.length===1)o[0]&&ol(o[0]);else{const l=[];for(const c of o)c&&l.push(...c);ol(ql(l))}}function ol(i,t){for(const e of Ft(i)?i:[...i])(e!==gn||e.allowRecurse)&&(e.scheduler?e.scheduler():e.run())}const dp=Vl("__proto__,__v_isRef,__isVue"),zh=new Set(Object.getOwnPropertyNames(Symbol).map(i=>Symbol[i]).filter(Bl)),fp=Ol(),pp=Ol(!1,!0),mp=Ol(!0),Wc=gp();function gp(){const i={};return["includes","indexOf","lastIndexOf"].forEach(t=>{i[t]=function(...e){const n=jt(this);for(let s=0,a=this.length;s<a;s++)Je(n,"get",s+"");const r=n[t](...e);return r===-1||r===!1?n[t](...e.map(jt)):r}}),["push","pop","shift","unshift","splice"].forEach(t=>{i[t]=function(...e){Tr();const n=jt(this)[t].apply(this,e);return Mr(),n}}),i}function Ol(i=!1,t=!1){return function(n,r,s){if(r==="__v_isReactive")return!i;if(r==="__v_isReadonly")return i;if(r==="__v_isShallow")return t;if(r==="__v_raw"&&s===(i?t?Lp:td:t?$h:Yh).get(n))return n;const a=Ft(n);if(!i&&a&&Gt(Wc,r))return Reflect.get(Wc,r,s);const o=Reflect.get(n,r,s);return(Bl(r)?zh.has(r):dp(r))||(i||Je(n,"get",r),t)?o:Se(o)?!a||!Hl(r)?o.value:o:Ce(o)?i?ed(o):Xl(o):o}}const yp=Qh(),Ap=Qh(!0);function Qh(i=!1){return function(e,n,r,s){let a=e[n];if(us(a)&&Se(a)&&!Se(r))return!1;if(!i&&!us(r)&&(nd(r)||(r=jt(r),a=jt(a)),!Ft(e)&&Se(a)&&!Se(r)))return a.value=r,!0;const o=Ft(e)&&Hl(n)?Number(n)<e.length:Gt(e,n),l=Reflect.set(e,n,r,s);return e===jt(s)&&(o?cs(r,a)&&Nn(e,"set",n,r):Nn(e,"add",n,r)),l}}function Sp(i,t){const e=Gt(i,t);i[t];const n=Reflect.deleteProperty(i,t);return n&&e&&Nn(i,"delete",t,void 0),n}function xp(i,t){const e=Reflect.has(i,t);return(!Bl(t)||!zh.has(t))&&Je(i,"has",t),e}function vp(i){return Je(i,"iterate",Ft(i)?"length":Ai),Reflect.ownKeys(i)}const _h={get:fp,set:yp,deleteProperty:Sp,has:xp,ownKeys:vp},bp={get:mp,set(i,t){return!0},deleteProperty(i,t){return!0}},Tp=we({},_h,{get:pp,set:Ap}),Gl=i=>i,Fa=i=>Reflect.getPrototypeOf(i);function Es(i,t,e=!1,n=!1){i=i.__v_raw;const r=jt(i),s=jt(t);t!==s&&!e&&Je(r,"get",t),!e&&Je(r,"get",s);const{has:a}=Fa(r),o=n?Gl:e?Zl:hs;if(a.call(r,t))return o(i.get(t));if(a.call(r,s))return o(i.get(s));i!==r&&i.get(t)}function Ws(i,t=!1){const e=this.__v_raw,n=jt(e),r=jt(i);return i!==r&&!t&&Je(n,"has",i),!t&&Je(n,"has",r),i===r?e.has(i):e.has(i)||e.has(r)}function Cs(i,t=!1){return i=i.__v_raw,!t&&Je(jt(i),"iterate",Ai),Reflect.get(i,"size",i)}function Cc(i){i=jt(i);const t=jt(this);return Fa(t).has.call(t,i)||(t.add(i),Nn(t,"add",i,i)),this}function Lc(i,t){t=jt(t);const e=jt(this),{has:n,get:r}=Fa(e);let s=n.call(e,i);s||(i=jt(i),s=n.call(e,i));const a=r.call(e,i);return e.set(i,t),s?cs(t,a)&&Nn(e,"set",i,t):Nn(e,"add",i,t),this}function Nc(i){const t=jt(this),{has:e,get:n}=Fa(t);let r=e.call(t,i);r||(i=jt(i),r=e.call(t,i)),n&&n.call(t,i);const s=t.delete(i);return r&&Nn(t,"delete",i,void 0),s}function Vc(){const i=jt(this),t=i.size!==0,e=i.clear();return t&&Nn(i,"clear",void 0,void 0),e}function Ls(i,t){return function(n,r){const s=this,a=s.__v_raw,o=jt(a),l=t?Gl:i?Zl:hs;return!i&&Je(o,"iterate",Ai),a.forEach((c,u)=>n.call(r,l(c),l(u),s))}}function Ns(i,t,e){return function(...n){const r=this.__v_raw,s=jt(r),a=$r(s),o=i==="entries"||i===Symbol.iterator&&a,l=i==="keys"&&a,c=r[i](...n),u=e?Gl:t?Zl:hs;return!t&&Je(s,"iterate",l?al:Ai),{next(){const{value:h,done:d}=c.next();return d?{value:h,done:d}:{value:o?[u(h[0]),u(h[1])]:u(h),done:d}},[Symbol.iterator](){return this}}}}function Dn(i){return function(...t){return i==="delete"?!1:this}}function Mp(){const i={get(s){return Es(this,s)},get size(){return Cs(this)},has:Ws,add:Cc,set:Lc,delete:Nc,clear:Vc,forEach:Ls(!1,!1)},t={get(s){return Es(this,s,!1,!0)},get size(){return Cs(this)},has:Ws,add:Cc,set:Lc,delete:Nc,clear:Vc,forEach:Ls(!1,!0)},e={get(s){return Es(this,s,!0)},get size(){return Cs(this,!0)},has(s){return Ws.call(this,s,!0)},add:Dn("add"),set:Dn("set"),delete:Dn("delete"),clear:Dn("clear"),forEach:Ls(!0,!1)},n={get(s){return Es(this,s,!0,!0)},get size(){return Cs(this,!0)},has(s){return Ws.call(this,s,!0)},add:Dn("add"),set:Dn("set"),delete:Dn("delete"),clear:Dn("clear"),forEach:Ls(!0,!0)};return["keys","values","entries",Symbol.iterator].forEach(s=>{i[s]=Ns(s,!1,!1),e[s]=Ns(s,!0,!1),t[s]=Ns(s,!1,!0),n[s]=Ns(s,!0,!0)}),[i,e,t,n]}const[wp,Ip,kp,Rp]=Mp();function jl(i,t){const e=t?i?Rp:kp:i?Ip:wp;return(n,r,s)=>r==="__v_isReactive"?!i:r==="__v_isReadonly"?i:r==="__v_raw"?n:Reflect.get(Gt(e,r)&&r in n?e:n,r,s)}const Ep={get:jl(!1,!1)},Wp={get:jl(!1,!0)},Cp={get:jl(!0,!1)},Yh=new WeakMap,$h=new WeakMap,td=new WeakMap,Lp=new WeakMap;function Np(i){switch(i){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function Vp(i){return i.__v_skip||!Object.isExtensible(i)?0:Np(np(i))}function Xl(i){return us(i)?i:Kl(i,!1,_h,Ep,Yh)}function Up(i){return Kl(i,!1,Tp,Wp,$h)}function ed(i){return Kl(i,!0,bp,Cp,td)}function Kl(i,t,e,n,r){if(!Ce(i)||i.__v_raw&&!(t&&i.__v_isReactive))return i;const s=r.get(i);if(s)return s;const a=Vp(i);if(a===0)return i;const o=new Proxy(i,a===2?n:e);return r.set(i,o),o}function ur(i){return us(i)?ur(i.__v_raw):!!(i&&i.__v_isReactive)}function us(i){return!!(i&&i.__v_isReadonly)}function nd(i){return!!(i&&i.__v_isShallow)}function id(i){return ur(i)||us(i)}function jt(i){const t=i&&i.__v_raw;return t?jt(t):i}function rd(i){return Sa(i,"__v_skip",!0),i}const hs=i=>Ce(i)?Xl(i):i,Zl=i=>Ce(i)?ed(i):i;function sd(i){Qn&&gn&&(i=jt(i),Zh(i.dep||(i.dep=ql())))}function ad(i,t){i=jt(i),i.dep&&ol(i.dep)}function Se(i){return!!(i&&i.__v_isRef===!0)}function Uc(i){return Pp(i,!1)}function Pp(i,t){return Se(i)?i:new Dp(i,t)}class Dp{constructor(t,e){this.__v_isShallow=e,this.dep=void 0,this.__v_isRef=!0,this._rawValue=e?t:jt(t),this._value=e?t:hs(t)}get value(){return sd(this),this._value}set value(t){t=this.__v_isShallow?t:jt(t),cs(t,this._rawValue)&&(this._rawValue=t,this._value=this.__v_isShallow?t:hs(t),ad(this))}}function _i(i){return Se(i)?i.value:i}const Fp={get:(i,t,e)=>_i(Reflect.get(i,t,e)),set:(i,t,e,n)=>{const r=i[t];return Se(r)&&!Se(e)?(r.value=e,!0):Reflect.set(i,t,e,n)}};function od(i){return ur(i)?i:new Proxy(i,Fp)}class Bp{constructor(t,e,n,r){this._setter=e,this.dep=void 0,this.__v_isRef=!0,this._dirty=!0,this.effect=new Jl(t,()=>{this._dirty||(this._dirty=!0,ad(this))}),this.effect.computed=this,this.effect.active=this._cacheable=!r,this.__v_isReadonly=n}get value(){const t=jt(this);return sd(t),(t._dirty||!t._cacheable)&&(t._dirty=!1,t._value=t.effect.run()),t._value}set value(t){this._setter(t)}}function Hp(i,t,e=!1){let n,r;const s=Ht(i);return s?(n=i,r=en):(n=i.get,r=i.set),new Bp(n,r,s||!r,e)}Promise.resolve();function _n(i,t,e,n){let r;try{r=n?i(...n):i()}catch(s){Ba(s,t,e)}return r}function Xe(i,t,e,n){if(Ht(i)){const s=_n(i,t,e,n);return s&&Oh(s)&&s.catch(a=>{Ba(a,t,e)}),s}const r=[];for(let s=0;s<i.length;s++)r.push(Xe(i[s],t,e,n));return r}function Ba(i,t,e,n=!0){const r=t?t.vnode:null;if(t){let s=t.parent;const a=t.proxy,o=e;for(;s;){const c=s.ec;if(c){for(let u=0;u<c.length;u++)if(c[u](i,a,o)===!1)return}s=s.parent}const l=t.appContext.config.errorHandler;if(l){_n(l,null,10,[i,a,o]);return}}qp(i,e,r,n)}function qp(i,t,e,n=!0){console.error(i)}let xa=!1,ll=!1;const Be=[];let Wn=0;const ts=[];let Kr=null,Yi=0;const es=[];let Xn=null,$i=0;const ld=Promise.resolve();let zl=null,cl=null;function Jp(i){const t=zl||ld;return i?t.then(this?i.bind(this):i):t}function Op(i){let t=Wn+1,e=Be.length;for(;t<e;){const n=t+e>>>1;ds(Be[n])<i?t=n+1:e=n}return t}function cd(i){(!Be.length||!Be.includes(i,xa&&i.allowRecurse?Wn+1:Wn))&&i!==cl&&(i.id==null?Be.push(i):Be.splice(Op(i.id),0,i),ud())}function ud(){!xa&&!ll&&(ll=!0,zl=ld.then(fd))}function Gp(i){const t=Be.indexOf(i);t>Wn&&Be.splice(t,1)}function hd(i,t,e,n){Ft(i)?e.push(...i):(!t||!t.includes(i,i.allowRecurse?n+1:n))&&e.push(i),ud()}function jp(i){hd(i,Kr,ts,Yi)}function Xp(i){hd(i,Xn,es,$i)}function Ql(i,t=null){if(ts.length){for(cl=t,Kr=[...new Set(ts)],ts.length=0,Yi=0;Yi<Kr.length;Yi++)Kr[Yi]();Kr=null,Yi=0,cl=null,Ql(i,t)}}function dd(i){if(es.length){const t=[...new Set(es)];if(es.length=0,Xn){Xn.push(...t);return}for(Xn=t,Xn.sort((e,n)=>ds(e)-ds(n)),$i=0;$i<Xn.length;$i++)Xn[$i]();Xn=null,$i=0}}const ds=i=>i.id==null?1/0:i.id;function fd(i){ll=!1,xa=!0,Ql(i),Be.sort((e,n)=>ds(e)-ds(n));const t=en;try{for(Wn=0;Wn<Be.length;Wn++){const e=Be[Wn];e&&e.active!==!1&&_n(e,null,14)}}finally{Wn=0,Be.length=0,dd(),xa=!1,zl=null,(Be.length||ts.length||es.length)&&fd(i)}}function Kp(i,t,...e){const n=i.vnode.props||Yt;let r=e;const s=t.startsWith("update:"),a=s&&t.slice(7);if(a&&a in n){const u=`${a==="modelValue"?"model":a}Modifiers`,{number:h,trim:d}=n[u]||Yt;d?r=e.map(m=>m.trim()):h&&(r=e.map(ap))}let o,l=n[o=so(t)]||n[o=so(fr(t))];!l&&s&&(l=n[o=so(br(t))]),l&&Xe(l,i,6,r);const c=n[o+"Once"];if(c){if(!i.emitted)i.emitted={};else if(i.emitted[o])return;i.emitted[o]=!0,Xe(c,i,6,r)}}function pd(i,t,e=!1){const n=t.emitsCache,r=n.get(i);if(r!==void 0)return r;const s=i.emits;let a={},o=!1;if(!Ht(i)){const l=c=>{const u=pd(c,t,!0);u&&(o=!0,we(a,u))};!e&&t.mixins.length&&t.mixins.forEach(l),i.extends&&l(i.extends),i.mixins&&i.mixins.forEach(l)}return!s&&!o?(n.set(i,null),null):(Ft(s)?s.forEach(l=>a[l]=null):we(a,s),n.set(i,a),a)}function _l(i,t){return!i||!Ua(t)?!1:(t=t.slice(2).replace(/Once$/,""),Gt(i,t[0].toLowerCase()+t.slice(1))||Gt(i,br(t))||Gt(i,t))}let yn=null,md=null;function va(i){const t=yn;return yn=i,md=i&&i.type.__scopeId||null,t}function Zp(i,t=yn,e){if(!t||i._n)return i;const n=(...r)=>{n._d&&jc(-1);const s=va(t),a=i(...r);return va(s),n._d&&jc(1),a};return n._n=!0,n._c=!0,n._d=!0,n}function oo(i){const{type:t,vnode:e,proxy:n,withProxy:r,props:s,propsOptions:[a],slots:o,attrs:l,emit:c,render:u,renderCache:h,data:d,setupState:m,ctx:g,inheritAttrs:p}=i;let f,y;const M=va(i);try{if(e.shapeFlag&4){const R=r||n;f=fn(u.call(R,R,h,s,m,d,g)),y=l}else{const R=t;f=fn(R.length>1?R(s,{attrs:l,slots:o,emit:c}):R(s,null)),y=t.props?l:zp(l)}}catch(R){ns.length=0,Ba(R,i,1),f=nn(An)}let E=f;if(y&&p!==!1){const R=Object.keys(y),{shapeFlag:b}=E;R.length&&b&7&&(a&&R.some(Dl)&&(y=Qp(y,a)),E=pr(E,y))}return e.dirs&&(E.dirs=E.dirs?E.dirs.concat(e.dirs):e.dirs),e.transition&&(E.transition=e.transition),f=E,va(M),f}const zp=i=>{let t;for(const e in i)(e==="class"||e==="style"||Ua(e))&&((t||(t={}))[e]=i[e]);return t},Qp=(i,t)=>{const e={};for(const n in i)(!Dl(n)||!(n.slice(9)in t))&&(e[n]=i[n]);return e};function _p(i,t,e){const{props:n,children:r,component:s}=i,{props:a,children:o,patchFlag:l}=t,c=s.emitsOptions;if(t.dirs||t.transition)return!0;if(e&&l>=0){if(l&1024)return!0;if(l&16)return n?Pc(n,a,c):!!a;if(l&8){const u=t.dynamicProps;for(let h=0;h<u.length;h++){const d=u[h];if(a[d]!==n[d]&&!_l(c,d))return!0}}}else return(r||o)&&(!o||!o.$stable)?!0:n===a?!1:n?a?Pc(n,a,c):!0:!!a;return!1}function Pc(i,t,e){const n=Object.keys(t);if(n.length!==Object.keys(i).length)return!0;for(let r=0;r<n.length;r++){const s=n[r];if(t[s]!==i[s]&&!_l(e,s))return!0}return!1}function Yp({vnode:i,parent:t},e){for(;t&&t.subTree===i;)(i=t.vnode).el=e,t=t.parent}const $p=i=>i.__isSuspense;function tm(i,t){t&&t.pendingBranch?Ft(i)?t.effects.push(...i):t.effects.push(i):Xp(i)}function em(i,t){if(Ae){let e=Ae.provides;const n=Ae.parent&&Ae.parent.provides;n===e&&(e=Ae.provides=Object.create(n)),e[i]=t}}function lo(i,t,e=!1){const n=Ae||yn;if(n){const r=n.parent==null?n.vnode.appContext&&n.vnode.appContext.provides:n.parent.provides;if(r&&i in r)return r[i];if(arguments.length>1)return e&&Ht(t)?t.call(n.proxy):t}}const Dc={};function co(i,t,e){return gd(i,t,e)}function gd(i,t,{immediate:e,deep:n,flush:r,onTrack:s,onTrigger:a}=Yt){const o=Ae;let l,c=!1,u=!1;if(Se(i)?(l=()=>i.value,c=nd(i)):ur(i)?(l=()=>i,n=!0):Ft(i)?(u=!0,c=i.some(ur),l=()=>i.map(y=>{if(Se(y))return y.value;if(ur(y))return er(y);if(Ht(y))return _n(y,o,2)})):Ht(i)?t?l=()=>_n(i,o,2):l=()=>{if(!(o&&o.isUnmounted))return h&&h(),Xe(i,o,3,[d])}:l=en,t&&n){const y=l;l=()=>er(y())}let h,d=y=>{h=f.onStop=()=>{_n(y,o,4)}};if(fs)return d=en,t?e&&Xe(t,o,3,[l(),u?[]:void 0,d]):l(),en;let m=u?[]:Dc;const g=()=>{if(!!f.active)if(t){const y=f.run();(n||c||(u?y.some((M,E)=>cs(M,m[E])):cs(y,m)))&&(h&&h(),Xe(t,o,3,[y,m===Dc?void 0:m,d]),m=y)}else f.run()};g.allowRecurse=!!t;let p;r==="sync"?p=g:r==="post"?p=()=>Ve(g,o&&o.suspense):p=()=>{!o||o.isMounted?jp(g):g()};const f=new Jl(l,p);return t?e?g():m=f.run():r==="post"?Ve(f.run.bind(f),o&&o.suspense):f.run(),()=>{f.stop(),o&&o.scope&&Fl(o.scope.effects,f)}}function nm(i,t,e){const n=this.proxy,r=Ie(i)?i.includes(".")?yd(n,i):()=>n[i]:i.bind(n,n);let s;Ht(t)?s=t:(s=t.handler,e=t);const a=Ae;mr(this);const o=gd(r,s.bind(n),e);return a?mr(a):xi(),o}function yd(i,t){const e=t.split(".");return()=>{let n=i;for(let r=0;r<e.length&&n;r++)n=n[e[r]];return n}}function er(i,t){if(!Ce(i)||i.__v_skip||(t=t||new Set,t.has(i)))return i;if(t.add(i),Se(i))er(i.value,t);else if(Ft(i))for(let e=0;e<i.length;e++)er(i[e],t);else if(tp(i)||$r(i))i.forEach(e=>{er(e,t)});else if(ip(i))for(const e in i)er(i[e],t);return i}function im(){const i={isMounted:!1,isLeaving:!1,isUnmounting:!1,leavingVNodes:new Map};return $l(()=>{i.isMounted=!0}),vd(()=>{i.isUnmounting=!0}),i}const Oe=[Function,Array],rm={name:"BaseTransition",props:{mode:String,appear:Boolean,persisted:Boolean,onBeforeEnter:Oe,onEnter:Oe,onAfterEnter:Oe,onEnterCancelled:Oe,onBeforeLeave:Oe,onLeave:Oe,onAfterLeave:Oe,onLeaveCancelled:Oe,onBeforeAppear:Oe,onAppear:Oe,onAfterAppear:Oe,onAppearCancelled:Oe},setup(i,{slots:t}){const e=Gm(),n=im();let r;return()=>{const s=t.default&&Sd(t.default(),!0);if(!s||!s.length)return;const a=jt(i),{mode:o}=a,l=s[0];if(n.isLeaving)return uo(l);const c=Fc(l);if(!c)return uo(l);const u=ul(c,a,n,e);hl(c,u);const h=e.subTree,d=h&&Fc(h);let m=!1;const{getTransitionKey:g}=c.type;if(g){const p=g();r===void 0?r=p:p!==r&&(r=p,m=!0)}if(d&&d.type!==An&&(!pi(c,d)||m)){const p=ul(d,a,n,e);if(hl(d,p),o==="out-in")return n.isLeaving=!0,p.afterLeave=()=>{n.isLeaving=!1,e.update()},uo(l);o==="in-out"&&c.type!==An&&(p.delayLeave=(f,y,M)=>{const E=Ad(n,d);E[String(d.key)]=d,f._leaveCb=()=>{y(),f._leaveCb=void 0,delete u.delayedLeave},u.delayedLeave=M})}return l}}},sm=rm;function Ad(i,t){const{leavingVNodes:e}=i;let n=e.get(t.type);return n||(n=Object.create(null),e.set(t.type,n)),n}function ul(i,t,e,n){const{appear:r,mode:s,persisted:a=!1,onBeforeEnter:o,onEnter:l,onAfterEnter:c,onEnterCancelled:u,onBeforeLeave:h,onLeave:d,onAfterLeave:m,onLeaveCancelled:g,onBeforeAppear:p,onAppear:f,onAfterAppear:y,onAppearCancelled:M}=t,E=String(i.key),R=Ad(e,i),b=(U,X)=>{U&&Xe(U,n,9,X)},D={mode:s,persisted:a,beforeEnter(U){let X=o;if(!e.isMounted)if(r)X=p||o;else return;U._leaveCb&&U._leaveCb(!0);const dt=R[E];dt&&pi(i,dt)&&dt.el._leaveCb&&dt.el._leaveCb(),b(X,[U])},enter(U){let X=l,dt=c,K=u;if(!e.isMounted)if(r)X=f||l,dt=y||c,K=M||u;else return;let v=!1;const C=U._enterCb=it=>{v||(v=!0,it?b(K,[U]):b(dt,[U]),D.delayedLeave&&D.delayedLeave(),U._enterCb=void 0)};X?(X(U,C),X.length<=1&&C()):C()},leave(U,X){const dt=String(i.key);if(U._enterCb&&U._enterCb(!0),e.isUnmounting)return X();b(h,[U]);let K=!1;const v=U._leaveCb=C=>{K||(K=!0,X(),C?b(g,[U]):b(m,[U]),U._leaveCb=void 0,R[dt]===i&&delete R[dt])};R[dt]=i,d?(d(U,v),d.length<=1&&v()):v()},clone(U){return ul(U,t,e,n)}};return D}function uo(i){if(Ha(i))return i=pr(i),i.children=null,i}function Fc(i){return Ha(i)?i.children?i.children[0]:void 0:i}function hl(i,t){i.shapeFlag&6&&i.component?hl(i.component.subTree,t):i.shapeFlag&128?(i.ssContent.transition=t.clone(i.ssContent),i.ssFallback.transition=t.clone(i.ssFallback)):i.transition=t}function Sd(i,t=!1){let e=[],n=0;for(let r=0;r<i.length;r++){const s=i[r];s.type===tn?(s.patchFlag&128&&n++,e=e.concat(Sd(s.children,t))):(t||s.type!==An)&&e.push(s)}if(n>1)for(let r=0;r<e.length;r++)e[r].patchFlag=-2;return e}function Yl(i){return Ht(i)?{setup:i,name:i.name}:i}const dl=i=>!!i.type.__asyncLoader,Ha=i=>i.type.__isKeepAlive;function am(i,t){xd(i,"a",t)}function om(i,t){xd(i,"da",t)}function xd(i,t,e=Ae){const n=i.__wdc||(i.__wdc=()=>{let r=e;for(;r;){if(r.isDeactivated)return;r=r.parent}return i()});if(qa(t,n,e),e){let r=e.parent;for(;r&&r.parent;)Ha(r.parent.vnode)&&lm(n,t,e,r),r=r.parent}}function lm(i,t,e,n){const r=qa(t,i,n,!0);bd(()=>{Fl(n[t],r)},e)}function qa(i,t,e=Ae,n=!1){if(e){const r=e[i]||(e[i]=[]),s=t.__weh||(t.__weh=(...a)=>{if(e.isUnmounted)return;Tr(),mr(e);const o=Xe(t,e,i,a);return xi(),Mr(),o});return n?r.unshift(s):r.push(s),s}}const Un=i=>(t,e=Ae)=>(!fs||i==="sp")&&qa(i,t,e),cm=Un("bm"),$l=Un("m"),um=Un("bu"),hm=Un("u"),vd=Un("bum"),bd=Un("um"),dm=Un("sp"),fm=Un("rtg"),pm=Un("rtc");function mm(i,t=Ae){qa("ec",i,t)}let fl=!0;function gm(i){const t=Md(i),e=i.proxy,n=i.ctx;fl=!1,t.beforeCreate&&Bc(t.beforeCreate,i,"bc");const{data:r,computed:s,methods:a,watch:o,provide:l,inject:c,created:u,beforeMount:h,mounted:d,beforeUpdate:m,updated:g,activated:p,deactivated:f,beforeDestroy:y,beforeUnmount:M,destroyed:E,unmounted:R,render:b,renderTracked:D,renderTriggered:U,errorCaptured:X,serverPrefetch:dt,expose:K,inheritAttrs:v,components:C,directives:it,filters:B}=t;if(c&&ym(c,n,null,i.appContext.config.unwrapInjectedRef),a)for(const H in a){const L=a[H];Ht(L)&&(n[H]=L.bind(e))}if(r){const H=r.call(e,e);Ce(H)&&(i.data=Xl(H))}if(fl=!0,s)for(const H in s){const L=s[H],z=Ht(L)?L.bind(e,e):Ht(L.get)?L.get.bind(e,e):en,lt=!Ht(L)&&Ht(L.set)?L.set.bind(e):en,ut=Qm({get:z,set:lt});Object.defineProperty(n,H,{enumerable:!0,configurable:!0,get:()=>ut.value,set:ht=>ut.value=ht})}if(o)for(const H in o)Td(o[H],n,e,H);if(l){const H=Ht(l)?l.call(e):l;Reflect.ownKeys(H).forEach(L=>{em(L,H[L])})}u&&Bc(u,i,"c");function F(H,L){Ft(L)?L.forEach(z=>H(z.bind(e))):L&&H(L.bind(e))}if(F(cm,h),F($l,d),F(um,m),F(hm,g),F(am,p),F(om,f),F(mm,X),F(pm,D),F(fm,U),F(vd,M),F(bd,R),F(dm,dt),Ft(K))if(K.length){const H=i.exposed||(i.exposed={});K.forEach(L=>{Object.defineProperty(H,L,{get:()=>e[L],set:z=>e[L]=z})})}else i.exposed||(i.exposed={});b&&i.render===en&&(i.render=b),v!=null&&(i.inheritAttrs=v),C&&(i.components=C),it&&(i.directives=it)}function ym(i,t,e=en,n=!1){Ft(i)&&(i=pl(i));for(const r in i){const s=i[r];let a;Ce(s)?"default"in s?a=lo(s.from||r,s.default,!0):a=lo(s.from||r):a=lo(s),Se(a)&&n?Object.defineProperty(t,r,{enumerable:!0,configurable:!0,get:()=>a.value,set:o=>a.value=o}):t[r]=a}}function Bc(i,t,e){Xe(Ft(i)?i.map(n=>n.bind(t.proxy)):i.bind(t.proxy),t,e)}function Td(i,t,e,n){const r=n.includes(".")?yd(e,n):()=>e[n];if(Ie(i)){const s=t[i];Ht(s)&&co(r,s)}else if(Ht(i))co(r,i.bind(e));else if(Ce(i))if(Ft(i))i.forEach(s=>Td(s,t,e,n));else{const s=Ht(i.handler)?i.handler.bind(e):t[i.handler];Ht(s)&&co(r,s,i)}}function Md(i){const t=i.type,{mixins:e,extends:n}=t,{mixins:r,optionsCache:s,config:{optionMergeStrategies:a}}=i.appContext,o=s.get(t);let l;return o?l=o:!r.length&&!e&&!n?l=t:(l={},r.length&&r.forEach(c=>ba(l,c,a,!0)),ba(l,t,a)),s.set(t,l),l}function ba(i,t,e,n=!1){const{mixins:r,extends:s}=t;s&&ba(i,s,e,!0),r&&r.forEach(a=>ba(i,a,e,!0));for(const a in t)if(!(n&&a==="expose")){const o=Am[a]||e&&e[a];i[a]=o?o(i[a],t[a]):t[a]}return i}const Am={data:Hc,props:di,emits:di,methods:di,computed:di,beforeCreate:Ee,created:Ee,beforeMount:Ee,mounted:Ee,beforeUpdate:Ee,updated:Ee,beforeDestroy:Ee,beforeUnmount:Ee,destroyed:Ee,unmounted:Ee,activated:Ee,deactivated:Ee,errorCaptured:Ee,serverPrefetch:Ee,components:di,directives:di,watch:xm,provide:Hc,inject:Sm};function Hc(i,t){return t?i?function(){return we(Ht(i)?i.call(this,this):i,Ht(t)?t.call(this,this):t)}:t:i}function Sm(i,t){return di(pl(i),pl(t))}function pl(i){if(Ft(i)){const t={};for(let e=0;e<i.length;e++)t[i[e]]=i[e];return t}return i}function Ee(i,t){return i?[...new Set([].concat(i,t))]:t}function di(i,t){return i?we(we(Object.create(null),i),t):t}function xm(i,t){if(!i)return t;if(!t)return i;const e=we(Object.create(null),i);for(const n in t)e[n]=Ee(i[n],t[n]);return e}function vm(i,t,e,n=!1){const r={},s={};Sa(s,Ja,1),i.propsDefaults=Object.create(null),wd(i,t,r,s);for(const a in i.propsOptions[0])a in r||(r[a]=void 0);e?i.props=n?r:Up(r):i.type.props?i.props=r:i.props=s,i.attrs=s}function bm(i,t,e,n){const{props:r,attrs:s,vnode:{patchFlag:a}}=i,o=jt(r),[l]=i.propsOptions;let c=!1;if((n||a>0)&&!(a&16)){if(a&8){const u=i.vnode.dynamicProps;for(let h=0;h<u.length;h++){let d=u[h];const m=t[d];if(l)if(Gt(s,d))m!==s[d]&&(s[d]=m,c=!0);else{const g=fr(d);r[g]=ml(l,o,g,m,i,!1)}else m!==s[d]&&(s[d]=m,c=!0)}}}else{wd(i,t,r,s)&&(c=!0);let u;for(const h in o)(!t||!Gt(t,h)&&((u=br(h))===h||!Gt(t,u)))&&(l?e&&(e[h]!==void 0||e[u]!==void 0)&&(r[h]=ml(l,o,h,void 0,i,!0)):delete r[h]);if(s!==o)for(const h in s)(!t||!Gt(t,h)&&!0)&&(delete s[h],c=!0)}c&&Nn(i,"set","$attrs")}function wd(i,t,e,n){const[r,s]=i.propsOptions;let a=!1,o;if(t)for(let l in t){if(ma(l))continue;const c=t[l];let u;r&&Gt(r,u=fr(l))?!s||!s.includes(u)?e[u]=c:(o||(o={}))[u]=c:_l(i.emitsOptions,l)||(!(l in n)||c!==n[l])&&(n[l]=c,a=!0)}if(s){const l=jt(e),c=o||Yt;for(let u=0;u<s.length;u++){const h=s[u];e[h]=ml(r,l,h,c[h],i,!Gt(c,h))}}return a}function ml(i,t,e,n,r,s){const a=i[e];if(a!=null){const o=Gt(a,"default");if(o&&n===void 0){const l=a.default;if(a.type!==Function&&Ht(l)){const{propsDefaults:c}=r;e in c?n=c[e]:(mr(r),n=c[e]=l.call(null,t),xi())}else n=l}a[0]&&(s&&!o?n=!1:a[1]&&(n===""||n===br(e))&&(n=!0))}return n}function Id(i,t,e=!1){const n=t.propsCache,r=n.get(i);if(r)return r;const s=i.props,a={},o=[];let l=!1;if(!Ht(i)){const u=h=>{l=!0;const[d,m]=Id(h,t,!0);we(a,d),m&&o.push(...m)};!e&&t.mixins.length&&t.mixins.forEach(u),i.extends&&u(i.extends),i.mixins&&i.mixins.forEach(u)}if(!s&&!l)return n.set(i,cr),cr;if(Ft(s))for(let u=0;u<s.length;u++){const h=fr(s[u]);qc(h)&&(a[h]=Yt)}else if(s)for(const u in s){const h=fr(u);if(qc(h)){const d=s[u],m=a[h]=Ft(d)||Ht(d)?{type:d}:d;if(m){const g=Gc(Boolean,m.type),p=Gc(String,m.type);m[0]=g>-1,m[1]=p<0||g<p,(g>-1||Gt(m,"default"))&&o.push(h)}}}const c=[a,o];return n.set(i,c),c}function qc(i){return i[0]!=="$"}function Jc(i){const t=i&&i.toString().match(/^\s*function (\w+)/);return t?t[1]:i===null?"null":""}function Oc(i,t){return Jc(i)===Jc(t)}function Gc(i,t){return Ft(t)?t.findIndex(e=>Oc(e,i)):Ht(t)&&Oc(t,i)?0:-1}const kd=i=>i[0]==="_"||i==="$stable",tc=i=>Ft(i)?i.map(fn):[fn(i)],Tm=(i,t,e)=>{const n=Zp((...r)=>tc(t(...r)),e);return n._c=!1,n},Rd=(i,t,e)=>{const n=i._ctx;for(const r in i){if(kd(r))continue;const s=i[r];if(Ht(s))t[r]=Tm(r,s,n);else if(s!=null){const a=tc(s);t[r]=()=>a}}},Ed=(i,t)=>{const e=tc(t);i.slots.default=()=>e},Mm=(i,t)=>{if(i.vnode.shapeFlag&32){const e=t._;e?(i.slots=jt(t),Sa(t,"_",e)):Rd(t,i.slots={})}else i.slots={},t&&Ed(i,t);Sa(i.slots,Ja,1)},wm=(i,t,e)=>{const{vnode:n,slots:r}=i;let s=!0,a=Yt;if(n.shapeFlag&32){const o=t._;o?e&&o===1?s=!1:(we(r,t),!e&&o===1&&delete r._):(s=!t.$stable,Rd(t,r)),a=t}else t&&(Ed(i,t),a={default:1});if(s)for(const o in r)!kd(o)&&!(o in a)&&delete r[o]};function oi(i,t,e,n){const r=i.dirs,s=t&&t.dirs;for(let a=0;a<r.length;a++){const o=r[a];s&&(o.oldValue=s[a].value);let l=o.dir[n];l&&(Tr(),Xe(l,e,8,[i.el,o,i,t]),Mr())}}function Wd(){return{app:null,config:{isNativeTag:_f,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let Im=0;function km(i,t){return function(n,r=null){r!=null&&!Ce(r)&&(r=null);const s=Wd(),a=new Set;let o=!1;const l=s.app={_uid:Im++,_component:n,_props:r,_container:null,_context:s,_instance:null,version:_m,get config(){return s.config},set config(c){},use(c,...u){return a.has(c)||(c&&Ht(c.install)?(a.add(c),c.install(l,...u)):Ht(c)&&(a.add(c),c(l,...u))),l},mixin(c){return s.mixins.includes(c)||s.mixins.push(c),l},component(c,u){return u?(s.components[c]=u,l):s.components[c]},directive(c,u){return u?(s.directives[c]=u,l):s.directives[c]},mount(c,u,h){if(!o){const d=nn(n,r);return d.appContext=s,u&&t?t(d,c):i(d,c,h),o=!0,l._container=c,c.__vue_app__=l,ic(d.component)||d.component.proxy}},unmount(){o&&(i(null,l._container),delete l._container.__vue_app__)},provide(c,u){return s.provides[c]=u,l}};return l}}function gl(i,t,e,n,r=!1){if(Ft(i)){i.forEach((d,m)=>gl(d,t&&(Ft(t)?t[m]:t),e,n,r));return}if(dl(n)&&!r)return;const s=n.shapeFlag&4?ic(n.component)||n.component.proxy:n.el,a=r?null:s,{i:o,r:l}=i,c=t&&t.r,u=o.refs===Yt?o.refs={}:o.refs,h=o.setupState;if(c!=null&&c!==l&&(Ie(c)?(u[c]=null,Gt(h,c)&&(h[c]=null)):Se(c)&&(c.value=null)),Ht(l))_n(l,o,12,[a,u]);else{const d=Ie(l),m=Se(l);if(d||m){const g=()=>{if(i.f){const p=d?u[l]:l.value;r?Ft(p)&&Fl(p,s):Ft(p)?p.includes(s)||p.push(s):d?u[l]=[s]:(l.value=[s],i.k&&(u[i.k]=l.value))}else d?(u[l]=a,Gt(h,l)&&(h[l]=a)):Se(l)&&(l.value=a,i.k&&(u[i.k]=a))};a?(g.id=-1,Ve(g,e)):g()}}}const Ve=tm;function Rm(i){return Em(i)}function Em(i,t){const e=op();e.__VUE__=!0;const{insert:n,remove:r,patchProp:s,createElement:a,createText:o,createComment:l,setText:c,setElementText:u,parentNode:h,nextSibling:d,setScopeId:m=en,cloneNode:g,insertStaticContent:p}=i,f=(x,w,V,P=null,O=null,Z=null,Y=!1,rt=null,st=!!w.dynamicChildren)=>{if(x===w)return;x&&!pi(x,w)&&(P=Rt(x),At(x,O,Z,!0),x=null),w.patchFlag===-2&&(st=!1,w.dynamicChildren=null);const{type:S,ref:A,shapeFlag:N}=w;switch(S){case ec:y(x,w,V,P);break;case An:M(x,w,V,P);break;case ho:x==null&&E(w,V,P,Y);break;case tn:it(x,w,V,P,O,Z,Y,rt,st);break;default:N&1?D(x,w,V,P,O,Z,Y,rt,st):N&6?B(x,w,V,P,O,Z,Y,rt,st):(N&64||N&128)&&S.process(x,w,V,P,O,Z,Y,rt,st,ft)}A!=null&&O&&gl(A,x&&x.ref,Z,w||x,!w)},y=(x,w,V,P)=>{if(x==null)n(w.el=o(w.children),V,P);else{const O=w.el=x.el;w.children!==x.children&&c(O,w.children)}},M=(x,w,V,P)=>{x==null?n(w.el=l(w.children||""),V,P):w.el=x.el},E=(x,w,V,P)=>{[x.el,x.anchor]=p(x.children,w,V,P,x.el,x.anchor)},R=({el:x,anchor:w},V,P)=>{let O;for(;x&&x!==w;)O=d(x),n(x,V,P),x=O;n(w,V,P)},b=({el:x,anchor:w})=>{let V;for(;x&&x!==w;)V=d(x),r(x),x=V;r(w)},D=(x,w,V,P,O,Z,Y,rt,st)=>{Y=Y||w.type==="svg",x==null?U(w,V,P,O,Z,Y,rt,st):K(x,w,O,Z,Y,rt,st)},U=(x,w,V,P,O,Z,Y,rt)=>{let st,S;const{type:A,props:N,shapeFlag:q,transition:tt,patchFlag:ot,dirs:St}=x;if(x.el&&g!==void 0&&ot===-1)st=x.el=g(x.el);else{if(st=x.el=a(x.type,Z,N&&N.is,N),q&8?u(st,x.children):q&16&&dt(x.children,st,null,P,O,Z&&A!=="foreignObject",Y,rt),St&&oi(x,null,P,"created"),N){for(const nt in N)nt!=="value"&&!ma(nt)&&s(st,nt,null,N[nt],Z,x.children,P,O,Nt);"value"in N&&s(st,"value",null,N.value),(S=N.onVnodeBeforeMount)&&un(S,P,x)}X(st,x,x.scopeId,Y,P)}St&&oi(x,null,P,"beforeMount");const T=(!O||O&&!O.pendingBranch)&&tt&&!tt.persisted;T&&tt.beforeEnter(st),n(st,w,V),((S=N&&N.onVnodeMounted)||T||St)&&Ve(()=>{S&&un(S,P,x),T&&tt.enter(st),St&&oi(x,null,P,"mounted")},O)},X=(x,w,V,P,O)=>{if(V&&m(x,V),P)for(let Z=0;Z<P.length;Z++)m(x,P[Z]);if(O){let Z=O.subTree;if(w===Z){const Y=O.vnode;X(x,Y,Y.scopeId,Y.slotScopeIds,O.parent)}}},dt=(x,w,V,P,O,Z,Y,rt,st=0)=>{for(let S=st;S<x.length;S++){const A=x[S]=rt?Zn(x[S]):fn(x[S]);f(null,A,w,V,P,O,Z,Y,rt)}},K=(x,w,V,P,O,Z,Y)=>{const rt=w.el=x.el;let{patchFlag:st,dynamicChildren:S,dirs:A}=w;st|=x.patchFlag&16;const N=x.props||Yt,q=w.props||Yt;let tt;V&&li(V,!1),(tt=q.onVnodeBeforeUpdate)&&un(tt,V,w,x),A&&oi(w,x,V,"beforeUpdate"),V&&li(V,!0);const ot=O&&w.type!=="foreignObject";if(S?v(x.dynamicChildren,S,rt,V,P,ot,Z):Y||z(x,w,rt,null,V,P,ot,Z,!1),st>0){if(st&16)C(rt,w,N,q,V,P,O);else if(st&2&&N.class!==q.class&&s(rt,"class",null,q.class,O),st&4&&s(rt,"style",N.style,q.style,O),st&8){const St=w.dynamicProps;for(let T=0;T<St.length;T++){const nt=St[T],bt=N[nt],mt=q[nt];(mt!==bt||nt==="value")&&s(rt,nt,bt,mt,O,x.children,V,P,Nt)}}st&1&&x.children!==w.children&&u(rt,w.children)}else!Y&&S==null&&C(rt,w,N,q,V,P,O);((tt=q.onVnodeUpdated)||A)&&Ve(()=>{tt&&un(tt,V,w,x),A&&oi(w,x,V,"updated")},P)},v=(x,w,V,P,O,Z,Y)=>{for(let rt=0;rt<w.length;rt++){const st=x[rt],S=w[rt],A=st.el&&(st.type===tn||!pi(st,S)||st.shapeFlag&70)?h(st.el):V;f(st,S,A,null,P,O,Z,Y,!0)}},C=(x,w,V,P,O,Z,Y)=>{if(V!==P){for(const rt in P){if(ma(rt))continue;const st=P[rt],S=V[rt];st!==S&&rt!=="value"&&s(x,rt,S,st,Y,w.children,O,Z,Nt)}if(V!==Yt)for(const rt in V)!ma(rt)&&!(rt in P)&&s(x,rt,V[rt],null,Y,w.children,O,Z,Nt);"value"in P&&s(x,"value",V.value,P.value)}},it=(x,w,V,P,O,Z,Y,rt,st)=>{const S=w.el=x?x.el:o(""),A=w.anchor=x?x.anchor:o("");let{patchFlag:N,dynamicChildren:q,slotScopeIds:tt}=w;tt&&(rt=rt?rt.concat(tt):tt),x==null?(n(S,V,P),n(A,V,P),dt(w.children,V,A,O,Z,Y,rt,st)):N>0&&N&64&&q&&x.dynamicChildren?(v(x.dynamicChildren,q,V,O,Z,Y,rt),(w.key!=null||O&&w===O.subTree)&&Cd(x,w,!0)):z(x,w,V,A,O,Z,Y,rt,st)},B=(x,w,V,P,O,Z,Y,rt,st)=>{w.slotScopeIds=rt,x==null?w.shapeFlag&512?O.ctx.activate(w,V,P,Y,st):G(w,V,P,O,Z,Y,st):F(x,w,st)},G=(x,w,V,P,O,Z,Y)=>{const rt=x.component=Om(x,P,O);if(Ha(x)&&(rt.ctx.renderer=ft),jm(rt),rt.asyncDep){if(O&&O.registerDep(rt,H),!x.el){const st=rt.subTree=nn(An);M(null,st,w,V)}return}H(rt,x,w,V,O,Z,Y)},F=(x,w,V)=>{const P=w.component=x.component;if(_p(x,w,V))if(P.asyncDep&&!P.asyncResolved){L(P,w,V);return}else P.next=w,Gp(P.update),P.update();else w.component=x.component,w.el=x.el,P.vnode=w},H=(x,w,V,P,O,Z,Y)=>{const rt=()=>{if(x.isMounted){let{next:A,bu:N,u:q,parent:tt,vnode:ot}=x,St=A,T;li(x,!1),A?(A.el=ot.el,L(x,A,Y)):A=ot,N&&ao(N),(T=A.props&&A.props.onVnodeBeforeUpdate)&&un(T,tt,A,ot),li(x,!0);const nt=oo(x),bt=x.subTree;x.subTree=nt,f(bt,nt,h(bt.el),Rt(bt),x,O,Z),A.el=nt.el,St===null&&Yp(x,nt.el),q&&Ve(q,O),(T=A.props&&A.props.onVnodeUpdated)&&Ve(()=>un(T,tt,A,ot),O)}else{let A;const{el:N,props:q}=w,{bm:tt,m:ot,parent:St}=x,T=dl(w);if(li(x,!1),tt&&ao(tt),!T&&(A=q&&q.onVnodeBeforeMount)&&un(A,St,w),li(x,!0),N&&$){const nt=()=>{x.subTree=oo(x),$(N,x.subTree,x,O,null)};T?w.type.__asyncLoader().then(()=>!x.isUnmounted&&nt()):nt()}else{const nt=x.subTree=oo(x);f(null,nt,V,P,x,O,Z),w.el=nt.el}if(ot&&Ve(ot,O),!T&&(A=q&&q.onVnodeMounted)){const nt=w;Ve(()=>un(A,St,nt),O)}w.shapeFlag&256&&x.a&&Ve(x.a,O),x.isMounted=!0,w=V=P=null}},st=x.effect=new Jl(rt,()=>cd(x.update),x.scope),S=x.update=st.run.bind(st);S.id=x.uid,li(x,!0),S()},L=(x,w,V)=>{w.component=x;const P=x.vnode.props;x.vnode=w,x.next=null,bm(x,w.props,P,V),wm(x,w.children,V),Tr(),Ql(void 0,x.update),Mr()},z=(x,w,V,P,O,Z,Y,rt,st=!1)=>{const S=x&&x.children,A=x?x.shapeFlag:0,N=w.children,{patchFlag:q,shapeFlag:tt}=w;if(q>0){if(q&128){ut(S,N,V,P,O,Z,Y,rt,st);return}else if(q&256){lt(S,N,V,P,O,Z,Y,rt,st);return}}tt&8?(A&16&&Nt(S,O,Z),N!==S&&u(V,N)):A&16?tt&16?ut(S,N,V,P,O,Z,Y,rt,st):Nt(S,O,Z,!0):(A&8&&u(V,""),tt&16&&dt(N,V,P,O,Z,Y,rt,st))},lt=(x,w,V,P,O,Z,Y,rt,st)=>{x=x||cr,w=w||cr;const S=x.length,A=w.length,N=Math.min(S,A);let q;for(q=0;q<N;q++){const tt=w[q]=st?Zn(w[q]):fn(w[q]);f(x[q],tt,V,null,O,Z,Y,rt,st)}S>A?Nt(x,O,Z,!0,!1,N):dt(w,V,P,O,Z,Y,rt,st,N)},ut=(x,w,V,P,O,Z,Y,rt,st)=>{let S=0;const A=w.length;let N=x.length-1,q=A-1;for(;S<=N&&S<=q;){const tt=x[S],ot=w[S]=st?Zn(w[S]):fn(w[S]);if(pi(tt,ot))f(tt,ot,V,null,O,Z,Y,rt,st);else break;S++}for(;S<=N&&S<=q;){const tt=x[N],ot=w[q]=st?Zn(w[q]):fn(w[q]);if(pi(tt,ot))f(tt,ot,V,null,O,Z,Y,rt,st);else break;N--,q--}if(S>N){if(S<=q){const tt=q+1,ot=tt<A?w[tt].el:P;for(;S<=q;)f(null,w[S]=st?Zn(w[S]):fn(w[S]),V,ot,O,Z,Y,rt,st),S++}}else if(S>q)for(;S<=N;)At(x[S],O,Z,!0),S++;else{const tt=S,ot=S,St=new Map;for(S=ot;S<=q;S++){const Tt=w[S]=st?Zn(w[S]):fn(w[S]);Tt.key!=null&&St.set(Tt.key,S)}let T,nt=0;const bt=q-ot+1;let mt=!1,W=0;const pt=new Array(bt);for(S=0;S<bt;S++)pt[S]=0;for(S=tt;S<=N;S++){const Tt=x[S];if(nt>=bt){At(Tt,O,Z,!0);continue}let yt;if(Tt.key!=null)yt=St.get(Tt.key);else for(T=ot;T<=q;T++)if(pt[T-ot]===0&&pi(Tt,w[T])){yt=T;break}yt===void 0?At(Tt,O,Z,!0):(pt[yt-ot]=S+1,yt>=W?W=yt:mt=!0,f(Tt,w[yt],V,null,O,Z,Y,rt,st),nt++)}const gt=mt?Wm(pt):cr;for(T=gt.length-1,S=bt-1;S>=0;S--){const Tt=ot+S,yt=w[Tt],wt=Tt+1<A?w[Tt+1].el:P;pt[S]===0?f(null,yt,V,wt,O,Z,Y,rt,st):mt&&(T<0||S!==gt[T]?ht(yt,V,wt,2):T--)}}},ht=(x,w,V,P,O=null)=>{const{el:Z,type:Y,transition:rt,children:st,shapeFlag:S}=x;if(S&6){ht(x.component.subTree,w,V,P);return}if(S&128){x.suspense.move(w,V,P);return}if(S&64){Y.move(x,w,V,ft);return}if(Y===tn){n(Z,w,V);for(let N=0;N<st.length;N++)ht(st[N],w,V,P);n(x.anchor,w,V);return}if(Y===ho){R(x,w,V);return}if(P!==2&&S&1&&rt)if(P===0)rt.beforeEnter(Z),n(Z,w,V),Ve(()=>rt.enter(Z),O);else{const{leave:N,delayLeave:q,afterLeave:tt}=rt,ot=()=>n(Z,w,V),St=()=>{N(Z,()=>{ot(),tt&&tt()})};q?q(Z,ot,St):St()}else n(Z,w,V)},At=(x,w,V,P=!1,O=!1)=>{const{type:Z,props:Y,ref:rt,children:st,dynamicChildren:S,shapeFlag:A,patchFlag:N,dirs:q}=x;if(rt!=null&&gl(rt,null,V,x,!0),A&256){w.ctx.deactivate(x);return}const tt=A&1&&q,ot=!dl(x);let St;if(ot&&(St=Y&&Y.onVnodeBeforeUnmount)&&un(St,w,x),A&6)et(x.component,V,P);else{if(A&128){x.suspense.unmount(V,P);return}tt&&oi(x,null,w,"beforeUnmount"),A&64?x.type.remove(x,w,V,O,ft,P):S&&(Z!==tn||N>0&&N&64)?Nt(S,w,V,!1,!0):(Z===tn&&N&384||!O&&A&16)&&Nt(st,w,V),P&&Lt(x)}(ot&&(St=Y&&Y.onVnodeUnmounted)||tt)&&Ve(()=>{St&&un(St,w,x),tt&&oi(x,null,w,"unmounted")},V)},Lt=x=>{const{type:w,el:V,anchor:P,transition:O}=x;if(w===tn){kt(V,P);return}if(w===ho){b(x);return}const Z=()=>{r(V),O&&!O.persisted&&O.afterLeave&&O.afterLeave()};if(x.shapeFlag&1&&O&&!O.persisted){const{leave:Y,delayLeave:rt}=O,st=()=>Y(V,Z);rt?rt(x.el,Z,st):st()}else Z()},kt=(x,w)=>{let V;for(;x!==w;)V=d(x),r(x),x=V;r(w)},et=(x,w,V)=>{const{bum:P,scope:O,update:Z,subTree:Y,um:rt}=x;P&&ao(P),O.stop(),Z&&(Z.active=!1,At(Y,x,w,V)),rt&&Ve(rt,w),Ve(()=>{x.isUnmounted=!0},w),w&&w.pendingBranch&&!w.isUnmounted&&x.asyncDep&&!x.asyncResolved&&x.suspenseId===w.pendingId&&(w.deps--,w.deps===0&&w.resolve())},Nt=(x,w,V,P=!1,O=!1,Z=0)=>{for(let Y=Z;Y<x.length;Y++)At(x[Y],w,V,P,O)},Rt=x=>x.shapeFlag&6?Rt(x.component.subTree):x.shapeFlag&128?x.suspense.next():d(x.anchor||x.el),Et=(x,w,V)=>{x==null?w._vnode&&At(w._vnode,null,null,!0):f(w._vnode||null,x,w,null,null,null,V),dd(),w._vnode=x},ft={p:f,um:At,m:ht,r:Lt,mt:G,mc:dt,pc:z,pbc:v,n:Rt,o:i};let Ct,$;return t&&([Ct,$]=t(ft)),{render:Et,hydrate:Ct,createApp:km(Et,Ct)}}function li({effect:i,update:t},e){i.allowRecurse=t.allowRecurse=e}function Cd(i,t,e=!1){const n=i.children,r=t.children;if(Ft(n)&&Ft(r))for(let s=0;s<n.length;s++){const a=n[s];let o=r[s];o.shapeFlag&1&&!o.dynamicChildren&&((o.patchFlag<=0||o.patchFlag===32)&&(o=r[s]=Zn(r[s]),o.el=a.el),e||Cd(a,o))}}function Wm(i){const t=i.slice(),e=[0];let n,r,s,a,o;const l=i.length;for(n=0;n<l;n++){const c=i[n];if(c!==0){if(r=e[e.length-1],i[r]<c){t[n]=r,e.push(n);continue}for(s=0,a=e.length-1;s<a;)o=s+a>>1,i[e[o]]<c?s=o+1:a=o;c<i[e[s]]&&(s>0&&(t[n]=e[s-1]),e[s]=n)}}for(s=e.length,a=e[s-1];s-- >0;)e[s]=a,a=t[a];return e}const Cm=i=>i.__isTeleport,Lm=Symbol(),tn=Symbol(void 0),ec=Symbol(void 0),An=Symbol(void 0),ho=Symbol(void 0),ns=[];let Si=null;function nr(i=!1){ns.push(Si=i?null:[])}function Nm(){ns.pop(),Si=ns[ns.length-1]||null}let Ta=1;function jc(i){Ta+=i}function Ld(i){return i.dynamicChildren=Ta>0?Si||cr:null,Nm(),Ta>0&&Si&&Si.push(i),i}function Zr(i,t,e,n,r,s){return Ld(Ma(i,t,e,n,r,s,!0))}function Vm(i,t,e,n,r){return Ld(nn(i,t,e,n,r,!0))}function Um(i){return i?i.__v_isVNode===!0:!1}function pi(i,t){return i.type===t.type&&i.key===t.key}const Ja="__vInternal",Nd=({key:i})=>i!=null?i:null,ga=({ref:i,ref_key:t,ref_for:e})=>i!=null?Ie(i)||Se(i)||Ht(i)?{i:yn,r:i,k:t,f:!!e}:i:null;function Ma(i,t=null,e=null,n=0,r=null,s=i===tn?0:1,a=!1,o=!1){const l={__v_isVNode:!0,__v_skip:!0,type:i,props:t,key:t&&Nd(t),ref:t&&ga(t),scopeId:md,slotScopeIds:null,children:e,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetAnchor:null,staticCount:0,shapeFlag:s,patchFlag:n,dynamicProps:r,dynamicChildren:null,appContext:null};return o?(nc(l,e),s&128&&i.normalize(l)):e&&(l.shapeFlag|=Ie(e)?8:16),Ta>0&&!a&&Si&&(l.patchFlag>0||s&6)&&l.patchFlag!==32&&Si.push(l),l}const nn=Pm;function Pm(i,t=null,e=null,n=0,r=null,s=!1){if((!i||i===Lm)&&(i=An),Um(i)){const o=pr(i,t,!0);return e&&nc(o,e),o}if(zm(i)&&(i=i.__vccOpts),t){t=Dm(t);let{class:o,style:l}=t;o&&!Ie(o)&&(t.class=Pl(o)),Ce(l)&&(id(l)&&!Ft(l)&&(l=we({},l)),t.style=Ul(l))}const a=Ie(i)?1:$p(i)?128:Cm(i)?64:Ce(i)?4:Ht(i)?2:0;return Ma(i,t,e,n,r,a,s,!0)}function Dm(i){return i?id(i)||Ja in i?we({},i):i:null}function pr(i,t,e=!1){const{props:n,ref:r,patchFlag:s,children:a}=i,o=t?Bm(n||{},t):n;return{__v_isVNode:!0,__v_skip:!0,type:i.type,props:o,key:o&&Nd(o),ref:t&&t.ref?e&&r?Ft(r)?r.concat(ga(t)):[r,ga(t)]:ga(t):r,scopeId:i.scopeId,slotScopeIds:i.slotScopeIds,children:a,target:i.target,targetAnchor:i.targetAnchor,staticCount:i.staticCount,shapeFlag:i.shapeFlag,patchFlag:t&&i.type!==tn?s===-1?16:s|16:s,dynamicProps:i.dynamicProps,dynamicChildren:i.dynamicChildren,appContext:i.appContext,dirs:i.dirs,transition:i.transition,component:i.component,suspense:i.suspense,ssContent:i.ssContent&&pr(i.ssContent),ssFallback:i.ssFallback&&pr(i.ssFallback),el:i.el,anchor:i.anchor}}function Fm(i=" ",t=0){return nn(ec,null,i,t)}function Xc(i="",t=!1){return t?(nr(),Vm(An,null,i)):nn(An,null,i)}function fn(i){return i==null||typeof i=="boolean"?nn(An):Ft(i)?nn(tn,null,i.slice()):typeof i=="object"?Zn(i):nn(ec,null,String(i))}function Zn(i){return i.el===null||i.memo?i:pr(i)}function nc(i,t){let e=0;const{shapeFlag:n}=i;if(t==null)t=null;else if(Ft(t))e=16;else if(typeof t=="object")if(n&65){const r=t.default;r&&(r._c&&(r._d=!1),nc(i,r()),r._c&&(r._d=!0));return}else{e=32;const r=t._;!r&&!(Ja in t)?t._ctx=yn:r===3&&yn&&(yn.slots._===1?t._=1:(t._=2,i.patchFlag|=1024))}else Ht(t)?(t={default:t,_ctx:yn},e=32):(t=String(t),n&64?(e=16,t=[Fm(t)]):e=8);i.children=t,i.shapeFlag|=e}function Bm(...i){const t={};for(let e=0;e<i.length;e++){const n=i[e];for(const r in n)if(r==="class")t.class!==n.class&&(t.class=Pl([t.class,n.class]));else if(r==="style")t.style=Ul([t.style,n.style]);else if(Ua(r)){const s=t[r],a=n[r];a&&s!==a&&!(Ft(s)&&s.includes(a))&&(t[r]=s?[].concat(s,a):a)}else r!==""&&(t[r]=n[r])}return t}function un(i,t,e,n=null){Xe(i,t,7,[e,n])}const yl=i=>i?Vd(i)?ic(i)||i.proxy:yl(i.parent):null,wa=we(Object.create(null),{$:i=>i,$el:i=>i.vnode.el,$data:i=>i.data,$props:i=>i.props,$attrs:i=>i.attrs,$slots:i=>i.slots,$refs:i=>i.refs,$parent:i=>yl(i.parent),$root:i=>yl(i.root),$emit:i=>i.emit,$options:i=>Md(i),$forceUpdate:i=>()=>cd(i.update),$nextTick:i=>Jp.bind(i.proxy),$watch:i=>nm.bind(i)}),Hm={get({_:i},t){const{ctx:e,setupState:n,data:r,props:s,accessCache:a,type:o,appContext:l}=i;let c;if(t[0]!=="$"){const m=a[t];if(m!==void 0)switch(m){case 1:return n[t];case 2:return r[t];case 4:return e[t];case 3:return s[t]}else{if(n!==Yt&&Gt(n,t))return a[t]=1,n[t];if(r!==Yt&&Gt(r,t))return a[t]=2,r[t];if((c=i.propsOptions[0])&&Gt(c,t))return a[t]=3,s[t];if(e!==Yt&&Gt(e,t))return a[t]=4,e[t];fl&&(a[t]=0)}}const u=wa[t];let h,d;if(u)return t==="$attrs"&&Je(i,"get",t),u(i);if((h=o.__cssModules)&&(h=h[t]))return h;if(e!==Yt&&Gt(e,t))return a[t]=4,e[t];if(d=l.config.globalProperties,Gt(d,t))return d[t]},set({_:i},t,e){const{data:n,setupState:r,ctx:s}=i;return r!==Yt&&Gt(r,t)?(r[t]=e,!0):n!==Yt&&Gt(n,t)?(n[t]=e,!0):Gt(i.props,t)||t[0]==="$"&&t.slice(1)in i?!1:(s[t]=e,!0)},has({_:{data:i,setupState:t,accessCache:e,ctx:n,appContext:r,propsOptions:s}},a){let o;return!!e[a]||i!==Yt&&Gt(i,a)||t!==Yt&&Gt(t,a)||(o=s[0])&&Gt(o,a)||Gt(n,a)||Gt(wa,a)||Gt(r.config.globalProperties,a)},defineProperty(i,t,e){return e.get!=null?this.set(i,t,e.get(),null):e.value!=null&&this.set(i,t,e.value,null),Reflect.defineProperty(i,t,e)}},qm=Wd();let Jm=0;function Om(i,t,e){const n=i.type,r=(t?t.appContext:i.appContext)||qm,s={uid:Jm++,vnode:i,type:n,parent:t,appContext:r,root:null,next:null,subTree:null,effect:null,update:null,scope:new lp(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:t?t.provides:Object.create(r.provides),accessCache:null,renderCache:[],components:null,directives:null,propsOptions:Id(n,r),emitsOptions:pd(n,r),emit:null,emitted:null,propsDefaults:Yt,inheritAttrs:n.inheritAttrs,ctx:Yt,data:Yt,props:Yt,attrs:Yt,slots:Yt,refs:Yt,setupState:Yt,setupContext:null,suspense:e,suspenseId:e?e.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return s.ctx={_:s},s.root=t?t.root:s,s.emit=Kp.bind(null,s),i.ce&&i.ce(s),s}let Ae=null;const Gm=()=>Ae||yn,mr=i=>{Ae=i,i.scope.on()},xi=()=>{Ae&&Ae.scope.off(),Ae=null};function Vd(i){return i.vnode.shapeFlag&4}let fs=!1;function jm(i,t=!1){fs=t;const{props:e,children:n}=i.vnode,r=Vd(i);vm(i,e,r,t),Mm(i,n);const s=r?Xm(i,t):void 0;return fs=!1,s}function Xm(i,t){const e=i.type;i.accessCache=Object.create(null),i.proxy=rd(new Proxy(i.ctx,Hm));const{setup:n}=e;if(n){const r=i.setupContext=n.length>1?Zm(i):null;mr(i),Tr();const s=_n(n,i,0,[i.props,r]);if(Mr(),xi(),Oh(s)){if(s.then(xi,xi),t)return s.then(a=>{Kc(i,a,t)}).catch(a=>{Ba(a,i,0)});i.asyncDep=s}else Kc(i,s,t)}else Ud(i,t)}function Kc(i,t,e){Ht(t)?i.type.__ssrInlineRender?i.ssrRender=t:i.render=t:Ce(t)&&(i.setupState=od(t)),Ud(i,e)}let Zc;function Ud(i,t,e){const n=i.type;if(!i.render){if(!t&&Zc&&!n.render){const r=n.template;if(r){const{isCustomElement:s,compilerOptions:a}=i.appContext.config,{delimiters:o,compilerOptions:l}=n,c=we(we({isCustomElement:s,delimiters:o},a),l);n.render=Zc(r,c)}}i.render=n.render||en}mr(i),Tr(),gm(i),Mr(),xi()}function Km(i){return new Proxy(i.attrs,{get(t,e){return Je(i,"get","$attrs"),t[e]}})}function Zm(i){const t=n=>{i.exposed=n||{}};let e;return{get attrs(){return e||(e=Km(i))},slots:i.slots,emit:i.emit,expose:t}}function ic(i){if(i.exposed)return i.exposeProxy||(i.exposeProxy=new Proxy(od(rd(i.exposed)),{get(t,e){if(e in t)return t[e];if(e in wa)return wa[e](i)}}))}function zm(i){return Ht(i)&&"__vccOpts"in i}const Qm=(i,t)=>Hp(i,t,fs),_m="3.2.31",Ym="http://www.w3.org/2000/svg",mi=typeof document!="undefined"?document:null,zc=mi&&mi.createElement("template"),$m={insert:(i,t,e)=>{t.insertBefore(i,e||null)},remove:i=>{const t=i.parentNode;t&&t.removeChild(i)},createElement:(i,t,e,n)=>{const r=t?mi.createElementNS(Ym,i):mi.createElement(i,e?{is:e}:void 0);return i==="select"&&n&&n.multiple!=null&&r.setAttribute("multiple",n.multiple),r},createText:i=>mi.createTextNode(i),createComment:i=>mi.createComment(i),setText:(i,t)=>{i.nodeValue=t},setElementText:(i,t)=>{i.textContent=t},parentNode:i=>i.parentNode,nextSibling:i=>i.nextSibling,querySelector:i=>mi.querySelector(i),setScopeId(i,t){i.setAttribute(t,"")},cloneNode(i){const t=i.cloneNode(!0);return"_value"in i&&(t._value=i._value),t},insertStaticContent(i,t,e,n,r,s){const a=e?e.previousSibling:t.lastChild;if(r&&(r===s||r.nextSibling))for(;t.insertBefore(r.cloneNode(!0),e),!(r===s||!(r=r.nextSibling)););else{zc.innerHTML=n?`<svg>${i}</svg>`:i;const o=zc.content;if(n){const l=o.firstChild;for(;l.firstChild;)o.appendChild(l.firstChild);o.removeChild(l)}t.insertBefore(o,e)}return[a?a.nextSibling:t.firstChild,e?e.previousSibling:t.lastChild]}};function tg(i,t,e){const n=i._vtc;n&&(t=(t?[t,...n]:[...n]).join(" ")),t==null?i.removeAttribute("class"):e?i.setAttribute("class",t):i.className=t}function eg(i,t,e){const n=i.style,r=Ie(e);if(e&&!r){for(const s in e)Al(n,s,e[s]);if(t&&!Ie(t))for(const s in t)e[s]==null&&Al(n,s,"")}else{const s=n.display;r?t!==e&&(n.cssText=e):t&&i.removeAttribute("style"),"_vod"in i&&(n.display=s)}}const Qc=/\s*!important$/;function Al(i,t,e){if(Ft(e))e.forEach(n=>Al(i,t,n));else if(t.startsWith("--"))i.setProperty(t,e);else{const n=ng(i,t);Qc.test(e)?i.setProperty(br(n),e.replace(Qc,""),"important"):i[n]=e}}const _c=["Webkit","Moz","ms"],fo={};function ng(i,t){const e=fo[t];if(e)return e;let n=fr(t);if(n!=="filter"&&n in i)return fo[t]=n;n=Gh(n);for(let r=0;r<_c.length;r++){const s=_c[r]+n;if(s in i)return fo[t]=s}return t}const Yc="http://www.w3.org/1999/xlink";function ig(i,t,e,n,r){if(n&&t.startsWith("xlink:"))e==null?i.removeAttributeNS(Yc,t.slice(6,t.length)):i.setAttributeNS(Yc,t,e);else{const s=Kf(t);e==null||s&&!Jh(e)?i.removeAttribute(t):i.setAttribute(t,s?"":e)}}function rg(i,t,e,n,r,s,a){if(t==="innerHTML"||t==="textContent"){n&&a(n,r,s),i[t]=e==null?"":e;return}if(t==="value"&&i.tagName!=="PROGRESS"&&!i.tagName.includes("-")){i._value=e;const o=e==null?"":e;(i.value!==o||i.tagName==="OPTION")&&(i.value=o),e==null&&i.removeAttribute(t);return}if(e===""||e==null){const o=typeof i[t];if(o==="boolean"){i[t]=Jh(e);return}else if(e==null&&o==="string"){i[t]="",i.removeAttribute(t);return}else if(o==="number"){try{i[t]=0}catch{}i.removeAttribute(t);return}}try{i[t]=e}catch{}}let Ia=Date.now,Pd=!1;if(typeof window!="undefined"){Ia()>document.createEvent("Event").timeStamp&&(Ia=()=>performance.now());const i=navigator.userAgent.match(/firefox\/(\d+)/i);Pd=!!(i&&Number(i[1])<=53)}let Sl=0;const sg=Promise.resolve(),ag=()=>{Sl=0},og=()=>Sl||(sg.then(ag),Sl=Ia());function lg(i,t,e,n){i.addEventListener(t,e,n)}function cg(i,t,e,n){i.removeEventListener(t,e,n)}function ug(i,t,e,n,r=null){const s=i._vei||(i._vei={}),a=s[t];if(n&&a)a.value=n;else{const[o,l]=hg(t);if(n){const c=s[t]=dg(n,r);lg(i,o,c,l)}else a&&(cg(i,o,a,l),s[t]=void 0)}}const $c=/(?:Once|Passive|Capture)$/;function hg(i){let t;if($c.test(i)){t={};let e;for(;e=i.match($c);)i=i.slice(0,i.length-e[0].length),t[e[0].toLowerCase()]=!0}return[br(i.slice(2)),t]}function dg(i,t){const e=n=>{const r=n.timeStamp||Ia();(Pd||r>=e.attached-1)&&Xe(fg(n,e.value),t,5,[n])};return e.value=i,e.attached=og(),e}function fg(i,t){if(Ft(t)){const e=i.stopImmediatePropagation;return i.stopImmediatePropagation=()=>{e.call(i),i._stopped=!0},t.map(n=>r=>!r._stopped&&n&&n(r))}else return t}const tu=/^on[a-z]/,pg=(i,t,e,n,r=!1,s,a,o,l)=>{t==="class"?tg(i,n,r):t==="style"?eg(i,e,n):Ua(t)?Dl(t)||ug(i,t,e,n,a):(t[0]==="."?(t=t.slice(1),!0):t[0]==="^"?(t=t.slice(1),!1):mg(i,t,n,r))?rg(i,t,n,s,a,o,l):(t==="true-value"?i._trueValue=n:t==="false-value"&&(i._falseValue=n),ig(i,t,n,r))};function mg(i,t,e,n){return n?!!(t==="innerHTML"||t==="textContent"||t in i&&tu.test(t)&&Ht(e)):t==="spellcheck"||t==="draggable"||t==="form"||t==="list"&&i.tagName==="INPUT"||t==="type"&&i.tagName==="TEXTAREA"||tu.test(t)&&Ie(e)?!1:t in i}const gg={name:String,type:String,css:{type:Boolean,default:!0},duration:[String,Number,Object],enterFromClass:String,enterActiveClass:String,enterToClass:String,appearFromClass:String,appearActiveClass:String,appearToClass:String,leaveFromClass:String,leaveActiveClass:String,leaveToClass:String};sm.props;const yg=we({patchProp:pg},$m);let eu;function Ag(){return eu||(eu=Rm(yg))}const Sg=(...i)=>{const t=Ag().createApp(...i),{mount:e}=t;return t.mount=n=>{const r=xg(n);if(!r)return;const s=t._component;!Ht(s)&&!s.render&&!s.template&&(s.template=r.innerHTML),r.innerHTML="";const a=e(r,!1,r instanceof SVGElement);return r instanceof Element&&(r.removeAttribute("v-cloak"),r.setAttribute("data-v-app","")),a},t};function xg(i){return Ie(i)?document.querySelector(i):i}try{self["workbox:window:6.4.1"]&&_()}catch{}function xl(i,t){return new Promise(function(e){var n=new MessageChannel;n.port1.onmessage=function(r){e(r.data)},i.postMessage(t,[n.port2])})}function vg(i,t){for(var e=0;e<t.length;e++){var n=t[e];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(i,n.key,n)}}function nu(i,t){(t==null||t>i.length)&&(t=i.length);for(var e=0,n=new Array(t);e<t;e++)n[e]=i[e];return n}function bg(i,t){var e;if(typeof Symbol=="undefined"||i[Symbol.iterator]==null){if(Array.isArray(i)||(e=function(r,s){if(r){if(typeof r=="string")return nu(r,s);var a=Object.prototype.toString.call(r).slice(8,-1);return a==="Object"&&r.constructor&&(a=r.constructor.name),a==="Map"||a==="Set"?Array.from(r):a==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)?nu(r,s):void 0}}(i))||t&&i&&typeof i.length=="number"){e&&(i=e);var n=0;return function(){return n>=i.length?{done:!0}:{done:!1,value:i[n++]}}}throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}return(e=i[Symbol.iterator]()).next.bind(e)}try{self["workbox:core:6.4.1"]&&_()}catch{}var po=function(){var i=this;this.promise=new Promise(function(t,e){i.resolve=t,i.reject=e})};function mo(i,t){var e=location.href;return new URL(i,e).href===new URL(t,e).href}var Pr=function(i,t){this.type=i,Object.assign(this,t)};function Vs(i,t,e){return e?t?t(i):i:(i&&i.then||(i=Promise.resolve(i)),t?i.then(t):i)}function Tg(){}var Mg={type:"SKIP_WAITING"};function iu(i,t){if(!t)return i&&i.then?i.then(Tg):Promise.resolve()}var wg=function(i){var t,e;function n(o,l){var c,u;return l===void 0&&(l={}),(c=i.call(this)||this).nn={},c.tn=0,c.rn=new po,c.en=new po,c.on=new po,c.un=0,c.an=new Set,c.cn=function(){var h=c.fn,d=h.installing;c.tn>0||!mo(d.scriptURL,c.sn.toString())||performance.now()>c.un+6e4?(c.vn=d,h.removeEventListener("updatefound",c.cn)):(c.hn=d,c.an.add(d),c.rn.resolve(d)),++c.tn,d.addEventListener("statechange",c.ln)},c.ln=function(h){var d=c.fn,m=h.target,g=m.state,p=m===c.vn,f={sw:m,isExternal:p,originalEvent:h};!p&&c.mn&&(f.isUpdate=!0),c.dispatchEvent(new Pr(g,f)),g==="installed"?c.wn=self.setTimeout(function(){g==="installed"&&d.waiting===m&&c.dispatchEvent(new Pr("waiting",f))},200):g==="activating"&&(clearTimeout(c.wn),p||c.en.resolve(m))},c.dn=function(h){var d=c.hn,m=d!==navigator.serviceWorker.controller;c.dispatchEvent(new Pr("controlling",{isExternal:m,originalEvent:h,sw:d,isUpdate:c.mn})),m||c.on.resolve(d)},c.gn=(u=function(h){var d=h.data,m=h.ports,g=h.source;return Vs(c.getSW(),function(){c.an.has(g)&&c.dispatchEvent(new Pr("message",{data:d,originalEvent:h,ports:m,sw:g}))})},function(){for(var h=[],d=0;d<arguments.length;d++)h[d]=arguments[d];try{return Promise.resolve(u.apply(this,h))}catch(m){return Promise.reject(m)}}),c.sn=o,c.nn=l,navigator.serviceWorker.addEventListener("message",c.gn),c}e=i,(t=n).prototype=Object.create(e.prototype),t.prototype.constructor=t,t.__proto__=e;var r,s,a=n.prototype;return a.register=function(o){var l=(o===void 0?{}:o).immediate,c=l!==void 0&&l;try{var u=this;return function(h,d){var m=h();return m&&m.then?m.then(d):d(m)}(function(){if(!c&&document.readyState!=="complete")return iu(new Promise(function(h){return window.addEventListener("load",h)}))},function(){return u.mn=Boolean(navigator.serviceWorker.controller),u.yn=u.pn(),Vs(u.bn(),function(h){u.fn=h,u.yn&&(u.hn=u.yn,u.en.resolve(u.yn),u.on.resolve(u.yn),u.yn.addEventListener("statechange",u.ln,{once:!0}));var d=u.fn.waiting;return d&&mo(d.scriptURL,u.sn.toString())&&(u.hn=d,Promise.resolve().then(function(){u.dispatchEvent(new Pr("waiting",{sw:d,wasWaitingBeforeRegister:!0}))}).then(function(){})),u.hn&&(u.rn.resolve(u.hn),u.an.add(u.hn)),u.fn.addEventListener("updatefound",u.cn),navigator.serviceWorker.addEventListener("controllerchange",u.dn),u.fn})})}catch(h){return Promise.reject(h)}},a.update=function(){try{return this.fn?iu(this.fn.update()):void 0}catch(o){return Promise.reject(o)}},a.getSW=function(){return this.hn!==void 0?Promise.resolve(this.hn):this.rn.promise},a.messageSW=function(o){try{return Vs(this.getSW(),function(l){return xl(l,o)})}catch(l){return Promise.reject(l)}},a.messageSkipWaiting=function(){this.fn&&this.fn.waiting&&xl(this.fn.waiting,Mg)},a.pn=function(){var o=navigator.serviceWorker.controller;return o&&mo(o.scriptURL,this.sn.toString())?o:void 0},a.bn=function(){try{var o=this;return function(l,c){try{var u=l()}catch(h){return c(h)}return u&&u.then?u.then(void 0,c):u}(function(){return Vs(navigator.serviceWorker.register(o.sn,o.nn),function(l){return o.un=performance.now(),l})},function(l){throw l})}catch(l){return Promise.reject(l)}},r=n,(s=[{key:"active",get:function(){return this.en.promise}},{key:"controlling",get:function(){return this.on.promise}}])&&vg(r.prototype,s),n}(function(){function i(){this.Pn=new Map}var t=i.prototype;return t.addEventListener=function(e,n){this.Sn(e).add(n)},t.removeEventListener=function(e,n){this.Sn(e).delete(n)},t.dispatchEvent=function(e){e.target=this;for(var n,r=bg(this.Sn(e.type));!(n=r()).done;)(0,n.value)(e)},t.Sn=function(e){return this.Pn.has(e)||this.Pn.set(e,new Set),this.Pn.get(e)},i}());function Ig(i={}){const{immediate:t=!1,onNeedRefresh:e,onOfflineReady:n,onRegistered:r,onRegisterError:s}=i;let a,o;const l=async(c=!0)=>{c&&(a==null||a.addEventListener("controlling",u=>{u.isUpdate&&window.location.reload()})),o&&o.waiting&&await xl(o.waiting,{type:"SKIP_WAITING"})};if("serviceWorker"in navigator){a=new wg("/sw.js",{scope:"/",type:"classic"}),a.addEventListener("activated",c=>{c.isUpdate||n==null||n()});{const c=()=>{e==null||e()};a.addEventListener("waiting",c),a.addEventListener("externalwaiting",c)}a.register({immediate:t}).then(c=>{o=c,r==null||r(c)}).catch(c=>{s==null||s(c)})}return l}function kg(i={}){const{immediate:t=!0,onNeedRefresh:e,onOfflineReady:n,onRegistered:r,onRegisterError:s}=i,a=Uc(!1),o=Uc(!1);return{updateServiceWorker:Ig({immediate:t,onNeedRefresh(){a.value=!0,e==null||e()},onOfflineReady(){o.value=!0,n==null||n()},onRegistered:r,onRegisterError:s}),offlineReady:o,needRefresh:a}}var Rg=(i,t)=>{const e=i.__vccOpts||i;for(const[n,r]of t)e[n]=r;return e};const Eg={key:0,class:"pwa-toast",role:"alert"},Wg={class:"message"},Cg={key:0},Lg={key:1},Ng=Yl({setup(i){const{offlineReady:t,needRefresh:e,updateServiceWorker:n}=kg(),r=async()=>{t.value=!1,e.value=!1};return(s,a)=>_i(t)||_i(e)?(nr(),Zr("div",Eg,[Ma("div",Wg,[_i(t)?(nr(),Zr("span",Cg," App ready to work offline ")):(nr(),Zr("span",Lg," New content available, click on reload button to update. "))]),_i(e)?(nr(),Zr("button",{key:0,onClick:a[0]||(a[0]=o=>_i(n)())},"Reload")):Xc("",!0),Ma("button",{onClick:r},"Close")])):Xc("",!0)}});var Vg=Rg(Ng,[["__scopeId","data-v-b4138ff6"]]);/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const rc="139",Ci={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},Li={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},Ug=0,ru=1,Pg=2,Dd=1,Dg=2,zr=3,gr=0,Ke=1,Mi=2,Fd=1,Yn=0,hr=1,su=2,au=3,ou=4,Fg=5,tr=100,Bg=101,Hg=102,lu=103,cu=104,qg=200,Jg=201,Og=202,Gg=203,Bd=204,Hd=205,jg=206,Xg=207,Kg=208,Zg=209,zg=210,Qg=0,_g=1,Yg=2,vl=3,$g=4,ty=5,ey=6,ny=7,Oa=0,iy=1,ry=2,Ln=0,sy=1,ay=2,oy=3,qd=4,ly=5,Jd=300,yr=301,Ar=302,bl=303,Tl=304,Ga=306,zn=1e3,He=1001,Ml=1002,ae=1003,uu=1004,hu=1005,Pe=1006,cy=1007,ja=1008,wi=1009,uy=1010,hy=1011,ps=1012,dy=1013,ya=1014,Cn=1015,vi=1016,fy=1017,py=1018,dr=1020,my=1021,gy=1022,qe=1023,yy=1024,Ay=1025,bi=1026,Sr=1027,Sy=1028,xy=1029,vy=1030,by=1031,Ty=1033,go=33776,yo=33777,Ao=33778,So=33779,du=35840,fu=35841,pu=35842,mu=35843,My=36196,gu=37492,yu=37496,Au=37808,Su=37809,xu=37810,vu=37811,bu=37812,Tu=37813,Mu=37814,wu=37815,Iu=37816,ku=37817,Ru=37818,Eu=37819,Wu=37820,Cu=37821,Lu=36492,wy=2200,Iy=2201,ky=2202,ka=2300,Ra=2301,xo=2302,ir=2400,rr=2401,Ea=2402,sc=2500,Od=2501,Ry=0,Vn=3e3,ee=3001,Ey=3200,Wy=3201,wr=0,Cy=1,En="srgb",yi="srgb-linear",vo=7680,Ly=519,ms=35044,Wa=35048,Nu="300 es",wl=1035;class ri{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[t]===void 0&&(n[t]=[]),n[t].indexOf(e)===-1&&n[t].push(e)}hasEventListener(t,e){if(this._listeners===void 0)return!1;const n=this._listeners;return n[t]!==void 0&&n[t].indexOf(e)!==-1}removeEventListener(t,e){if(this._listeners===void 0)return;const r=this._listeners[t];if(r!==void 0){const s=r.indexOf(e);s!==-1&&r.splice(s,1)}}dispatchEvent(t){if(this._listeners===void 0)return;const n=this._listeners[t.type];if(n!==void 0){t.target=this;const r=n.slice(0);for(let s=0,a=r.length;s<a;s++)r[s].call(this,t);t.target=null}}}const ye=[];for(let i=0;i<256;i++)ye[i]=(i<16?"0":"")+i.toString(16);let Vu=1234567;const is=Math.PI/180,gs=180/Math.PI;function rn(){const i=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(ye[i&255]+ye[i>>8&255]+ye[i>>16&255]+ye[i>>24&255]+"-"+ye[t&255]+ye[t>>8&255]+"-"+ye[t>>16&15|64]+ye[t>>24&255]+"-"+ye[e&63|128]+ye[e>>8&255]+"-"+ye[e>>16&255]+ye[e>>24&255]+ye[n&255]+ye[n>>8&255]+ye[n>>16&255]+ye[n>>24&255]).toLowerCase()}function fe(i,t,e){return Math.max(t,Math.min(e,i))}function ac(i,t){return(i%t+t)%t}function Ny(i,t,e,n,r){return n+(i-t)*(r-n)/(e-t)}function Vy(i,t,e){return i!==t?(e-i)/(t-i):0}function rs(i,t,e){return(1-e)*i+e*t}function Uy(i,t,e,n){return rs(i,t,1-Math.exp(-e*n))}function Py(i,t=1){return t-Math.abs(ac(i,t*2)-t)}function Dy(i,t,e){return i<=t?0:i>=e?1:(i=(i-t)/(e-t),i*i*(3-2*i))}function Fy(i,t,e){return i<=t?0:i>=e?1:(i=(i-t)/(e-t),i*i*i*(i*(i*6-15)+10))}function By(i,t){return i+Math.floor(Math.random()*(t-i+1))}function Hy(i,t){return i+Math.random()*(t-i)}function qy(i){return i*(.5-Math.random())}function Jy(i){i!==void 0&&(Vu=i);let t=Vu+=1831565813;return t=Math.imul(t^t>>>15,t|1),t^=t+Math.imul(t^t>>>7,t|61),((t^t>>>14)>>>0)/4294967296}function Oy(i){return i*is}function Gy(i){return i*gs}function Il(i){return(i&i-1)===0&&i!==0}function jy(i){return Math.pow(2,Math.ceil(Math.log(i)/Math.LN2))}function Ca(i){return Math.pow(2,Math.floor(Math.log(i)/Math.LN2))}function Xy(i,t,e,n,r){const s=Math.cos,a=Math.sin,o=s(e/2),l=a(e/2),c=s((t+n)/2),u=a((t+n)/2),h=s((t-n)/2),d=a((t-n)/2),m=s((n-t)/2),g=a((n-t)/2);switch(r){case"XYX":i.set(o*u,l*h,l*d,o*c);break;case"YZY":i.set(l*d,o*u,l*h,o*c);break;case"ZXZ":i.set(l*h,l*d,o*u,o*c);break;case"XZX":i.set(o*u,l*g,l*m,o*c);break;case"YXY":i.set(l*m,o*u,l*g,o*c);break;case"ZYZ":i.set(l*g,l*m,o*u,o*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+r)}}function Ky(i,t){switch(t.constructor){case Float32Array:return i;case Uint16Array:return i/65535;case Uint8Array:return i/255;case Int16Array:return Math.max(i/32767,-1);case Int8Array:return Math.max(i/127,-1);default:throw new Error("Invalid component type.")}}function Zy(i,t){switch(t.constructor){case Float32Array:return i;case Uint16Array:return Math.round(i*65535);case Uint8Array:return Math.round(i*255);case Int16Array:return Math.round(i*32767);case Int8Array:return Math.round(i*127);default:throw new Error("Invalid component type.")}}var Uu=Object.freeze({__proto__:null,DEG2RAD:is,RAD2DEG:gs,generateUUID:rn,clamp:fe,euclideanModulo:ac,mapLinear:Ny,inverseLerp:Vy,lerp:rs,damp:Uy,pingpong:Py,smoothstep:Dy,smootherstep:Fy,randInt:By,randFloat:Hy,randFloatSpread:qy,seededRandom:Jy,degToRad:Oy,radToDeg:Gy,isPowerOfTwo:Il,ceilPowerOfTwo:jy,floorPowerOfTwo:Ca,setQuaternionFromProperEuler:Xy,normalize:Zy,denormalize:Ky});class ct{constructor(t=0,e=0){this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,r=t.elements;return this.x=r[0]*e+r[3]*n+r[6],this.y=r[1]*e+r[4]*n+r[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),r=Math.sin(e),s=this.x-t.x,a=this.y-t.y;return this.x=s*n-a*r+t.x,this.y=s*r+a*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}ct.prototype.isVector2=!0;class xe{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,r,s,a,o,l,c){const u=this.elements;return u[0]=t,u[1]=r,u[2]=o,u[3]=e,u[4]=s,u[5]=l,u[6]=n,u[7]=a,u[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,r=e.elements,s=this.elements,a=n[0],o=n[3],l=n[6],c=n[1],u=n[4],h=n[7],d=n[2],m=n[5],g=n[8],p=r[0],f=r[3],y=r[6],M=r[1],E=r[4],R=r[7],b=r[2],D=r[5],U=r[8];return s[0]=a*p+o*M+l*b,s[3]=a*f+o*E+l*D,s[6]=a*y+o*R+l*U,s[1]=c*p+u*M+h*b,s[4]=c*f+u*E+h*D,s[7]=c*y+u*R+h*U,s[2]=d*p+m*M+g*b,s[5]=d*f+m*E+g*D,s[8]=d*y+m*R+g*U,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],r=t[2],s=t[3],a=t[4],o=t[5],l=t[6],c=t[7],u=t[8];return e*a*u-e*o*c-n*s*u+n*o*l+r*s*c-r*a*l}invert(){const t=this.elements,e=t[0],n=t[1],r=t[2],s=t[3],a=t[4],o=t[5],l=t[6],c=t[7],u=t[8],h=u*a-o*c,d=o*l-u*s,m=c*s-a*l,g=e*h+n*d+r*m;if(g===0)return this.set(0,0,0,0,0,0,0,0,0);const p=1/g;return t[0]=h*p,t[1]=(r*c-u*n)*p,t[2]=(o*n-r*a)*p,t[3]=d*p,t[4]=(u*e-r*l)*p,t[5]=(r*s-o*e)*p,t[6]=m*p,t[7]=(n*l-c*e)*p,t[8]=(a*e-n*s)*p,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,r,s,a,o){const l=Math.cos(s),c=Math.sin(s);return this.set(n*l,n*c,-n*(l*a+c*o)+a+t,-r*c,r*l,-r*(-c*a+l*o)+o+e,0,0,1),this}scale(t,e){const n=this.elements;return n[0]*=t,n[3]*=t,n[6]*=t,n[1]*=e,n[4]*=e,n[7]*=e,this}rotate(t){const e=Math.cos(t),n=Math.sin(t),r=this.elements,s=r[0],a=r[3],o=r[6],l=r[1],c=r[4],u=r[7];return r[0]=e*s+n*l,r[3]=e*a+n*c,r[6]=e*o+n*u,r[1]=-n*s+e*l,r[4]=-n*a+e*c,r[7]=-n*o+e*u,this}translate(t,e){const n=this.elements;return n[0]+=t*n[2],n[3]+=t*n[5],n[6]+=t*n[8],n[1]+=e*n[2],n[4]+=e*n[5],n[7]+=e*n[8],this}equals(t){const e=this.elements,n=t.elements;for(let r=0;r<9;r++)if(e[r]!==n[r])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return new this.constructor().fromArray(this.elements)}}xe.prototype.isMatrix3=!0;function Gd(i){for(let t=i.length-1;t>=0;--t)if(i[t]>65535)return!0;return!1}function ys(i){return document.createElementNS("http://www.w3.org/1999/xhtml",i)}function Ti(i){return i<.04045?i*.0773993808:Math.pow(i*.9478672986+.0521327014,2.4)}function Aa(i){return i<.0031308?i*12.92:1.055*Math.pow(i,.41666)-.055}const bo={[En]:{[yi]:Ti},[yi]:{[En]:Aa}},Qe={legacyMode:!0,get workingColorSpace(){return yi},set workingColorSpace(i){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(i,t,e){if(this.legacyMode||t===e||!t||!e)return i;if(bo[t]&&bo[t][e]!==void 0){const n=bo[t][e];return i.r=n(i.r),i.g=n(i.g),i.b=n(i.b),i}throw new Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(i,t){return this.convert(i,this.workingColorSpace,t)},toWorkingColorSpace:function(i,t){return this.convert(i,t,this.workingColorSpace)}},jd={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},ue={r:0,g:0,b:0},_e={h:0,s:0,l:0},Us={h:0,s:0,l:0};function To(i,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?i+(t-i)*6*e:e<1/2?t:e<2/3?i+(t-i)*6*(2/3-e):i}function Ps(i,t){return t.r=i.r,t.g=i.g,t.b=i.b,t}class Mt{constructor(t,e,n){return e===void 0&&n===void 0?this.set(t):this.setRGB(t,e,n)}set(t){return t&&t.isColor?this.copy(t):typeof t=="number"?this.setHex(t):typeof t=="string"&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=En){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,Qe.toWorkingColorSpace(this,e),this}setRGB(t,e,n,r=yi){return this.r=t,this.g=e,this.b=n,Qe.toWorkingColorSpace(this,r),this}setHSL(t,e,n,r=yi){if(t=ac(t,1),e=fe(e,0,1),n=fe(n,0,1),e===0)this.r=this.g=this.b=n;else{const s=n<=.5?n*(1+e):n+e-n*e,a=2*n-s;this.r=To(a,s,t+1/3),this.g=To(a,s,t),this.b=To(a,s,t-1/3)}return Qe.toWorkingColorSpace(this,r),this}setStyle(t,e=En){function n(s){s!==void 0&&parseFloat(s)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let r;if(r=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let s;const a=r[1],o=r[2];switch(a){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(255,parseInt(s[1],10))/255,this.g=Math.min(255,parseInt(s[2],10))/255,this.b=Math.min(255,parseInt(s[3],10))/255,Qe.toWorkingColorSpace(this,e),n(s[4]),this;if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(100,parseInt(s[1],10))/100,this.g=Math.min(100,parseInt(s[2],10))/100,this.b=Math.min(100,parseInt(s[3],10))/100,Qe.toWorkingColorSpace(this,e),n(s[4]),this;break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)){const l=parseFloat(s[1])/360,c=parseInt(s[2],10)/100,u=parseInt(s[3],10)/100;return n(s[4]),this.setHSL(l,c,u,e)}break}}else if(r=/^\#([A-Fa-f\d]+)$/.exec(t)){const s=r[1],a=s.length;if(a===3)return this.r=parseInt(s.charAt(0)+s.charAt(0),16)/255,this.g=parseInt(s.charAt(1)+s.charAt(1),16)/255,this.b=parseInt(s.charAt(2)+s.charAt(2),16)/255,Qe.toWorkingColorSpace(this,e),this;if(a===6)return this.r=parseInt(s.charAt(0)+s.charAt(1),16)/255,this.g=parseInt(s.charAt(2)+s.charAt(3),16)/255,this.b=parseInt(s.charAt(4)+s.charAt(5),16)/255,Qe.toWorkingColorSpace(this,e),this}return t&&t.length>0?this.setColorName(t,e):this}setColorName(t,e=En){const n=jd[t.toLowerCase()];return n!==void 0?this.setHex(n,e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=Ti(t.r),this.g=Ti(t.g),this.b=Ti(t.b),this}copyLinearToSRGB(t){return this.r=Aa(t.r),this.g=Aa(t.g),this.b=Aa(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=En){return Qe.fromWorkingColorSpace(Ps(this,ue),t),fe(ue.r*255,0,255)<<16^fe(ue.g*255,0,255)<<8^fe(ue.b*255,0,255)<<0}getHexString(t=En){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=yi){Qe.fromWorkingColorSpace(Ps(this,ue),e);const n=ue.r,r=ue.g,s=ue.b,a=Math.max(n,r,s),o=Math.min(n,r,s);let l,c;const u=(o+a)/2;if(o===a)l=0,c=0;else{const h=a-o;switch(c=u<=.5?h/(a+o):h/(2-a-o),a){case n:l=(r-s)/h+(r<s?6:0);break;case r:l=(s-n)/h+2;break;case s:l=(n-r)/h+4;break}l/=6}return t.h=l,t.s=c,t.l=u,t}getRGB(t,e=yi){return Qe.fromWorkingColorSpace(Ps(this,ue),e),t.r=ue.r,t.g=ue.g,t.b=ue.b,t}getStyle(t=En){return Qe.fromWorkingColorSpace(Ps(this,ue),t),t!==En?`color(${t} ${ue.r} ${ue.g} ${ue.b})`:`rgb(${ue.r*255|0},${ue.g*255|0},${ue.b*255|0})`}offsetHSL(t,e,n){return this.getHSL(_e),_e.h+=t,_e.s+=e,_e.l+=n,this.setHSL(_e.h,_e.s,_e.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(_e),t.getHSL(Us);const n=rs(_e.h,Us.h,e),r=rs(_e.s,Us.s,e),s=rs(_e.l,Us.l,e);return this.setHSL(n,r,s),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),t.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}Mt.NAMES=jd;Mt.prototype.isColor=!0;Mt.prototype.r=1;Mt.prototype.g=1;Mt.prototype.b=1;let Ni;class Ii{static getDataURL(t){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement=="undefined")return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{Ni===void 0&&(Ni=ys("canvas")),Ni.width=t.width,Ni.height=t.height;const n=Ni.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=Ni}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}static sRGBToLinear(t){if(typeof HTMLImageElement!="undefined"&&t instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&t instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&t instanceof ImageBitmap){const e=ys("canvas");e.width=t.width,e.height=t.height;const n=e.getContext("2d");n.drawImage(t,0,0,t.width,t.height);const r=n.getImageData(0,0,t.width,t.height),s=r.data;for(let a=0;a<s.length;a++)s[a]=Ti(s[a]/255)*255;return n.putImageData(r,0,0),e}else if(t.data){const e=t.data.slice(0);for(let n=0;n<e.length;n++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[n]=Math.floor(Ti(e[n]/255)*255):e[n]=Ti(e[n]);return{data:e,width:t.width,height:t.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}class Xd{constructor(t=null){this.uuid=rn(),this.data=t,this.version=0}set needsUpdate(t){t===!0&&this.version++}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.images[this.uuid]!==void 0)return t.images[this.uuid];const n={uuid:this.uuid,url:""},r=this.data;if(r!==null){let s;if(Array.isArray(r)){s=[];for(let a=0,o=r.length;a<o;a++)r[a].isDataTexture?s.push(Mo(r[a].image)):s.push(Mo(r[a]))}else s=Mo(r);n.url=s}return e||(t.images[this.uuid]=n),n}}function Mo(i){return typeof HTMLImageElement!="undefined"&&i instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&i instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&i instanceof ImageBitmap?Ii.getDataURL(i):i.data?{data:Array.prototype.slice.call(i.data),width:i.width,height:i.height,type:i.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}Xd.prototype.isSource=!0;let zy=0;class ge extends ri{constructor(t=ge.DEFAULT_IMAGE,e=ge.DEFAULT_MAPPING,n=He,r=He,s=Pe,a=ja,o=qe,l=wi,c=1,u=Vn){super();Object.defineProperty(this,"id",{value:zy++}),this.uuid=rn(),this.name="",this.source=new Xd(t),this.mipmaps=[],this.mapping=e,this.wrapS=n,this.wrapT=r,this.magFilter=s,this.minFilter=a,this.anisotropy=c,this.format=o,this.internalFormat=null,this.type=l,this.offset=new ct(0,0),this.repeat=new ct(1,1),this.center=new ct(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new xe,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=u,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(t){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData),e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==Jd)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case zn:t.x=t.x-Math.floor(t.x);break;case He:t.x=t.x<0?0:1;break;case Ml:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case zn:t.y=t.y-Math.floor(t.y);break;case He:t.y=t.y<0?0:1;break;case Ml:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&(this.version++,this.source.needsUpdate=!0)}}ge.DEFAULT_IMAGE=null;ge.DEFAULT_MAPPING=Jd;ge.prototype.isTexture=!0;class Kt{constructor(t=0,e=0,n=0,r=1){this.x=t,this.y=e,this.z=n,this.w=r}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,r){return this.x=t,this.y=e,this.z=n,this.w=r,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,r=this.z,s=this.w,a=t.elements;return this.x=a[0]*e+a[4]*n+a[8]*r+a[12]*s,this.y=a[1]*e+a[5]*n+a[9]*r+a[13]*s,this.z=a[2]*e+a[6]*n+a[10]*r+a[14]*s,this.w=a[3]*e+a[7]*n+a[11]*r+a[15]*s,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,r,s;const l=t.elements,c=l[0],u=l[4],h=l[8],d=l[1],m=l[5],g=l[9],p=l[2],f=l[6],y=l[10];if(Math.abs(u-d)<.01&&Math.abs(h-p)<.01&&Math.abs(g-f)<.01){if(Math.abs(u+d)<.1&&Math.abs(h+p)<.1&&Math.abs(g+f)<.1&&Math.abs(c+m+y-3)<.1)return this.set(1,0,0,0),this;e=Math.PI;const E=(c+1)/2,R=(m+1)/2,b=(y+1)/2,D=(u+d)/4,U=(h+p)/4,X=(g+f)/4;return E>R&&E>b?E<.01?(n=0,r=.707106781,s=.707106781):(n=Math.sqrt(E),r=D/n,s=U/n):R>b?R<.01?(n=.707106781,r=0,s=.707106781):(r=Math.sqrt(R),n=D/r,s=X/r):b<.01?(n=.707106781,r=.707106781,s=0):(s=Math.sqrt(b),n=U/s,r=X/s),this.set(n,r,s,e),this}let M=Math.sqrt((f-g)*(f-g)+(h-p)*(h-p)+(d-u)*(d-u));return Math.abs(M)<.001&&(M=1),this.x=(f-g)/M,this.y=(h-p)/M,this.z=(d-u)/M,this.w=Math.acos((c+m+y-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}Kt.prototype.isVector4=!0;class We extends ri{constructor(t,e,n={}){super();this.width=t,this.height=e,this.depth=1,this.scissor=new Kt(0,0,t,e),this.scissorTest=!1,this.viewport=new Kt(0,0,t,e);const r={width:t,height:e,depth:1};this.texture=new ge(r,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=n.generateMipmaps!==void 0?n.generateMipmaps:!1,this.texture.internalFormat=n.internalFormat!==void 0?n.internalFormat:null,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:Pe,this.depthBuffer=n.depthBuffer!==void 0?n.depthBuffer:!0,this.stencilBuffer=n.stencilBuffer!==void 0?n.stencilBuffer:!1,this.depthTexture=n.depthTexture!==void 0?n.depthTexture:null,this.samples=n.samples!==void 0?n.samples:0}setSize(t,e,n=1){(this.width!==t||this.height!==e||this.depth!==n)&&(this.width=t,this.height=e,this.depth=n,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.texture.isRenderTargetTexture=!0,this.texture.image=Object.assign({},t.texture.image),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,t.depthTexture!==null&&(this.depthTexture=t.depthTexture.clone()),this.samples=t.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}We.prototype.isWebGLRenderTarget=!0;class Xa extends ge{constructor(t=null,e=1,n=1,r=1){super(null);this.image={data:t,width:e,height:n,depth:r},this.magFilter=ae,this.minFilter=ae,this.wrapR=He,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}Xa.prototype.isDataArrayTexture=!0;class Qy extends We{constructor(t,e,n){super(t,e);this.depth=n,this.texture=new Xa(null,t,e,n),this.texture.isRenderTargetTexture=!0}}Qy.prototype.isWebGLArrayRenderTarget=!0;class oc extends ge{constructor(t=null,e=1,n=1,r=1){super(null);this.image={data:t,width:e,height:n,depth:r},this.magFilter=ae,this.minFilter=ae,this.wrapR=He,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}oc.prototype.isData3DTexture=!0;class _y extends We{constructor(t,e,n){super(t,e);this.depth=n,this.texture=new oc(null,t,e,n),this.texture.isRenderTargetTexture=!0}}_y.prototype.isWebGL3DRenderTarget=!0;class Yy extends We{constructor(t,e,n,r={}){super(t,e,r);const s=this.texture;this.texture=[];for(let a=0;a<n;a++)this.texture[a]=s.clone(),this.texture[a].isRenderTargetTexture=!0}setSize(t,e,n=1){if(this.width!==t||this.height!==e||this.depth!==n){this.width=t,this.height=e,this.depth=n;for(let r=0,s=this.texture.length;r<s;r++)this.texture[r].image.width=t,this.texture[r].image.height=e,this.texture[r].image.depth=n;this.dispose()}return this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e),this}copy(t){this.dispose(),this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this.texture.length=0;for(let e=0,n=t.texture.length;e<n;e++)this.texture[e]=t.texture[e].clone();return this}}Yy.prototype.isWebGLMultipleRenderTargets=!0;class Me{constructor(t=0,e=0,n=0,r=1){this._x=t,this._y=e,this._z=n,this._w=r}static slerp(t,e,n,r){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(t,e,r)}static slerpFlat(t,e,n,r,s,a,o){let l=n[r+0],c=n[r+1],u=n[r+2],h=n[r+3];const d=s[a+0],m=s[a+1],g=s[a+2],p=s[a+3];if(o===0){t[e+0]=l,t[e+1]=c,t[e+2]=u,t[e+3]=h;return}if(o===1){t[e+0]=d,t[e+1]=m,t[e+2]=g,t[e+3]=p;return}if(h!==p||l!==d||c!==m||u!==g){let f=1-o;const y=l*d+c*m+u*g+h*p,M=y>=0?1:-1,E=1-y*y;if(E>Number.EPSILON){const b=Math.sqrt(E),D=Math.atan2(b,y*M);f=Math.sin(f*D)/b,o=Math.sin(o*D)/b}const R=o*M;if(l=l*f+d*R,c=c*f+m*R,u=u*f+g*R,h=h*f+p*R,f===1-o){const b=1/Math.sqrt(l*l+c*c+u*u+h*h);l*=b,c*=b,u*=b,h*=b}}t[e]=l,t[e+1]=c,t[e+2]=u,t[e+3]=h}static multiplyQuaternionsFlat(t,e,n,r,s,a){const o=n[r],l=n[r+1],c=n[r+2],u=n[r+3],h=s[a],d=s[a+1],m=s[a+2],g=s[a+3];return t[e]=o*g+u*h+l*m-c*d,t[e+1]=l*g+u*d+c*h-o*m,t[e+2]=c*g+u*m+o*d-l*h,t[e+3]=u*g-o*h-l*d-c*m,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,r){return this._x=t,this._y=e,this._z=n,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!(t&&t.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=t._x,r=t._y,s=t._z,a=t._order,o=Math.cos,l=Math.sin,c=o(n/2),u=o(r/2),h=o(s/2),d=l(n/2),m=l(r/2),g=l(s/2);switch(a){case"XYZ":this._x=d*u*h+c*m*g,this._y=c*m*h-d*u*g,this._z=c*u*g+d*m*h,this._w=c*u*h-d*m*g;break;case"YXZ":this._x=d*u*h+c*m*g,this._y=c*m*h-d*u*g,this._z=c*u*g-d*m*h,this._w=c*u*h+d*m*g;break;case"ZXY":this._x=d*u*h-c*m*g,this._y=c*m*h+d*u*g,this._z=c*u*g+d*m*h,this._w=c*u*h-d*m*g;break;case"ZYX":this._x=d*u*h-c*m*g,this._y=c*m*h+d*u*g,this._z=c*u*g-d*m*h,this._w=c*u*h+d*m*g;break;case"YZX":this._x=d*u*h+c*m*g,this._y=c*m*h+d*u*g,this._z=c*u*g-d*m*h,this._w=c*u*h-d*m*g;break;case"XZY":this._x=d*u*h-c*m*g,this._y=c*m*h-d*u*g,this._z=c*u*g+d*m*h,this._w=c*u*h+d*m*g;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return e!==!1&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,r=Math.sin(n);return this._x=t.x*r,this._y=t.y*r,this._z=t.z*r,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],r=e[4],s=e[8],a=e[1],o=e[5],l=e[9],c=e[2],u=e[6],h=e[10],d=n+o+h;if(d>0){const m=.5/Math.sqrt(d+1);this._w=.25/m,this._x=(u-l)*m,this._y=(s-c)*m,this._z=(a-r)*m}else if(n>o&&n>h){const m=2*Math.sqrt(1+n-o-h);this._w=(u-l)/m,this._x=.25*m,this._y=(r+a)/m,this._z=(s+c)/m}else if(o>h){const m=2*Math.sqrt(1+o-n-h);this._w=(s-c)/m,this._x=(r+a)/m,this._y=.25*m,this._z=(l+u)/m}else{const m=2*Math.sqrt(1+h-n-o);this._w=(a-r)/m,this._x=(s+c)/m,this._y=(l+u)/m,this._z=.25*m}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(fe(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(n===0)return this;const r=Math.min(1,e/n);return this.slerp(t,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return e!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,r=t._y,s=t._z,a=t._w,o=e._x,l=e._y,c=e._z,u=e._w;return this._x=n*u+a*o+r*c-s*l,this._y=r*u+a*l+s*o-n*c,this._z=s*u+a*c+n*l-r*o,this._w=a*u-n*o-r*l-s*c,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const n=this._x,r=this._y,s=this._z,a=this._w;let o=a*t._w+n*t._x+r*t._y+s*t._z;if(o<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,o=-o):this.copy(t),o>=1)return this._w=a,this._x=n,this._y=r,this._z=s,this;const l=1-o*o;if(l<=Number.EPSILON){const m=1-e;return this._w=m*a+e*this._w,this._x=m*n+e*this._x,this._y=m*r+e*this._y,this._z=m*s+e*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(l),u=Math.atan2(c,o),h=Math.sin((1-e)*u)/c,d=Math.sin(e*u)/c;return this._w=a*h+this._w*d,this._x=n*h+this._x*d,this._y=r*h+this._y*d,this._z=s*h+this._z*d,this._onChangeCallback(),this}slerpQuaternions(t,e,n){return this.copy(t).slerp(e,n)}random(){const t=Math.random(),e=Math.sqrt(1-t),n=Math.sqrt(t),r=2*Math.PI*Math.random(),s=2*Math.PI*Math.random();return this.set(e*Math.cos(r),n*Math.sin(s),n*Math.cos(s),e*Math.sin(r))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}Me.prototype.isQuaternion=!0;class k{constructor(t=0,e=0,n=0){this.x=t,this.y=e,this.z=n}set(t,e,n){return n===void 0&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(Pu.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(Pu.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,r=this.z,s=t.elements;return this.x=s[0]*e+s[3]*n+s[6]*r,this.y=s[1]*e+s[4]*n+s[7]*r,this.z=s[2]*e+s[5]*n+s[8]*r,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,r=this.z,s=t.elements,a=1/(s[3]*e+s[7]*n+s[11]*r+s[15]);return this.x=(s[0]*e+s[4]*n+s[8]*r+s[12])*a,this.y=(s[1]*e+s[5]*n+s[9]*r+s[13])*a,this.z=(s[2]*e+s[6]*n+s[10]*r+s[14])*a,this}applyQuaternion(t){const e=this.x,n=this.y,r=this.z,s=t.x,a=t.y,o=t.z,l=t.w,c=l*e+a*r-o*n,u=l*n+o*e-s*r,h=l*r+s*n-a*e,d=-s*e-a*n-o*r;return this.x=c*l+d*-s+u*-o-h*-a,this.y=u*l+d*-a+h*-s-c*-o,this.z=h*l+d*-o+c*-a-u*-s,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,r=this.z,s=t.elements;return this.x=s[0]*e+s[4]*n+s[8]*r,this.y=s[1]*e+s[5]*n+s[9]*r,this.z=s[2]*e+s[6]*n+s[10]*r,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t,e){return e!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,r=t.y,s=t.z,a=e.x,o=e.y,l=e.z;return this.x=r*l-s*o,this.y=s*a-n*l,this.z=n*o-r*a,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return wo.copy(this).projectOnVector(t),this.sub(wo)}reflect(t){return this.sub(wo.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(fe(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,r=this.z-t.z;return e*e+n*n+r*r}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const r=Math.sin(e)*t;return this.x=r*Math.sin(n),this.y=Math.cos(e)*t,this.z=r*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),r=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=r,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=(Math.random()-.5)*2,e=Math.random()*Math.PI*2,n=Math.sqrt(1-t**2);return this.x=n*Math.cos(e),this.y=n*Math.sin(e),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}k.prototype.isVector3=!0;const wo=new k,Pu=new Me;class sn{constructor(t=new k(1/0,1/0,1/0),e=new k(-1/0,-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,n=1/0,r=1/0,s=-1/0,a=-1/0,o=-1/0;for(let l=0,c=t.length;l<c;l+=3){const u=t[l],h=t[l+1],d=t[l+2];u<e&&(e=u),h<n&&(n=h),d<r&&(r=d),u>s&&(s=u),h>a&&(a=h),d>o&&(o=d)}return this.min.set(e,n,r),this.max.set(s,a,o),this}setFromBufferAttribute(t){let e=1/0,n=1/0,r=1/0,s=-1/0,a=-1/0,o=-1/0;for(let l=0,c=t.count;l<c;l++){const u=t.getX(l),h=t.getY(l),d=t.getZ(l);u<e&&(e=u),h<n&&(n=h),d<r&&(r=d),u>s&&(s=u),h>a&&(a=h),d>o&&(o=d)}return this.min.set(e,n,r),this.max.set(s,a,o),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=ci.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const n=t.geometry;if(n!==void 0)if(e&&n.attributes!=null&&n.attributes.position!==void 0){const s=n.attributes.position;for(let a=0,o=s.count;a<o;a++)ci.fromBufferAttribute(s,a).applyMatrix4(t.matrixWorld),this.expandByPoint(ci)}else n.boundingBox===null&&n.computeBoundingBox(),Io.copy(n.boundingBox),Io.applyMatrix4(t.matrixWorld),this.union(Io);const r=t.children;for(let s=0,a=r.length;s<a;s++)this.expandByObject(r[s],e);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,ci),ci.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Dr),Ds.subVectors(this.max,Dr),Vi.subVectors(t.a,Dr),Ui.subVectors(t.b,Dr),Pi.subVectors(t.c,Dr),Fn.subVectors(Ui,Vi),Bn.subVectors(Pi,Ui),ui.subVectors(Vi,Pi);let e=[0,-Fn.z,Fn.y,0,-Bn.z,Bn.y,0,-ui.z,ui.y,Fn.z,0,-Fn.x,Bn.z,0,-Bn.x,ui.z,0,-ui.x,-Fn.y,Fn.x,0,-Bn.y,Bn.x,0,-ui.y,ui.x,0];return!ko(e,Vi,Ui,Pi,Ds)||(e=[1,0,0,0,1,0,0,0,1],!ko(e,Vi,Ui,Pi,Ds))?!1:(Fs.crossVectors(Fn,Bn),e=[Fs.x,Fs.y,Fs.z],ko(e,Vi,Ui,Pi,Ds))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return ci.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return this.getCenter(t.center),t.radius=this.getSize(ci).length()*.5,t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(vn[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),vn[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),vn[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),vn[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),vn[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),vn[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),vn[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),vn[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(vn),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}sn.prototype.isBox3=!0;const vn=[new k,new k,new k,new k,new k,new k,new k,new k],ci=new k,Io=new sn,Vi=new k,Ui=new k,Pi=new k,Fn=new k,Bn=new k,ui=new k,Dr=new k,Ds=new k,Fs=new k,hi=new k;function ko(i,t,e,n,r){for(let s=0,a=i.length-3;s<=a;s+=3){hi.fromArray(i,s);const o=r.x*Math.abs(hi.x)+r.y*Math.abs(hi.y)+r.z*Math.abs(hi.z),l=t.dot(hi),c=e.dot(hi),u=n.dot(hi);if(Math.max(-Math.max(l,c,u),Math.min(l,c,u))>o)return!1}return!0}const $y=new sn,Du=new k,Bs=new k,Ro=new k;class Ir{constructor(t=new k,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;e!==void 0?n.copy(e):$y.setFromPoints(t).getCenter(n);let r=0;for(let s=0,a=t.length;s<a;s++)r=Math.max(r,n.distanceToSquared(t[s]));return this.radius=Math.sqrt(r),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){Ro.subVectors(t,this.center);const e=Ro.lengthSq();if(e>this.radius*this.radius){const n=Math.sqrt(e),r=(n-this.radius)*.5;this.center.add(Ro.multiplyScalar(r/n)),this.radius+=r}return this}union(t){return this.center.equals(t.center)===!0?Bs.set(0,0,1).multiplyScalar(t.radius):Bs.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint(Du.copy(t.center).add(Bs)),this.expandByPoint(Du.copy(t.center).sub(Bs)),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}const bn=new k,Eo=new k,Hs=new k,Hn=new k,Wo=new k,qs=new k,Co=new k;class kr{constructor(t=new k,e=new k(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,bn)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=bn.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(bn.copy(this.direction).multiplyScalar(e).add(this.origin),bn.distanceToSquared(t))}distanceSqToSegment(t,e,n,r){Eo.copy(t).add(e).multiplyScalar(.5),Hs.copy(e).sub(t).normalize(),Hn.copy(this.origin).sub(Eo);const s=t.distanceTo(e)*.5,a=-this.direction.dot(Hs),o=Hn.dot(this.direction),l=-Hn.dot(Hs),c=Hn.lengthSq(),u=Math.abs(1-a*a);let h,d,m,g;if(u>0)if(h=a*l-o,d=a*o-l,g=s*u,h>=0)if(d>=-g)if(d<=g){const p=1/u;h*=p,d*=p,m=h*(h+a*d+2*o)+d*(a*h+d+2*l)+c}else d=s,h=Math.max(0,-(a*d+o)),m=-h*h+d*(d+2*l)+c;else d=-s,h=Math.max(0,-(a*d+o)),m=-h*h+d*(d+2*l)+c;else d<=-g?(h=Math.max(0,-(-a*s+o)),d=h>0?-s:Math.min(Math.max(-s,-l),s),m=-h*h+d*(d+2*l)+c):d<=g?(h=0,d=Math.min(Math.max(-s,-l),s),m=d*(d+2*l)+c):(h=Math.max(0,-(a*s+o)),d=h>0?s:Math.min(Math.max(-s,-l),s),m=-h*h+d*(d+2*l)+c);else d=a>0?-s:s,h=Math.max(0,-(a*d+o)),m=-h*h+d*(d+2*l)+c;return n&&n.copy(this.direction).multiplyScalar(h).add(this.origin),r&&r.copy(Hs).multiplyScalar(d).add(Eo),m}intersectSphere(t,e){bn.subVectors(t.center,this.origin);const n=bn.dot(this.direction),r=bn.dot(bn)-n*n,s=t.radius*t.radius;if(r>s)return null;const a=Math.sqrt(s-r),o=n-a,l=n+a;return o<0&&l<0?null:o<0?this.at(l,e):this.at(o,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return n===null?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,r,s,a,o,l;const c=1/this.direction.x,u=1/this.direction.y,h=1/this.direction.z,d=this.origin;return c>=0?(n=(t.min.x-d.x)*c,r=(t.max.x-d.x)*c):(n=(t.max.x-d.x)*c,r=(t.min.x-d.x)*c),u>=0?(s=(t.min.y-d.y)*u,a=(t.max.y-d.y)*u):(s=(t.max.y-d.y)*u,a=(t.min.y-d.y)*u),n>a||s>r||((s>n||n!==n)&&(n=s),(a<r||r!==r)&&(r=a),h>=0?(o=(t.min.z-d.z)*h,l=(t.max.z-d.z)*h):(o=(t.max.z-d.z)*h,l=(t.min.z-d.z)*h),n>l||o>r)||((o>n||n!==n)&&(n=o),(l<r||r!==r)&&(r=l),r<0)?null:this.at(n>=0?n:r,e)}intersectsBox(t){return this.intersectBox(t,bn)!==null}intersectTriangle(t,e,n,r,s){Wo.subVectors(e,t),qs.subVectors(n,t),Co.crossVectors(Wo,qs);let a=this.direction.dot(Co),o;if(a>0){if(r)return null;o=1}else if(a<0)o=-1,a=-a;else return null;Hn.subVectors(this.origin,t);const l=o*this.direction.dot(qs.crossVectors(Hn,qs));if(l<0)return null;const c=o*this.direction.dot(Wo.cross(Hn));if(c<0||l+c>a)return null;const u=-o*Hn.dot(Co);return u<0?null:this.at(u/a,s)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class It{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,r,s,a,o,l,c,u,h,d,m,g,p,f){const y=this.elements;return y[0]=t,y[4]=e,y[8]=n,y[12]=r,y[1]=s,y[5]=a,y[9]=o,y[13]=l,y[2]=c,y[6]=u,y[10]=h,y[14]=d,y[3]=m,y[7]=g,y[11]=p,y[15]=f,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new It().fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,r=1/Di.setFromMatrixColumn(t,0).length(),s=1/Di.setFromMatrixColumn(t,1).length(),a=1/Di.setFromMatrixColumn(t,2).length();return e[0]=n[0]*r,e[1]=n[1]*r,e[2]=n[2]*r,e[3]=0,e[4]=n[4]*s,e[5]=n[5]*s,e[6]=n[6]*s,e[7]=0,e[8]=n[8]*a,e[9]=n[9]*a,e[10]=n[10]*a,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const e=this.elements,n=t.x,r=t.y,s=t.z,a=Math.cos(n),o=Math.sin(n),l=Math.cos(r),c=Math.sin(r),u=Math.cos(s),h=Math.sin(s);if(t.order==="XYZ"){const d=a*u,m=a*h,g=o*u,p=o*h;e[0]=l*u,e[4]=-l*h,e[8]=c,e[1]=m+g*c,e[5]=d-p*c,e[9]=-o*l,e[2]=p-d*c,e[6]=g+m*c,e[10]=a*l}else if(t.order==="YXZ"){const d=l*u,m=l*h,g=c*u,p=c*h;e[0]=d+p*o,e[4]=g*o-m,e[8]=a*c,e[1]=a*h,e[5]=a*u,e[9]=-o,e[2]=m*o-g,e[6]=p+d*o,e[10]=a*l}else if(t.order==="ZXY"){const d=l*u,m=l*h,g=c*u,p=c*h;e[0]=d-p*o,e[4]=-a*h,e[8]=g+m*o,e[1]=m+g*o,e[5]=a*u,e[9]=p-d*o,e[2]=-a*c,e[6]=o,e[10]=a*l}else if(t.order==="ZYX"){const d=a*u,m=a*h,g=o*u,p=o*h;e[0]=l*u,e[4]=g*c-m,e[8]=d*c+p,e[1]=l*h,e[5]=p*c+d,e[9]=m*c-g,e[2]=-c,e[6]=o*l,e[10]=a*l}else if(t.order==="YZX"){const d=a*l,m=a*c,g=o*l,p=o*c;e[0]=l*u,e[4]=p-d*h,e[8]=g*h+m,e[1]=h,e[5]=a*u,e[9]=-o*u,e[2]=-c*u,e[6]=m*h+g,e[10]=d-p*h}else if(t.order==="XZY"){const d=a*l,m=a*c,g=o*l,p=o*c;e[0]=l*u,e[4]=-h,e[8]=c*u,e[1]=d*h+p,e[5]=a*u,e[9]=m*h-g,e[2]=g*h-m,e[6]=o*u,e[10]=p*h+d}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(t0,t,e0)}lookAt(t,e,n){const r=this.elements;return De.subVectors(t,e),De.lengthSq()===0&&(De.z=1),De.normalize(),qn.crossVectors(n,De),qn.lengthSq()===0&&(Math.abs(n.z)===1?De.x+=1e-4:De.z+=1e-4,De.normalize(),qn.crossVectors(n,De)),qn.normalize(),Js.crossVectors(De,qn),r[0]=qn.x,r[4]=Js.x,r[8]=De.x,r[1]=qn.y,r[5]=Js.y,r[9]=De.y,r[2]=qn.z,r[6]=Js.z,r[10]=De.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,r=e.elements,s=this.elements,a=n[0],o=n[4],l=n[8],c=n[12],u=n[1],h=n[5],d=n[9],m=n[13],g=n[2],p=n[6],f=n[10],y=n[14],M=n[3],E=n[7],R=n[11],b=n[15],D=r[0],U=r[4],X=r[8],dt=r[12],K=r[1],v=r[5],C=r[9],it=r[13],B=r[2],G=r[6],F=r[10],H=r[14],L=r[3],z=r[7],lt=r[11],ut=r[15];return s[0]=a*D+o*K+l*B+c*L,s[4]=a*U+o*v+l*G+c*z,s[8]=a*X+o*C+l*F+c*lt,s[12]=a*dt+o*it+l*H+c*ut,s[1]=u*D+h*K+d*B+m*L,s[5]=u*U+h*v+d*G+m*z,s[9]=u*X+h*C+d*F+m*lt,s[13]=u*dt+h*it+d*H+m*ut,s[2]=g*D+p*K+f*B+y*L,s[6]=g*U+p*v+f*G+y*z,s[10]=g*X+p*C+f*F+y*lt,s[14]=g*dt+p*it+f*H+y*ut,s[3]=M*D+E*K+R*B+b*L,s[7]=M*U+E*v+R*G+b*z,s[11]=M*X+E*C+R*F+b*lt,s[15]=M*dt+E*it+R*H+b*ut,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],r=t[8],s=t[12],a=t[1],o=t[5],l=t[9],c=t[13],u=t[2],h=t[6],d=t[10],m=t[14],g=t[3],p=t[7],f=t[11],y=t[15];return g*(+s*l*h-r*c*h-s*o*d+n*c*d+r*o*m-n*l*m)+p*(+e*l*m-e*c*d+s*a*d-r*a*m+r*c*u-s*l*u)+f*(+e*c*h-e*o*m-s*a*h+n*a*m+s*o*u-n*c*u)+y*(-r*o*u-e*l*h+e*o*d+r*a*h-n*a*d+n*l*u)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const r=this.elements;return t.isVector3?(r[12]=t.x,r[13]=t.y,r[14]=t.z):(r[12]=t,r[13]=e,r[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],r=t[2],s=t[3],a=t[4],o=t[5],l=t[6],c=t[7],u=t[8],h=t[9],d=t[10],m=t[11],g=t[12],p=t[13],f=t[14],y=t[15],M=h*f*c-p*d*c+p*l*m-o*f*m-h*l*y+o*d*y,E=g*d*c-u*f*c-g*l*m+a*f*m+u*l*y-a*d*y,R=u*p*c-g*h*c+g*o*m-a*p*m-u*o*y+a*h*y,b=g*h*l-u*p*l-g*o*d+a*p*d+u*o*f-a*h*f,D=e*M+n*E+r*R+s*b;if(D===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const U=1/D;return t[0]=M*U,t[1]=(p*d*s-h*f*s-p*r*m+n*f*m+h*r*y-n*d*y)*U,t[2]=(o*f*s-p*l*s+p*r*c-n*f*c-o*r*y+n*l*y)*U,t[3]=(h*l*s-o*d*s-h*r*c+n*d*c+o*r*m-n*l*m)*U,t[4]=E*U,t[5]=(u*f*s-g*d*s+g*r*m-e*f*m-u*r*y+e*d*y)*U,t[6]=(g*l*s-a*f*s-g*r*c+e*f*c+a*r*y-e*l*y)*U,t[7]=(a*d*s-u*l*s+u*r*c-e*d*c-a*r*m+e*l*m)*U,t[8]=R*U,t[9]=(g*h*s-u*p*s-g*n*m+e*p*m+u*n*y-e*h*y)*U,t[10]=(a*p*s-g*o*s+g*n*c-e*p*c-a*n*y+e*o*y)*U,t[11]=(u*o*s-a*h*s-u*n*c+e*h*c+a*n*m-e*o*m)*U,t[12]=b*U,t[13]=(u*p*r-g*h*r+g*n*d-e*p*d-u*n*f+e*h*f)*U,t[14]=(g*o*r-a*p*r-g*n*l+e*p*l+a*n*f-e*o*f)*U,t[15]=(a*h*r-u*o*r+u*n*l-e*h*l-a*n*d+e*o*d)*U,this}scale(t){const e=this.elements,n=t.x,r=t.y,s=t.z;return e[0]*=n,e[4]*=r,e[8]*=s,e[1]*=n,e[5]*=r,e[9]*=s,e[2]*=n,e[6]*=r,e[10]*=s,e[3]*=n,e[7]*=r,e[11]*=s,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],r=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,r))}makeTranslation(t,e,n){return this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),r=Math.sin(e),s=1-n,a=t.x,o=t.y,l=t.z,c=s*a,u=s*o;return this.set(c*a+n,c*o-r*l,c*l+r*o,0,c*o+r*l,u*o+n,u*l-r*a,0,c*l-r*o,u*l+r*a,s*l*l+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n,r,s,a){return this.set(1,n,s,0,t,1,a,0,e,r,1,0,0,0,0,1),this}compose(t,e,n){const r=this.elements,s=e._x,a=e._y,o=e._z,l=e._w,c=s+s,u=a+a,h=o+o,d=s*c,m=s*u,g=s*h,p=a*u,f=a*h,y=o*h,M=l*c,E=l*u,R=l*h,b=n.x,D=n.y,U=n.z;return r[0]=(1-(p+y))*b,r[1]=(m+R)*b,r[2]=(g-E)*b,r[3]=0,r[4]=(m-R)*D,r[5]=(1-(d+y))*D,r[6]=(f+M)*D,r[7]=0,r[8]=(g+E)*U,r[9]=(f-M)*U,r[10]=(1-(d+p))*U,r[11]=0,r[12]=t.x,r[13]=t.y,r[14]=t.z,r[15]=1,this}decompose(t,e,n){const r=this.elements;let s=Di.set(r[0],r[1],r[2]).length();const a=Di.set(r[4],r[5],r[6]).length(),o=Di.set(r[8],r[9],r[10]).length();this.determinant()<0&&(s=-s),t.x=r[12],t.y=r[13],t.z=r[14],Ye.copy(this);const c=1/s,u=1/a,h=1/o;return Ye.elements[0]*=c,Ye.elements[1]*=c,Ye.elements[2]*=c,Ye.elements[4]*=u,Ye.elements[5]*=u,Ye.elements[6]*=u,Ye.elements[8]*=h,Ye.elements[9]*=h,Ye.elements[10]*=h,e.setFromRotationMatrix(Ye),n.x=s,n.y=a,n.z=o,this}makePerspective(t,e,n,r,s,a){a===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const o=this.elements,l=2*s/(e-t),c=2*s/(n-r),u=(e+t)/(e-t),h=(n+r)/(n-r),d=-(a+s)/(a-s),m=-2*a*s/(a-s);return o[0]=l,o[4]=0,o[8]=u,o[12]=0,o[1]=0,o[5]=c,o[9]=h,o[13]=0,o[2]=0,o[6]=0,o[10]=d,o[14]=m,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(t,e,n,r,s,a){const o=this.elements,l=1/(e-t),c=1/(n-r),u=1/(a-s),h=(e+t)*l,d=(n+r)*c,m=(a+s)*u;return o[0]=2*l,o[4]=0,o[8]=0,o[12]=-h,o[1]=0,o[5]=2*c,o[9]=0,o[13]=-d,o[2]=0,o[6]=0,o[10]=-2*u,o[14]=-m,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let r=0;r<16;r++)if(e[r]!==n[r])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}It.prototype.isMatrix4=!0;const Di=new k,Ye=new It,t0=new k(0,0,0),e0=new k(1,1,1),qn=new k,Js=new k,De=new k,Fu=new It,Bu=new Me;class ki{constructor(t=0,e=0,n=0,r=ki.DefaultOrder){this._x=t,this._y=e,this._z=n,this._order=r}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,r=this._order){return this._x=t,this._y=e,this._z=n,this._order=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,n=!0){const r=t.elements,s=r[0],a=r[4],o=r[8],l=r[1],c=r[5],u=r[9],h=r[2],d=r[6],m=r[10];switch(e){case"XYZ":this._y=Math.asin(fe(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-u,m),this._z=Math.atan2(-a,s)):(this._x=Math.atan2(d,c),this._z=0);break;case"YXZ":this._x=Math.asin(-fe(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(o,m),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-h,s),this._z=0);break;case"ZXY":this._x=Math.asin(fe(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-h,m),this._z=Math.atan2(-a,c)):(this._y=0,this._z=Math.atan2(l,s));break;case"ZYX":this._y=Math.asin(-fe(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(d,m),this._z=Math.atan2(l,s)):(this._x=0,this._z=Math.atan2(-a,c));break;case"YZX":this._z=Math.asin(fe(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-u,c),this._y=Math.atan2(-h,s)):(this._x=0,this._y=Math.atan2(o,m));break;case"XZY":this._z=Math.asin(-fe(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(d,c),this._y=Math.atan2(o,s)):(this._x=Math.atan2(-u,m),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,n===!0&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return Fu.makeRotationFromQuaternion(t),this.setFromRotationMatrix(Fu,e,n)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return Bu.setFromEuler(this),this.setFromQuaternion(Bu,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}ki.prototype.isEuler=!0;ki.DefaultOrder="XYZ";ki.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class Kd{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!==0}isEnabled(t){return(this.mask&(1<<t|0))!==0}}let n0=0;const Hu=new k,Fi=new Me,Tn=new It,Os=new k,Fr=new k,i0=new k,r0=new Me,qu=new k(1,0,0),Ju=new k(0,1,0),Ou=new k(0,0,1),s0={type:"added"},Gu={type:"removed"};class Qt extends ri{constructor(){super();Object.defineProperty(this,"id",{value:n0++}),this.uuid=rn(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Qt.DefaultUp.clone();const t=new k,e=new ki,n=new Me,r=new k(1,1,1);function s(){n.setFromEuler(e,!1)}function a(){e.setFromQuaternion(n,void 0,!1)}e._onChange(s),n._onChange(a),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new It},normalMatrix:{value:new xe}}),this.matrix=new It,this.matrixWorld=new It,this.matrixAutoUpdate=Qt.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new Kd,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return Fi.setFromAxisAngle(t,e),this.quaternion.multiply(Fi),this}rotateOnWorldAxis(t,e){return Fi.setFromAxisAngle(t,e),this.quaternion.premultiply(Fi),this}rotateX(t){return this.rotateOnAxis(qu,t)}rotateY(t){return this.rotateOnAxis(Ju,t)}rotateZ(t){return this.rotateOnAxis(Ou,t)}translateOnAxis(t,e){return Hu.copy(t).applyQuaternion(this.quaternion),this.position.add(Hu.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(qu,t)}translateY(t){return this.translateOnAxis(Ju,t)}translateZ(t){return this.translateOnAxis(Ou,t)}localToWorld(t){return t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return t.applyMatrix4(Tn.copy(this.matrixWorld).invert())}lookAt(t,e,n){t.isVector3?Os.copy(t):Os.set(t,e,n);const r=this.parent;this.updateWorldMatrix(!0,!1),Fr.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Tn.lookAt(Fr,Os,this.up):Tn.lookAt(Os,Fr,this.up),this.quaternion.setFromRotationMatrix(Tn),r&&(Tn.extractRotation(r.matrixWorld),Fi.setFromRotationMatrix(Tn),this.quaternion.premultiply(Fi.invert()))}add(t){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.parent!==null&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(s0)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const e=this.children.indexOf(t);return e!==-1&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(Gu)),this}removeFromParent(){const t=this.parent;return t!==null&&t.remove(this),this}clear(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(Gu)}return this.children.length=0,this}attach(t){return this.updateWorldMatrix(!0,!1),Tn.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),Tn.multiply(t.parent.matrixWorld)),t.applyMatrix4(Tn),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let n=0,r=this.children.length;n<r;n++){const a=this.children[n].getObjectByProperty(t,e);if(a!==void 0)return a}}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Fr,t,i0),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Fr,r0,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let n=0,r=e.length;n<r;n++)e[n].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const e=this.children;for(let n=0,r=e.length;n<r;n++)e[n].traverseVisible(t)}traverseAncestors(t){const e=this.parent;e!==null&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,r=e.length;n<r;n++)e[n].updateMatrixWorld(t)}updateWorldMatrix(t,e){const n=this.parent;if(t===!0&&n!==null&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),e===!0){const r=this.children;for(let s=0,a=r.length;s<a;s++)r[s].updateWorldMatrix(!1,!0)}}toJSON(t){const e=t===void 0||typeof t=="string",n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const r={};r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),this.castShadow===!0&&(r.castShadow=!0),this.receiveShadow===!0&&(r.receiveShadow=!0),this.visible===!1&&(r.visible=!1),this.frustumCulled===!1&&(r.frustumCulled=!1),this.renderOrder!==0&&(r.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(r.instanceColor=this.instanceColor.toJSON()));function s(o,l){return o[l.uuid]===void 0&&(o[l.uuid]=l.toJSON(t)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?r.background=this.background.toJSON():this.background.isTexture&&(r.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&(r.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){r.geometry=s(t.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const l=o.shapes;if(Array.isArray(l))for(let c=0,u=l.length;c<u;c++){const h=l[c];s(t.shapes,h)}else s(t.shapes,l)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(t.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let l=0,c=this.material.length;l<c;l++)o.push(s(t.materials,this.material[l]));r.material=o}else r.material=s(t.materials,this.material);if(this.children.length>0){r.children=[];for(let o=0;o<this.children.length;o++)r.children.push(this.children[o].toJSON(t).object)}if(this.animations.length>0){r.animations=[];for(let o=0;o<this.animations.length;o++){const l=this.animations[o];r.animations.push(s(t.animations,l))}}if(e){const o=a(t.geometries),l=a(t.materials),c=a(t.textures),u=a(t.images),h=a(t.shapes),d=a(t.skeletons),m=a(t.animations),g=a(t.nodes);o.length>0&&(n.geometries=o),l.length>0&&(n.materials=l),c.length>0&&(n.textures=c),u.length>0&&(n.images=u),h.length>0&&(n.shapes=h),d.length>0&&(n.skeletons=d),m.length>0&&(n.animations=m),g.length>0&&(n.nodes=g)}return n.object=r,n;function a(o){const l=[];for(const c in o){const u=o[c];delete u.metadata,l.push(u)}return l}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),e===!0)for(let n=0;n<t.children.length;n++){const r=t.children[n];this.add(r.clone())}return this}}Qt.DefaultUp=new k(0,1,0);Qt.DefaultMatrixAutoUpdate=!0;Qt.prototype.isObject3D=!0;const $e=new k,Mn=new k,Lo=new k,wn=new k,Bi=new k,Hi=new k,ju=new k,No=new k,Vo=new k,Uo=new k;class ce{constructor(t=new k,e=new k,n=new k){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,r){r.subVectors(n,e),$e.subVectors(t,e),r.cross($e);const s=r.lengthSq();return s>0?r.multiplyScalar(1/Math.sqrt(s)):r.set(0,0,0)}static getBarycoord(t,e,n,r,s){$e.subVectors(r,e),Mn.subVectors(n,e),Lo.subVectors(t,e);const a=$e.dot($e),o=$e.dot(Mn),l=$e.dot(Lo),c=Mn.dot(Mn),u=Mn.dot(Lo),h=a*c-o*o;if(h===0)return s.set(-2,-1,-1);const d=1/h,m=(c*l-o*u)*d,g=(a*u-o*l)*d;return s.set(1-m-g,g,m)}static containsPoint(t,e,n,r){return this.getBarycoord(t,e,n,r,wn),wn.x>=0&&wn.y>=0&&wn.x+wn.y<=1}static getUV(t,e,n,r,s,a,o,l){return this.getBarycoord(t,e,n,r,wn),l.set(0,0),l.addScaledVector(s,wn.x),l.addScaledVector(a,wn.y),l.addScaledVector(o,wn.z),l}static isFrontFacing(t,e,n,r){return $e.subVectors(n,e),Mn.subVectors(t,e),$e.cross(Mn).dot(r)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,r){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[r]),this}setFromAttributeAndIndices(t,e,n,r){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,n),this.c.fromBufferAttribute(t,r),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return $e.subVectors(this.c,this.b),Mn.subVectors(this.a,this.b),$e.cross(Mn).length()*.5}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return ce.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return ce.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,n,r,s){return ce.getUV(t,this.a,this.b,this.c,e,n,r,s)}containsPoint(t){return ce.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return ce.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const n=this.a,r=this.b,s=this.c;let a,o;Bi.subVectors(r,n),Hi.subVectors(s,n),No.subVectors(t,n);const l=Bi.dot(No),c=Hi.dot(No);if(l<=0&&c<=0)return e.copy(n);Vo.subVectors(t,r);const u=Bi.dot(Vo),h=Hi.dot(Vo);if(u>=0&&h<=u)return e.copy(r);const d=l*h-u*c;if(d<=0&&l>=0&&u<=0)return a=l/(l-u),e.copy(n).addScaledVector(Bi,a);Uo.subVectors(t,s);const m=Bi.dot(Uo),g=Hi.dot(Uo);if(g>=0&&m<=g)return e.copy(s);const p=m*c-l*g;if(p<=0&&c>=0&&g<=0)return o=c/(c-g),e.copy(n).addScaledVector(Hi,o);const f=u*g-m*h;if(f<=0&&h-u>=0&&m-g>=0)return ju.subVectors(s,r),o=(h-u)/(h-u+(m-g)),e.copy(r).addScaledVector(ju,o);const y=1/(f+p+d);return a=p*y,o=d*y,e.copy(n).addScaledVector(Bi,a).addScaledVector(Hi,o)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}let a0=0;class he extends ri{constructor(){super();Object.defineProperty(this,"id",{value:a0++}),this.uuid=rn(),this.name="",this.type="Material",this.fog=!0,this.blending=hr,this.side=gr,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=Bd,this.blendDst=Hd,this.blendEquation=tr,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=vl,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=Ly,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=vo,this.stencilZFail=vo,this.stencilZPass=vo,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(t!==void 0)for(const e in t){const n=t[e];if(n===void 0){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if(e==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===Fd;continue}const r=this[e];if(r===void 0){console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.");continue}r&&r.isColor?r.set(n):r&&r.isVector3&&n&&n.isVector3?r.copy(n):this[e]=n}}toJSON(t){const e=t===void 0||typeof t=="string";e&&(t={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheen!==void 0&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(t).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(t).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(t).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(t).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(t).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(t).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(t).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(t).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(t).uuid),this.attenuationDistance!==void 0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(n.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==hr&&(n.blending=this.blending),this.side!==gr&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.transparent===!0&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation!==void 0&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(n.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=this.flatShading),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData);function r(s){const a=[];for(const o in s){const l=s[o];delete l.metadata,a.push(l)}return a}if(e){const s=r(t.textures),a=r(t.images);s.length>0&&(n.textures=s),a.length>0&&(n.images=a)}return n}clone(){return new this.constructor().copy(this)}copy(t){this.name=t.name,this.fog=t.fog,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(e!==null){const r=e.length;n=new Array(r);for(let s=0;s!==r;++s)n[s]=e[s].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}}he.prototype.isMaterial=!0;he.fromType=function(){return null};class Ka extends he{constructor(t){super();this.type="MeshBasicMaterial",this.color=new Mt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Oa,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}Ka.prototype.isMeshBasicMaterial=!0;const le=new k,Gs=new ct;class re{constructor(t,e,n){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=n===!0,this.usage=ms,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this}copyAt(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let r=0,s=this.itemSize;r<s;r++)this.array[t+r]=e.array[n+r];return this}copyArray(t){return this.array.set(t),this}copyColorsArray(t){const e=this.array;let n=0;for(let r=0,s=t.length;r<s;r++){let a=t[r];a===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",r),a=new Mt),e[n++]=a.r,e[n++]=a.g,e[n++]=a.b}return this}copyVector2sArray(t){const e=this.array;let n=0;for(let r=0,s=t.length;r<s;r++){let a=t[r];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",r),a=new ct),e[n++]=a.x,e[n++]=a.y}return this}copyVector3sArray(t){const e=this.array;let n=0;for(let r=0,s=t.length;r<s;r++){let a=t[r];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",r),a=new k),e[n++]=a.x,e[n++]=a.y,e[n++]=a.z}return this}copyVector4sArray(t){const e=this.array;let n=0;for(let r=0,s=t.length;r<s;r++){let a=t[r];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",r),a=new Kt),e[n++]=a.x,e[n++]=a.y,e[n++]=a.z,e[n++]=a.w}return this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,n=this.count;e<n;e++)Gs.fromBufferAttribute(this,e),Gs.applyMatrix3(t),this.setXY(e,Gs.x,Gs.y);else if(this.itemSize===3)for(let e=0,n=this.count;e<n;e++)le.fromBufferAttribute(this,e),le.applyMatrix3(t),this.setXYZ(e,le.x,le.y,le.z);return this}applyMatrix4(t){for(let e=0,n=this.count;e<n;e++)le.fromBufferAttribute(this,e),le.applyMatrix4(t),this.setXYZ(e,le.x,le.y,le.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)le.fromBufferAttribute(this,e),le.applyNormalMatrix(t),this.setXYZ(e,le.x,le.y,le.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)le.fromBufferAttribute(this,e),le.transformDirection(t),this.setXYZ(e,le.x,le.y,le.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){return this.array[t*this.itemSize]}setX(t,e){return this.array[t*this.itemSize]=e,this}getY(t){return this.array[t*this.itemSize+1]}setY(t,e){return this.array[t*this.itemSize+1]=e,this}getZ(t){return this.array[t*this.itemSize+2]}setZ(t,e){return this.array[t*this.itemSize+2]=e,this}getW(t){return this.array[t*this.itemSize+3]}setW(t,e){return this.array[t*this.itemSize+3]=e,this}setXY(t,e,n){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this}setXYZ(t,e,n,r){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=r,this}setXYZW(t,e,n,r,s){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=r,this.array[t+3]=s,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==ms&&(t.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(t.updateRange=this.updateRange),t}}re.prototype.isBufferAttribute=!0;class Zd extends re{constructor(t,e,n){super(new Uint16Array(t),e,n)}}class zd extends re{constructor(t,e,n){super(new Uint32Array(t),e,n)}}class o0 extends re{constructor(t,e,n){super(new Uint16Array(t),e,n)}}o0.prototype.isFloat16BufferAttribute=!0;class me extends re{constructor(t,e,n){super(new Float32Array(t),e,n)}}let l0=0;const Ge=new It,Po=new Qt,qi=new k,Fe=new sn,Br=new sn,de=new k;class te extends ri{constructor(){super();Object.defineProperty(this,"id",{value:l0++}),this.uuid=rn(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(Gd(t)?zd:Zd)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const s=new xe().getNormalMatrix(t);n.applyNormalMatrix(s),n.needsUpdate=!0}const r=this.attributes.tangent;return r!==void 0&&(r.transformDirection(t),r.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return Ge.makeRotationFromQuaternion(t),this.applyMatrix4(Ge),this}rotateX(t){return Ge.makeRotationX(t),this.applyMatrix4(Ge),this}rotateY(t){return Ge.makeRotationY(t),this.applyMatrix4(Ge),this}rotateZ(t){return Ge.makeRotationZ(t),this.applyMatrix4(Ge),this}translate(t,e,n){return Ge.makeTranslation(t,e,n),this.applyMatrix4(Ge),this}scale(t,e,n){return Ge.makeScale(t,e,n),this.applyMatrix4(Ge),this}lookAt(t){return Po.lookAt(t),Po.updateMatrix(),this.applyMatrix4(Po.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(qi).negate(),this.translate(qi.x,qi.y,qi.z),this}setFromPoints(t){const e=[];for(let n=0,r=t.length;n<r;n++){const s=t[n];e.push(s.x,s.y,s.z||0)}return this.setAttribute("position",new me(e,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new sn);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new k(-1/0,-1/0,-1/0),new k(1/0,1/0,1/0));return}if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let n=0,r=e.length;n<r;n++){const s=e[n];Fe.setFromBufferAttribute(s),this.morphTargetsRelative?(de.addVectors(this.boundingBox.min,Fe.min),this.boundingBox.expandByPoint(de),de.addVectors(this.boundingBox.max,Fe.max),this.boundingBox.expandByPoint(de)):(this.boundingBox.expandByPoint(Fe.min),this.boundingBox.expandByPoint(Fe.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Ir);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new k,1/0);return}if(t){const n=this.boundingSphere.center;if(Fe.setFromBufferAttribute(t),e)for(let s=0,a=e.length;s<a;s++){const o=e[s];Br.setFromBufferAttribute(o),this.morphTargetsRelative?(de.addVectors(Fe.min,Br.min),Fe.expandByPoint(de),de.addVectors(Fe.max,Br.max),Fe.expandByPoint(de)):(Fe.expandByPoint(Br.min),Fe.expandByPoint(Br.max))}Fe.getCenter(n);let r=0;for(let s=0,a=t.count;s<a;s++)de.fromBufferAttribute(t,s),r=Math.max(r,n.distanceToSquared(de));if(e)for(let s=0,a=e.length;s<a;s++){const o=e[s],l=this.morphTargetsRelative;for(let c=0,u=o.count;c<u;c++)de.fromBufferAttribute(o,c),l&&(qi.fromBufferAttribute(t,c),de.add(qi)),r=Math.max(r,n.distanceToSquared(de))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const n=t.array,r=e.position.array,s=e.normal.array,a=e.uv.array,o=r.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new re(new Float32Array(4*o),4));const l=this.getAttribute("tangent").array,c=[],u=[];for(let K=0;K<o;K++)c[K]=new k,u[K]=new k;const h=new k,d=new k,m=new k,g=new ct,p=new ct,f=new ct,y=new k,M=new k;function E(K,v,C){h.fromArray(r,K*3),d.fromArray(r,v*3),m.fromArray(r,C*3),g.fromArray(a,K*2),p.fromArray(a,v*2),f.fromArray(a,C*2),d.sub(h),m.sub(h),p.sub(g),f.sub(g);const it=1/(p.x*f.y-f.x*p.y);!isFinite(it)||(y.copy(d).multiplyScalar(f.y).addScaledVector(m,-p.y).multiplyScalar(it),M.copy(m).multiplyScalar(p.x).addScaledVector(d,-f.x).multiplyScalar(it),c[K].add(y),c[v].add(y),c[C].add(y),u[K].add(M),u[v].add(M),u[C].add(M))}let R=this.groups;R.length===0&&(R=[{start:0,count:n.length}]);for(let K=0,v=R.length;K<v;++K){const C=R[K],it=C.start,B=C.count;for(let G=it,F=it+B;G<F;G+=3)E(n[G+0],n[G+1],n[G+2])}const b=new k,D=new k,U=new k,X=new k;function dt(K){U.fromArray(s,K*3),X.copy(U);const v=c[K];b.copy(v),b.sub(U.multiplyScalar(U.dot(v))).normalize(),D.crossVectors(X,v);const it=D.dot(u[K])<0?-1:1;l[K*4]=b.x,l[K*4+1]=b.y,l[K*4+2]=b.z,l[K*4+3]=it}for(let K=0,v=R.length;K<v;++K){const C=R[K],it=C.start,B=C.count;for(let G=it,F=it+B;G<F;G+=3)dt(n[G+0]),dt(n[G+1]),dt(n[G+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new re(new Float32Array(e.count*3),3),this.setAttribute("normal",n);else for(let d=0,m=n.count;d<m;d++)n.setXYZ(d,0,0,0);const r=new k,s=new k,a=new k,o=new k,l=new k,c=new k,u=new k,h=new k;if(t)for(let d=0,m=t.count;d<m;d+=3){const g=t.getX(d+0),p=t.getX(d+1),f=t.getX(d+2);r.fromBufferAttribute(e,g),s.fromBufferAttribute(e,p),a.fromBufferAttribute(e,f),u.subVectors(a,s),h.subVectors(r,s),u.cross(h),o.fromBufferAttribute(n,g),l.fromBufferAttribute(n,p),c.fromBufferAttribute(n,f),o.add(u),l.add(u),c.add(u),n.setXYZ(g,o.x,o.y,o.z),n.setXYZ(p,l.x,l.y,l.z),n.setXYZ(f,c.x,c.y,c.z)}else for(let d=0,m=e.count;d<m;d+=3)r.fromBufferAttribute(e,d+0),s.fromBufferAttribute(e,d+1),a.fromBufferAttribute(e,d+2),u.subVectors(a,s),h.subVectors(r,s),u.cross(h),n.setXYZ(d+0,u.x,u.y,u.z),n.setXYZ(d+1,u.x,u.y,u.z),n.setXYZ(d+2,u.x,u.y,u.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(t,e){if(!(t&&t.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);return}e===void 0&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const r in n){if(t.attributes[r]===void 0)continue;const a=n[r].array,o=t.attributes[r],l=o.array,c=o.itemSize*e,u=Math.min(l.length,a.length-c);for(let h=0,d=c;h<u;h++,d++)a[d]=l[h]}return this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)de.fromBufferAttribute(t,e),de.normalize(),t.setXYZ(e,de.x,de.y,de.z)}toNonIndexed(){function t(o,l){const c=o.array,u=o.itemSize,h=o.normalized,d=new c.constructor(l.length*u);let m=0,g=0;for(let p=0,f=l.length;p<f;p++){o.isInterleavedBufferAttribute?m=l[p]*o.data.stride+o.offset:m=l[p]*u;for(let y=0;y<u;y++)d[g++]=c[m++]}return new re(d,u,h)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new te,n=this.index.array,r=this.attributes;for(const o in r){const l=r[o],c=t(l,n);e.setAttribute(o,c)}const s=this.morphAttributes;for(const o in s){const l=[],c=s[o];for(let u=0,h=c.length;u<h;u++){const d=c[u],m=t(d,n);l.push(m)}e.morphAttributes[o]=l}e.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let o=0,l=a.length;o<l;o++){const c=a[o];e.addGroup(c.start,c.count,c.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const c in l)l[c]!==void 0&&(t[c]=l[c]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const l in n){const c=n[l];t.data.attributes[l]=c.toJSON(t.data)}const r={};let s=!1;for(const l in this.morphAttributes){const c=this.morphAttributes[l],u=[];for(let h=0,d=c.length;h<d;h++){const m=c[h];u.push(m.toJSON(t.data))}u.length>0&&(r[l]=u,s=!0)}s&&(t.data.morphAttributes=r,t.data.morphTargetsRelative=this.morphTargetsRelative);const a=this.groups;a.length>0&&(t.data.groups=JSON.parse(JSON.stringify(a)));const o=this.boundingSphere;return o!==null&&(t.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),t}clone(){return new this.constructor().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;n!==null&&this.setIndex(n.clone(e));const r=t.attributes;for(const c in r){const u=r[c];this.setAttribute(c,u.clone(e))}const s=t.morphAttributes;for(const c in s){const u=[],h=s[c];for(let d=0,m=h.length;d<m;d++)u.push(h[d].clone(e));this.morphAttributes[c]=u}this.morphTargetsRelative=t.morphTargetsRelative;const a=t.groups;for(let c=0,u=a.length;c<u;c++){const h=a[c];this.addGroup(h.start,h.count,h.materialIndex)}const o=t.boundingBox;o!==null&&(this.boundingBox=o.clone());const l=t.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,t.parameters!==void 0&&(this.parameters=Object.assign({},t.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}te.prototype.isBufferGeometry=!0;const Xu=new It,Ji=new kr,Do=new Ir,Jn=new k,On=new k,Gn=new k,Fo=new k,Bo=new k,Ho=new k,js=new k,Xs=new k,Ks=new k,Zs=new ct,zs=new ct,Qs=new ct,qo=new k,_s=new k;class pe extends Qt{constructor(t=new te,e=new Ka){super();this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const r=e[n[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=r.length;s<a;s++){const o=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(t,e){const n=this.geometry,r=this.material,s=this.matrixWorld;if(r===void 0||(n.boundingSphere===null&&n.computeBoundingSphere(),Do.copy(n.boundingSphere),Do.applyMatrix4(s),t.ray.intersectsSphere(Do)===!1)||(Xu.copy(s).invert(),Ji.copy(t.ray).applyMatrix4(Xu),n.boundingBox!==null&&Ji.intersectsBox(n.boundingBox)===!1))return;let a;if(n.isBufferGeometry){const o=n.index,l=n.attributes.position,c=n.morphAttributes.position,u=n.morphTargetsRelative,h=n.attributes.uv,d=n.attributes.uv2,m=n.groups,g=n.drawRange;if(o!==null)if(Array.isArray(r))for(let p=0,f=m.length;p<f;p++){const y=m[p],M=r[y.materialIndex],E=Math.max(y.start,g.start),R=Math.min(o.count,Math.min(y.start+y.count,g.start+g.count));for(let b=E,D=R;b<D;b+=3){const U=o.getX(b),X=o.getX(b+1),dt=o.getX(b+2);a=Ys(this,M,t,Ji,l,c,u,h,d,U,X,dt),a&&(a.faceIndex=Math.floor(b/3),a.face.materialIndex=y.materialIndex,e.push(a))}}else{const p=Math.max(0,g.start),f=Math.min(o.count,g.start+g.count);for(let y=p,M=f;y<M;y+=3){const E=o.getX(y),R=o.getX(y+1),b=o.getX(y+2);a=Ys(this,r,t,Ji,l,c,u,h,d,E,R,b),a&&(a.faceIndex=Math.floor(y/3),e.push(a))}}else if(l!==void 0)if(Array.isArray(r))for(let p=0,f=m.length;p<f;p++){const y=m[p],M=r[y.materialIndex],E=Math.max(y.start,g.start),R=Math.min(l.count,Math.min(y.start+y.count,g.start+g.count));for(let b=E,D=R;b<D;b+=3){const U=b,X=b+1,dt=b+2;a=Ys(this,M,t,Ji,l,c,u,h,d,U,X,dt),a&&(a.faceIndex=Math.floor(b/3),a.face.materialIndex=y.materialIndex,e.push(a))}}else{const p=Math.max(0,g.start),f=Math.min(l.count,g.start+g.count);for(let y=p,M=f;y<M;y+=3){const E=y,R=y+1,b=y+2;a=Ys(this,r,t,Ji,l,c,u,h,d,E,R,b),a&&(a.faceIndex=Math.floor(y/3),e.push(a))}}}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}pe.prototype.isMesh=!0;function c0(i,t,e,n,r,s,a,o){let l;if(t.side===Ke?l=n.intersectTriangle(a,s,r,!0,o):l=n.intersectTriangle(r,s,a,t.side!==Mi,o),l===null)return null;_s.copy(o),_s.applyMatrix4(i.matrixWorld);const c=e.ray.origin.distanceTo(_s);return c<e.near||c>e.far?null:{distance:c,point:_s.clone(),object:i}}function Ys(i,t,e,n,r,s,a,o,l,c,u,h){Jn.fromBufferAttribute(r,c),On.fromBufferAttribute(r,u),Gn.fromBufferAttribute(r,h);const d=i.morphTargetInfluences;if(s&&d){js.set(0,0,0),Xs.set(0,0,0),Ks.set(0,0,0);for(let g=0,p=s.length;g<p;g++){const f=d[g],y=s[g];f!==0&&(Fo.fromBufferAttribute(y,c),Bo.fromBufferAttribute(y,u),Ho.fromBufferAttribute(y,h),a?(js.addScaledVector(Fo,f),Xs.addScaledVector(Bo,f),Ks.addScaledVector(Ho,f)):(js.addScaledVector(Fo.sub(Jn),f),Xs.addScaledVector(Bo.sub(On),f),Ks.addScaledVector(Ho.sub(Gn),f)))}Jn.add(js),On.add(Xs),Gn.add(Ks)}i.isSkinnedMesh&&(i.boneTransform(c,Jn),i.boneTransform(u,On),i.boneTransform(h,Gn));const m=c0(i,t,e,n,Jn,On,Gn,qo);if(m){o&&(Zs.fromBufferAttribute(o,c),zs.fromBufferAttribute(o,u),Qs.fromBufferAttribute(o,h),m.uv=ce.getUV(qo,Jn,On,Gn,Zs,zs,Qs,new ct)),l&&(Zs.fromBufferAttribute(l,c),zs.fromBufferAttribute(l,u),Qs.fromBufferAttribute(l,h),m.uv2=ce.getUV(qo,Jn,On,Gn,Zs,zs,Qs,new ct));const g={a:c,b:u,c:h,normal:new k,materialIndex:0};ce.getNormal(Jn,On,Gn,g.normal),m.face=g}return m}class Rr extends te{constructor(t=1,e=1,n=1,r=1,s=1,a=1){super();this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:r,heightSegments:s,depthSegments:a};const o=this;r=Math.floor(r),s=Math.floor(s),a=Math.floor(a);const l=[],c=[],u=[],h=[];let d=0,m=0;g("z","y","x",-1,-1,n,e,t,a,s,0),g("z","y","x",1,-1,n,e,-t,a,s,1),g("x","z","y",1,1,t,n,e,r,a,2),g("x","z","y",1,-1,t,n,-e,r,a,3),g("x","y","z",1,-1,t,e,n,r,s,4),g("x","y","z",-1,-1,t,e,-n,r,s,5),this.setIndex(l),this.setAttribute("position",new me(c,3)),this.setAttribute("normal",new me(u,3)),this.setAttribute("uv",new me(h,2));function g(p,f,y,M,E,R,b,D,U,X,dt){const K=R/U,v=b/X,C=R/2,it=b/2,B=D/2,G=U+1,F=X+1;let H=0,L=0;const z=new k;for(let lt=0;lt<F;lt++){const ut=lt*v-it;for(let ht=0;ht<G;ht++){const At=ht*K-C;z[p]=At*M,z[f]=ut*E,z[y]=B,c.push(z.x,z.y,z.z),z[p]=0,z[f]=0,z[y]=D>0?1:-1,u.push(z.x,z.y,z.z),h.push(ht/U),h.push(1-lt/X),H+=1}}for(let lt=0;lt<X;lt++)for(let ut=0;ut<U;ut++){const ht=d+ut+G*lt,At=d+ut+G*(lt+1),Lt=d+(ut+1)+G*(lt+1),kt=d+(ut+1)+G*lt;l.push(ht,At,kt),l.push(At,Lt,kt),L+=6}o.addGroup(m,L,dt),m+=L,d+=H}}static fromJSON(t){return new Rr(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function xr(i){const t={};for(const e in i){t[e]={};for(const n in i[e]){const r=i[e][n];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture||r.isQuaternion)?t[e][n]=r.clone():Array.isArray(r)?t[e][n]=r.slice():t[e][n]=r}}return t}function be(i){const t={};for(let e=0;e<i.length;e++){const n=xr(i[e]);for(const r in n)t[r]=n[r]}return t}const La={clone:xr,merge:be};var u0=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,h0=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class Le extends he{constructor(t){super();this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=u0,this.fragmentShader=h0,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,t!==void 0&&(t.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(t))}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=xr(t.uniforms),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const r in this.uniforms){const a=this.uniforms[r].value;a&&a.isTexture?e.uniforms[r]={type:"t",value:a.toJSON(t).uuid}:a&&a.isColor?e.uniforms[r]={type:"c",value:a.getHex()}:a&&a.isVector2?e.uniforms[r]={type:"v2",value:a.toArray()}:a&&a.isVector3?e.uniforms[r]={type:"v3",value:a.toArray()}:a&&a.isVector4?e.uniforms[r]={type:"v4",value:a.toArray()}:a&&a.isMatrix3?e.uniforms[r]={type:"m3",value:a.toArray()}:a&&a.isMatrix4?e.uniforms[r]={type:"m4",value:a.toArray()}:e.uniforms[r]={value:a}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const n={};for(const r in this.extensions)this.extensions[r]===!0&&(n[r]=!0);return Object.keys(n).length>0&&(e.extensions=n),e}}Le.prototype.isShaderMaterial=!0;class Za extends Qt{constructor(){super();this.type="Camera",this.matrixWorldInverse=new It,this.projectionMatrix=new It,this.projectionMatrixInverse=new It}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}Za.prototype.isCamera=!0;class Te extends Za{constructor(t=50,e=1,n=.1,r=2e3){super();this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=r,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=t.view===null?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=gs*2*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(is*.5*this.fov);return .5*this.getFilmHeight()/t}getEffectiveFOV(){return gs*2*Math.atan(Math.tan(is*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(t,e,n,r,s,a){this.aspect=t/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=r,this.view.width=s,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(is*.5*this.fov)/this.zoom,n=2*e,r=this.aspect*n,s=-.5*r;const a=this.view;if(this.view!==null&&this.view.enabled){const l=a.fullWidth,c=a.fullHeight;s+=a.offsetX*r/l,e-=a.offsetY*n/c,r*=a.width/l,n*=a.height/c}const o=this.filmOffset;o!==0&&(s+=t*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+r,e,e-n,t,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}Te.prototype.isPerspectiveCamera=!0;const Oi=90,Gi=1;class lc extends Qt{constructor(t,e,n){super();if(this.type="CubeCamera",n.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=n;const r=new Te(Oi,Gi,t,e);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new k(1,0,0)),this.add(r);const s=new Te(Oi,Gi,t,e);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new k(-1,0,0)),this.add(s);const a=new Te(Oi,Gi,t,e);a.layers=this.layers,a.up.set(0,0,1),a.lookAt(new k(0,1,0)),this.add(a);const o=new Te(Oi,Gi,t,e);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(new k(0,-1,0)),this.add(o);const l=new Te(Oi,Gi,t,e);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new k(0,0,1)),this.add(l);const c=new Te(Oi,Gi,t,e);c.layers=this.layers,c.up.set(0,-1,0),c.lookAt(new k(0,0,-1)),this.add(c)}update(t,e){this.parent===null&&this.updateMatrixWorld();const n=this.renderTarget,[r,s,a,o,l,c]=this.children,u=t.getRenderTarget(),h=t.outputEncoding,d=t.toneMapping,m=t.xr.enabled;t.outputEncoding=Vn,t.toneMapping=Ln,t.xr.enabled=!1;const g=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0),t.render(e,r),t.setRenderTarget(n,1),t.render(e,s),t.setRenderTarget(n,2),t.render(e,a),t.setRenderTarget(n,3),t.render(e,o),t.setRenderTarget(n,4),t.render(e,l),n.texture.generateMipmaps=g,t.setRenderTarget(n,5),t.render(e,c),t.setRenderTarget(u),t.outputEncoding=h,t.toneMapping=d,t.xr.enabled=m,n.texture.needsPMREMUpdate=!0}}class za extends ge{constructor(t,e,n,r,s,a,o,l,c,u){t=t!==void 0?t:[],e=e!==void 0?e:yr;super(t,e,n,r,s,a,o,l,c,u);this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}za.prototype.isCubeTexture=!0;class Qd extends We{constructor(t,e={}){super(t,t,e);const n={width:t,height:t,depth:1},r=[n,n,n,n,n,n];this.texture=new za(r,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=e.generateMipmaps!==void 0?e.generateMipmaps:!1,this.texture.minFilter=e.minFilter!==void 0?e.minFilter:Pe}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},r=new Rr(5,5,5),s=new Le({name:"CubemapFromEquirect",uniforms:xr(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:Ke,blending:Yn});s.uniforms.tEquirect.value=e;const a=new pe(r,s),o=e.minFilter;return e.minFilter===ja&&(e.minFilter=Pe),new lc(1,10,this).update(t,a),e.minFilter=o,a.geometry.dispose(),a.material.dispose(),this}clear(t,e,n,r){const s=t.getRenderTarget();for(let a=0;a<6;a++)t.setRenderTarget(this,a),t.clear(e,n,r);t.setRenderTarget(s)}}Qd.prototype.isWebGLCubeRenderTarget=!0;const Jo=new k,d0=new k,f0=new xe;class pn{constructor(t=new k(1,0,0),e=0){this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,r){return this.normal.set(t,e,n),this.constant=r,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const r=Jo.subVectors(n,e).cross(d0.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(r,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){const n=t.delta(Jo),r=this.normal.dot(n);if(r===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const s=-(t.start.dot(this.normal)+this.constant)/r;return s<0||s>1?null:e.copy(n).multiplyScalar(s).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||f0.getNormalMatrix(t),r=this.coplanarPoint(Jo).applyMatrix4(t),s=this.normal.applyMatrix3(n).normalize();return this.constant=-r.dot(s),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}pn.prototype.isPlane=!0;const ji=new Ir,$s=new k;class Qa{constructor(t=new pn,e=new pn,n=new pn,r=new pn,s=new pn,a=new pn){this.planes=[t,e,n,r,s,a]}set(t,e,n,r,s,a){const o=this.planes;return o[0].copy(t),o[1].copy(e),o[2].copy(n),o[3].copy(r),o[4].copy(s),o[5].copy(a),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t){const e=this.planes,n=t.elements,r=n[0],s=n[1],a=n[2],o=n[3],l=n[4],c=n[5],u=n[6],h=n[7],d=n[8],m=n[9],g=n[10],p=n[11],f=n[12],y=n[13],M=n[14],E=n[15];return e[0].setComponents(o-r,h-l,p-d,E-f).normalize(),e[1].setComponents(o+r,h+l,p+d,E+f).normalize(),e[2].setComponents(o+s,h+c,p+m,E+y).normalize(),e[3].setComponents(o-s,h-c,p-m,E-y).normalize(),e[4].setComponents(o-a,h-u,p-g,E-M).normalize(),e[5].setComponents(o+a,h+u,p+g,E+M).normalize(),this}intersectsObject(t){const e=t.geometry;return e.boundingSphere===null&&e.computeBoundingSphere(),ji.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(ji)}intersectsSprite(t){return ji.center.set(0,0,0),ji.radius=.7071067811865476,ji.applyMatrix4(t.matrixWorld),this.intersectsSphere(ji)}intersectsSphere(t){const e=this.planes,n=t.center,r=-t.radius;for(let s=0;s<6;s++)if(e[s].distanceToPoint(n)<r)return!1;return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const r=e[n];if($s.x=r.normal.x>0?t.max.x:t.min.x,$s.y=r.normal.y>0?t.max.y:t.min.y,$s.z=r.normal.z>0?t.max.z:t.min.z,r.distanceToPoint($s)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function _d(){let i=null,t=!1,e=null,n=null;function r(s,a){e(s,a),n=i.requestAnimationFrame(r)}return{start:function(){t!==!0&&e!==null&&(n=i.requestAnimationFrame(r),t=!0)},stop:function(){i.cancelAnimationFrame(n),t=!1},setAnimationLoop:function(s){e=s},setContext:function(s){i=s}}}function p0(i,t){const e=t.isWebGL2,n=new WeakMap;function r(c,u){const h=c.array,d=c.usage,m=i.createBuffer();i.bindBuffer(u,m),i.bufferData(u,h,d),c.onUploadCallback();let g;if(h instanceof Float32Array)g=5126;else if(h instanceof Uint16Array)if(c.isFloat16BufferAttribute)if(e)g=5131;else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");else g=5123;else if(h instanceof Int16Array)g=5122;else if(h instanceof Uint32Array)g=5125;else if(h instanceof Int32Array)g=5124;else if(h instanceof Int8Array)g=5120;else if(h instanceof Uint8Array)g=5121;else if(h instanceof Uint8ClampedArray)g=5121;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+h);return{buffer:m,type:g,bytesPerElement:h.BYTES_PER_ELEMENT,version:c.version}}function s(c,u,h){const d=u.array,m=u.updateRange;i.bindBuffer(h,c),m.count===-1?i.bufferSubData(h,0,d):(e?i.bufferSubData(h,m.offset*d.BYTES_PER_ELEMENT,d,m.offset,m.count):i.bufferSubData(h,m.offset*d.BYTES_PER_ELEMENT,d.subarray(m.offset,m.offset+m.count)),m.count=-1)}function a(c){return c.isInterleavedBufferAttribute&&(c=c.data),n.get(c)}function o(c){c.isInterleavedBufferAttribute&&(c=c.data);const u=n.get(c);u&&(i.deleteBuffer(u.buffer),n.delete(c))}function l(c,u){if(c.isGLBufferAttribute){const d=n.get(c);(!d||d.version<c.version)&&n.set(c,{buffer:c.buffer,type:c.type,bytesPerElement:c.elementSize,version:c.version});return}c.isInterleavedBufferAttribute&&(c=c.data);const h=n.get(c);h===void 0?n.set(c,r(c,u)):h.version<c.version&&(s(h.buffer,c,u),h.version=c.version)}return{get:a,remove:o,update:l}}class bs extends te{constructor(t=1,e=1,n=1,r=1){super();this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:r};const s=t/2,a=e/2,o=Math.floor(n),l=Math.floor(r),c=o+1,u=l+1,h=t/o,d=e/l,m=[],g=[],p=[],f=[];for(let y=0;y<u;y++){const M=y*d-a;for(let E=0;E<c;E++){const R=E*h-s;g.push(R,-M,0),p.push(0,0,1),f.push(E/o),f.push(1-y/l)}}for(let y=0;y<l;y++)for(let M=0;M<o;M++){const E=M+c*y,R=M+c*(y+1),b=M+1+c*(y+1),D=M+1+c*y;m.push(E,R,D),m.push(R,b,D)}this.setIndex(m),this.setAttribute("position",new me(g,3)),this.setAttribute("normal",new me(p,3)),this.setAttribute("uv",new me(f,2))}static fromJSON(t){return new bs(t.width,t.height,t.widthSegments,t.heightSegments)}}var m0=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,g0=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,y0=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,A0=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,S0=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,x0=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,v0="vec3 transformed = vec3( position );",b0=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,T0=`vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,M0=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,w0=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,I0=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,k0=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,R0=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,E0=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,W0=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,C0=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,L0=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,N0=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,V0=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,U0=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,P0=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,D0=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,F0=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,B0=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,H0="gl_FragColor = linearToOutputTexel( gl_FragColor );",q0=`vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,J0=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,O0=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,G0=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,j0=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,X0=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,K0=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,Z0=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,z0=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,Q0=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,_0=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,Y0=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,$0=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,tA=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`,eA=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,nA=`#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,iA=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,rA=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,sA=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,aA=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,oA=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,lA=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,cA=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,uA=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,hA=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,dA=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,fA=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,pA=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,mA=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,gA=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,yA=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,AA=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,SA=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,xA=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,vA=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,bA=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,TA=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,MA=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,wA=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,IA=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,kA=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,RA=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,EA=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,WA=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,CA=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,LA=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,NA=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,VA=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,UA=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,PA=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,DA=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,FA=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,BA=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,HA=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,qA=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,JA=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,OA=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,GA=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,jA=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,XA=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,KA=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,ZA=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,zA=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,QA=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,_A=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,YA=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,$A=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,tS=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,eS=`#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`,nS=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,iS=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,rS=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,sS=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,aS=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,oS=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,lS=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,cS=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const uS=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,hS=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );
	#endif
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,dS=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,fS=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,pS=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,mS=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,gS=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,yS=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,AS=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,SS=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,xS=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,vS=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,bS=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,TS=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,MS=`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,wS=`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,IS=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,kS=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,RS=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,ES=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,WS=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,CS=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,LS=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,NS=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,VS=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,US=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,PS=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,DS=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,FS=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,BS=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,HS=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,qS=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,Bt={alphamap_fragment:m0,alphamap_pars_fragment:g0,alphatest_fragment:y0,alphatest_pars_fragment:A0,aomap_fragment:S0,aomap_pars_fragment:x0,begin_vertex:v0,beginnormal_vertex:b0,bsdfs:T0,bumpmap_pars_fragment:M0,clipping_planes_fragment:w0,clipping_planes_pars_fragment:I0,clipping_planes_pars_vertex:k0,clipping_planes_vertex:R0,color_fragment:E0,color_pars_fragment:W0,color_pars_vertex:C0,color_vertex:L0,common:N0,cube_uv_reflection_fragment:V0,defaultnormal_vertex:U0,displacementmap_pars_vertex:P0,displacementmap_vertex:D0,emissivemap_fragment:F0,emissivemap_pars_fragment:B0,encodings_fragment:H0,encodings_pars_fragment:q0,envmap_fragment:J0,envmap_common_pars_fragment:O0,envmap_pars_fragment:G0,envmap_pars_vertex:j0,envmap_physical_pars_fragment:nA,envmap_vertex:X0,fog_vertex:K0,fog_pars_vertex:Z0,fog_fragment:z0,fog_pars_fragment:Q0,gradientmap_pars_fragment:_0,lightmap_fragment:Y0,lightmap_pars_fragment:$0,lights_lambert_vertex:tA,lights_pars_begin:eA,lights_toon_fragment:iA,lights_toon_pars_fragment:rA,lights_phong_fragment:sA,lights_phong_pars_fragment:aA,lights_physical_fragment:oA,lights_physical_pars_fragment:lA,lights_fragment_begin:cA,lights_fragment_maps:uA,lights_fragment_end:hA,logdepthbuf_fragment:dA,logdepthbuf_pars_fragment:fA,logdepthbuf_pars_vertex:pA,logdepthbuf_vertex:mA,map_fragment:gA,map_pars_fragment:yA,map_particle_fragment:AA,map_particle_pars_fragment:SA,metalnessmap_fragment:xA,metalnessmap_pars_fragment:vA,morphcolor_vertex:bA,morphnormal_vertex:TA,morphtarget_pars_vertex:MA,morphtarget_vertex:wA,normal_fragment_begin:IA,normal_fragment_maps:kA,normal_pars_fragment:RA,normal_pars_vertex:EA,normal_vertex:WA,normalmap_pars_fragment:CA,clearcoat_normal_fragment_begin:LA,clearcoat_normal_fragment_maps:NA,clearcoat_pars_fragment:VA,output_fragment:UA,packing:PA,premultiplied_alpha_fragment:DA,project_vertex:FA,dithering_fragment:BA,dithering_pars_fragment:HA,roughnessmap_fragment:qA,roughnessmap_pars_fragment:JA,shadowmap_pars_fragment:OA,shadowmap_pars_vertex:GA,shadowmap_vertex:jA,shadowmask_pars_fragment:XA,skinbase_vertex:KA,skinning_pars_vertex:ZA,skinning_vertex:zA,skinnormal_vertex:QA,specularmap_fragment:_A,specularmap_pars_fragment:YA,tonemapping_fragment:$A,tonemapping_pars_fragment:tS,transmission_fragment:eS,transmission_pars_fragment:nS,uv_pars_fragment:iS,uv_pars_vertex:rS,uv_vertex:sS,uv2_pars_fragment:aS,uv2_pars_vertex:oS,uv2_vertex:lS,worldpos_vertex:cS,background_vert:uS,background_frag:hS,cube_vert:dS,cube_frag:fS,depth_vert:pS,depth_frag:mS,distanceRGBA_vert:gS,distanceRGBA_frag:yS,equirect_vert:AS,equirect_frag:SS,linedashed_vert:xS,linedashed_frag:vS,meshbasic_vert:bS,meshbasic_frag:TS,meshlambert_vert:MS,meshlambert_frag:wS,meshmatcap_vert:IS,meshmatcap_frag:kS,meshnormal_vert:RS,meshnormal_frag:ES,meshphong_vert:WS,meshphong_frag:CS,meshphysical_vert:LS,meshphysical_frag:NS,meshtoon_vert:VS,meshtoon_frag:US,points_vert:PS,points_frag:DS,shadow_vert:FS,shadow_frag:BS,sprite_vert:HS,sprite_frag:qS},vt={common:{diffuse:{value:new Mt(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new xe},uv2Transform:{value:new xe},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new ct(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Mt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Mt(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new xe}},sprite:{diffuse:{value:new Mt(16777215)},opacity:{value:1},center:{value:new ct(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new xe}}},mn={basic:{uniforms:be([vt.common,vt.specularmap,vt.envmap,vt.aomap,vt.lightmap,vt.fog]),vertexShader:Bt.meshbasic_vert,fragmentShader:Bt.meshbasic_frag},lambert:{uniforms:be([vt.common,vt.specularmap,vt.envmap,vt.aomap,vt.lightmap,vt.emissivemap,vt.fog,vt.lights,{emissive:{value:new Mt(0)}}]),vertexShader:Bt.meshlambert_vert,fragmentShader:Bt.meshlambert_frag},phong:{uniforms:be([vt.common,vt.specularmap,vt.envmap,vt.aomap,vt.lightmap,vt.emissivemap,vt.bumpmap,vt.normalmap,vt.displacementmap,vt.fog,vt.lights,{emissive:{value:new Mt(0)},specular:{value:new Mt(1118481)},shininess:{value:30}}]),vertexShader:Bt.meshphong_vert,fragmentShader:Bt.meshphong_frag},standard:{uniforms:be([vt.common,vt.envmap,vt.aomap,vt.lightmap,vt.emissivemap,vt.bumpmap,vt.normalmap,vt.displacementmap,vt.roughnessmap,vt.metalnessmap,vt.fog,vt.lights,{emissive:{value:new Mt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Bt.meshphysical_vert,fragmentShader:Bt.meshphysical_frag},toon:{uniforms:be([vt.common,vt.aomap,vt.lightmap,vt.emissivemap,vt.bumpmap,vt.normalmap,vt.displacementmap,vt.gradientmap,vt.fog,vt.lights,{emissive:{value:new Mt(0)}}]),vertexShader:Bt.meshtoon_vert,fragmentShader:Bt.meshtoon_frag},matcap:{uniforms:be([vt.common,vt.bumpmap,vt.normalmap,vt.displacementmap,vt.fog,{matcap:{value:null}}]),vertexShader:Bt.meshmatcap_vert,fragmentShader:Bt.meshmatcap_frag},points:{uniforms:be([vt.points,vt.fog]),vertexShader:Bt.points_vert,fragmentShader:Bt.points_frag},dashed:{uniforms:be([vt.common,vt.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Bt.linedashed_vert,fragmentShader:Bt.linedashed_frag},depth:{uniforms:be([vt.common,vt.displacementmap]),vertexShader:Bt.depth_vert,fragmentShader:Bt.depth_frag},normal:{uniforms:be([vt.common,vt.bumpmap,vt.normalmap,vt.displacementmap,{opacity:{value:1}}]),vertexShader:Bt.meshnormal_vert,fragmentShader:Bt.meshnormal_frag},sprite:{uniforms:be([vt.sprite,vt.fog]),vertexShader:Bt.sprite_vert,fragmentShader:Bt.sprite_frag},background:{uniforms:{uvTransform:{value:new xe},t2D:{value:null}},vertexShader:Bt.background_vert,fragmentShader:Bt.background_frag},cube:{uniforms:be([vt.envmap,{opacity:{value:1}}]),vertexShader:Bt.cube_vert,fragmentShader:Bt.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Bt.equirect_vert,fragmentShader:Bt.equirect_frag},distanceRGBA:{uniforms:be([vt.common,vt.displacementmap,{referencePosition:{value:new k},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Bt.distanceRGBA_vert,fragmentShader:Bt.distanceRGBA_frag},shadow:{uniforms:be([vt.lights,vt.fog,{color:{value:new Mt(0)},opacity:{value:1}}]),vertexShader:Bt.shadow_vert,fragmentShader:Bt.shadow_frag}};mn.physical={uniforms:be([mn.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new ct(1,1)},clearcoatNormalMap:{value:null},sheen:{value:0},sheenColor:{value:new Mt(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new ct},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new Mt(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new Mt(1,1,1)},specularColorMap:{value:null}}]),vertexShader:Bt.meshphysical_vert,fragmentShader:Bt.meshphysical_frag};function JS(i,t,e,n,r,s){const a=new Mt(0);let o=r===!0?0:1,l,c,u=null,h=0,d=null;function m(p,f){let y=!1,M=f.isScene===!0?f.background:null;M&&M.isTexture&&(M=t.get(M));const E=i.xr,R=E.getSession&&E.getSession();R&&R.environmentBlendMode==="additive"&&(M=null),M===null?g(a,o):M&&M.isColor&&(g(M,1),y=!0),(i.autoClear||y)&&i.clear(i.autoClearColor,i.autoClearDepth,i.autoClearStencil),M&&(M.isCubeTexture||M.mapping===Ga)?(c===void 0&&(c=new pe(new Rr(1,1,1),new Le({name:"BackgroundCubeMaterial",uniforms:xr(mn.cube.uniforms),vertexShader:mn.cube.vertexShader,fragmentShader:mn.cube.fragmentShader,side:Ke,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(b,D,U){this.matrixWorld.copyPosition(U.matrixWorld)},Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),n.update(c)),c.material.uniforms.envMap.value=M,c.material.uniforms.flipEnvMap.value=M.isCubeTexture&&M.isRenderTargetTexture===!1?-1:1,(u!==M||h!==M.version||d!==i.toneMapping)&&(c.material.needsUpdate=!0,u=M,h=M.version,d=i.toneMapping),p.unshift(c,c.geometry,c.material,0,0,null)):M&&M.isTexture&&(l===void 0&&(l=new pe(new bs(2,2),new Le({name:"BackgroundMaterial",uniforms:xr(mn.background.uniforms),vertexShader:mn.background.vertexShader,fragmentShader:mn.background.fragmentShader,side:gr,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),Object.defineProperty(l.material,"map",{get:function(){return this.uniforms.t2D.value}}),n.update(l)),l.material.uniforms.t2D.value=M,M.matrixAutoUpdate===!0&&M.updateMatrix(),l.material.uniforms.uvTransform.value.copy(M.matrix),(u!==M||h!==M.version||d!==i.toneMapping)&&(l.material.needsUpdate=!0,u=M,h=M.version,d=i.toneMapping),p.unshift(l,l.geometry,l.material,0,0,null))}function g(p,f){e.buffers.color.setClear(p.r,p.g,p.b,f,s)}return{getClearColor:function(){return a},setClearColor:function(p,f=1){a.set(p),o=f,g(a,o)},getClearAlpha:function(){return o},setClearAlpha:function(p){o=p,g(a,o)},render:m}}function OS(i,t,e,n){const r=i.getParameter(34921),s=n.isWebGL2?null:t.get("OES_vertex_array_object"),a=n.isWebGL2||s!==null,o={},l=f(null);let c=l,u=!1;function h(B,G,F,H,L){let z=!1;if(a){const lt=p(H,F,G);c!==lt&&(c=lt,m(c.object)),z=y(H,L),z&&M(H,L)}else{const lt=G.wireframe===!0;(c.geometry!==H.id||c.program!==F.id||c.wireframe!==lt)&&(c.geometry=H.id,c.program=F.id,c.wireframe=lt,z=!0)}B.isInstancedMesh===!0&&(z=!0),L!==null&&e.update(L,34963),(z||u)&&(u=!1,X(B,G,F,H),L!==null&&i.bindBuffer(34963,e.get(L).buffer))}function d(){return n.isWebGL2?i.createVertexArray():s.createVertexArrayOES()}function m(B){return n.isWebGL2?i.bindVertexArray(B):s.bindVertexArrayOES(B)}function g(B){return n.isWebGL2?i.deleteVertexArray(B):s.deleteVertexArrayOES(B)}function p(B,G,F){const H=F.wireframe===!0;let L=o[B.id];L===void 0&&(L={},o[B.id]=L);let z=L[G.id];z===void 0&&(z={},L[G.id]=z);let lt=z[H];return lt===void 0&&(lt=f(d()),z[H]=lt),lt}function f(B){const G=[],F=[],H=[];for(let L=0;L<r;L++)G[L]=0,F[L]=0,H[L]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:G,enabledAttributes:F,attributeDivisors:H,object:B,attributes:{},index:null}}function y(B,G){const F=c.attributes,H=B.attributes;let L=0;for(const z in H){const lt=F[z],ut=H[z];if(lt===void 0||lt.attribute!==ut||lt.data!==ut.data)return!0;L++}return c.attributesNum!==L||c.index!==G}function M(B,G){const F={},H=B.attributes;let L=0;for(const z in H){const lt=H[z],ut={};ut.attribute=lt,lt.data&&(ut.data=lt.data),F[z]=ut,L++}c.attributes=F,c.attributesNum=L,c.index=G}function E(){const B=c.newAttributes;for(let G=0,F=B.length;G<F;G++)B[G]=0}function R(B){b(B,0)}function b(B,G){const F=c.newAttributes,H=c.enabledAttributes,L=c.attributeDivisors;F[B]=1,H[B]===0&&(i.enableVertexAttribArray(B),H[B]=1),L[B]!==G&&((n.isWebGL2?i:t.get("ANGLE_instanced_arrays"))[n.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](B,G),L[B]=G)}function D(){const B=c.newAttributes,G=c.enabledAttributes;for(let F=0,H=G.length;F<H;F++)G[F]!==B[F]&&(i.disableVertexAttribArray(F),G[F]=0)}function U(B,G,F,H,L,z){n.isWebGL2===!0&&(F===5124||F===5125)?i.vertexAttribIPointer(B,G,F,L,z):i.vertexAttribPointer(B,G,F,H,L,z)}function X(B,G,F,H){if(n.isWebGL2===!1&&(B.isInstancedMesh||H.isInstancedBufferGeometry)&&t.get("ANGLE_instanced_arrays")===null)return;E();const L=H.attributes,z=F.getAttributes(),lt=G.defaultAttributeValues;for(const ut in z){const ht=z[ut];if(ht.location>=0){let At=L[ut];if(At===void 0&&(ut==="instanceMatrix"&&B.instanceMatrix&&(At=B.instanceMatrix),ut==="instanceColor"&&B.instanceColor&&(At=B.instanceColor)),At!==void 0){const Lt=At.normalized,kt=At.itemSize,et=e.get(At);if(et===void 0)continue;const Nt=et.buffer,Rt=et.type,Et=et.bytesPerElement;if(At.isInterleavedBufferAttribute){const ft=At.data,Ct=ft.stride,$=At.offset;if(ft.isInstancedInterleavedBuffer){for(let x=0;x<ht.locationSize;x++)b(ht.location+x,ft.meshPerAttribute);B.isInstancedMesh!==!0&&H._maxInstanceCount===void 0&&(H._maxInstanceCount=ft.meshPerAttribute*ft.count)}else for(let x=0;x<ht.locationSize;x++)R(ht.location+x);i.bindBuffer(34962,Nt);for(let x=0;x<ht.locationSize;x++)U(ht.location+x,kt/ht.locationSize,Rt,Lt,Ct*Et,($+kt/ht.locationSize*x)*Et)}else{if(At.isInstancedBufferAttribute){for(let ft=0;ft<ht.locationSize;ft++)b(ht.location+ft,At.meshPerAttribute);B.isInstancedMesh!==!0&&H._maxInstanceCount===void 0&&(H._maxInstanceCount=At.meshPerAttribute*At.count)}else for(let ft=0;ft<ht.locationSize;ft++)R(ht.location+ft);i.bindBuffer(34962,Nt);for(let ft=0;ft<ht.locationSize;ft++)U(ht.location+ft,kt/ht.locationSize,Rt,Lt,kt*Et,kt/ht.locationSize*ft*Et)}}else if(lt!==void 0){const Lt=lt[ut];if(Lt!==void 0)switch(Lt.length){case 2:i.vertexAttrib2fv(ht.location,Lt);break;case 3:i.vertexAttrib3fv(ht.location,Lt);break;case 4:i.vertexAttrib4fv(ht.location,Lt);break;default:i.vertexAttrib1fv(ht.location,Lt)}}}}D()}function dt(){C();for(const B in o){const G=o[B];for(const F in G){const H=G[F];for(const L in H)g(H[L].object),delete H[L];delete G[F]}delete o[B]}}function K(B){if(o[B.id]===void 0)return;const G=o[B.id];for(const F in G){const H=G[F];for(const L in H)g(H[L].object),delete H[L];delete G[F]}delete o[B.id]}function v(B){for(const G in o){const F=o[G];if(F[B.id]===void 0)continue;const H=F[B.id];for(const L in H)g(H[L].object),delete H[L];delete F[B.id]}}function C(){it(),u=!0,c!==l&&(c=l,m(c.object))}function it(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:h,reset:C,resetDefaultState:it,dispose:dt,releaseStatesOfGeometry:K,releaseStatesOfProgram:v,initAttributes:E,enableAttribute:R,disableUnusedAttributes:D}}function GS(i,t,e,n){const r=n.isWebGL2;let s;function a(c){s=c}function o(c,u){i.drawArrays(s,c,u),e.update(u,s,1)}function l(c,u,h){if(h===0)return;let d,m;if(r)d=i,m="drawArraysInstanced";else if(d=t.get("ANGLE_instanced_arrays"),m="drawArraysInstancedANGLE",d===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}d[m](s,c,u,h),e.update(u,s,h)}this.setMode=a,this.render=o,this.renderInstances=l}function jS(i,t,e){let n;function r(){if(n!==void 0)return n;if(t.has("EXT_texture_filter_anisotropic")===!0){const U=t.get("EXT_texture_filter_anisotropic");n=i.getParameter(U.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n}function s(U){if(U==="highp"){if(i.getShaderPrecisionFormat(35633,36338).precision>0&&i.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";U="mediump"}return U==="mediump"&&i.getShaderPrecisionFormat(35633,36337).precision>0&&i.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const a=typeof WebGL2RenderingContext!="undefined"&&i instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!="undefined"&&i instanceof WebGL2ComputeRenderingContext;let o=e.precision!==void 0?e.precision:"highp";const l=s(o);l!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",l,"instead."),o=l);const c=a||t.has("WEBGL_draw_buffers"),u=e.logarithmicDepthBuffer===!0,h=i.getParameter(34930),d=i.getParameter(35660),m=i.getParameter(3379),g=i.getParameter(34076),p=i.getParameter(34921),f=i.getParameter(36347),y=i.getParameter(36348),M=i.getParameter(36349),E=d>0,R=a||t.has("OES_texture_float"),b=E&&R,D=a?i.getParameter(36183):0;return{isWebGL2:a,drawBuffers:c,getMaxAnisotropy:r,getMaxPrecision:s,precision:o,logarithmicDepthBuffer:u,maxTextures:h,maxVertexTextures:d,maxTextureSize:m,maxCubemapSize:g,maxAttributes:p,maxVertexUniforms:f,maxVaryings:y,maxFragmentUniforms:M,vertexTextures:E,floatFragmentTextures:R,floatVertexTextures:b,maxSamples:D}}function XS(i){const t=this;let e=null,n=0,r=!1,s=!1;const a=new pn,o=new xe,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(h,d,m){const g=h.length!==0||d||n!==0||r;return r=d,e=u(h,m,0),n=h.length,g},this.beginShadows=function(){s=!0,u(null)},this.endShadows=function(){s=!1,c()},this.setState=function(h,d,m){const g=h.clippingPlanes,p=h.clipIntersection,f=h.clipShadows,y=i.get(h);if(!r||g===null||g.length===0||s&&!f)s?u(null):c();else{const M=s?0:n,E=M*4;let R=y.clippingState||null;l.value=R,R=u(g,d,E,m);for(let b=0;b!==E;++b)R[b]=e[b];y.clippingState=R,this.numIntersection=p?this.numPlanes:0,this.numPlanes+=M}};function c(){l.value!==e&&(l.value=e,l.needsUpdate=n>0),t.numPlanes=n,t.numIntersection=0}function u(h,d,m,g){const p=h!==null?h.length:0;let f=null;if(p!==0){if(f=l.value,g!==!0||f===null){const y=m+p*4,M=d.matrixWorldInverse;o.getNormalMatrix(M),(f===null||f.length<y)&&(f=new Float32Array(y));for(let E=0,R=m;E!==p;++E,R+=4)a.copy(h[E]).applyMatrix4(M,o),a.normal.toArray(f,R),f[R+3]=a.constant}l.value=f,l.needsUpdate=!0}return t.numPlanes=p,t.numIntersection=0,f}}function KS(i){let t=new WeakMap;function e(a,o){return o===bl?a.mapping=yr:o===Tl&&(a.mapping=Ar),a}function n(a){if(a&&a.isTexture&&a.isRenderTargetTexture===!1){const o=a.mapping;if(o===bl||o===Tl)if(t.has(a)){const l=t.get(a).texture;return e(l,a.mapping)}else{const l=a.image;if(l&&l.height>0){const c=new Qd(l.height/2);return c.fromEquirectangularTexture(i,a),t.set(a,c),a.addEventListener("dispose",r),e(c.texture,a.mapping)}else return null}}return a}function r(a){const o=a.target;o.removeEventListener("dispose",r);const l=t.get(o);l!==void 0&&(t.delete(o),l.dispose())}function s(){t=new WeakMap}return{get:n,dispose:s}}class cc extends Za{constructor(t=-1,e=1,n=1,r=-1,s=.1,a=2e3){super();this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=r,this.near=s,this.far=a,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=t.view===null?null:Object.assign({},t.view),this}setViewOffset(t,e,n,r,s,a){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=r,this.view.width=s,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let s=n-t,a=n+t,o=r+e,l=r-e;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,u=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=c*this.view.offsetX,a=s+c*this.view.width,o-=u*this.view.offsetY,l=o-u*this.view.height}this.projectionMatrix.makeOrthographic(s,a,o,l,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}}cc.prototype.isOrthographicCamera=!0;const sr=4,Ku=[.125,.215,.35,.446,.526,.582],gi=20,Oo=new cc,Zu=new Mt;let Go=null;const fi=(1+Math.sqrt(5))/2,Xi=1/fi,zu=[new k(1,1,1),new k(-1,1,1),new k(1,1,-1),new k(-1,1,-1),new k(0,fi,Xi),new k(0,fi,-Xi),new k(Xi,0,fi),new k(-Xi,0,fi),new k(fi,Xi,0),new k(-fi,Xi,0)];class kl{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,n=.1,r=100){Go=this._renderer.getRenderTarget(),this._setSize(256);const s=this._allocateTargets();return s.depthBuffer=!0,this._sceneToCubeUV(t,n,r,s),e>0&&this._blur(s,0,0,e),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(t,e=null){return this._fromTexture(t,e)}fromCubemap(t,e=null){return this._fromTexture(t,e)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=Yu(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=_u(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(t){this._lodMax=Math.floor(Math.log2(t)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let t=0;t<this._lodPlanes.length;t++)this._lodPlanes[t].dispose()}_cleanup(t){this._renderer.setRenderTarget(Go),t.scissorTest=!1,ta(t,0,0,t.width,t.height)}_fromTexture(t,e){t.mapping===yr||t.mapping===Ar?this._setSize(t.image.length===0?16:t.image[0].width||t.image[0].image.width):this._setSize(t.image.width/4),Go=this._renderer.getRenderTarget();const n=e||this._allocateTargets();return this._textureToCubeUV(t,n),this._applyPMREM(n),this._cleanup(n),n}_allocateTargets(){const t=3*Math.max(this._cubeSize,112),e=4*this._cubeSize-32,n={magFilter:Pe,minFilter:Pe,generateMipmaps:!1,type:vi,format:qe,encoding:Vn,depthBuffer:!1},r=Qu(t,e,n);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==t){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=Qu(t,e,n);const{_lodMax:s}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=ZS(s)),this._blurMaterial=zS(s,t,e)}return r}_compileMaterial(t){const e=new pe(this._lodPlanes[0],t);this._renderer.compile(e,Oo)}_sceneToCubeUV(t,e,n,r){const o=new Te(90,1,e,n),l=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],u=this._renderer,h=u.autoClear,d=u.toneMapping;u.getClearColor(Zu),u.toneMapping=Ln,u.autoClear=!1;const m=new Ka({name:"PMREM.Background",side:Ke,depthWrite:!1,depthTest:!1}),g=new pe(new Rr,m);let p=!1;const f=t.background;f?f.isColor&&(m.color.copy(f),t.background=null,p=!0):(m.color.copy(Zu),p=!0);for(let y=0;y<6;y++){const M=y%3;M===0?(o.up.set(0,l[y],0),o.lookAt(c[y],0,0)):M===1?(o.up.set(0,0,l[y]),o.lookAt(0,c[y],0)):(o.up.set(0,l[y],0),o.lookAt(0,0,c[y]));const E=this._cubeSize;ta(r,M*E,y>2?E:0,E,E),u.setRenderTarget(r),p&&u.render(g,o),u.render(t,o)}g.geometry.dispose(),g.material.dispose(),u.toneMapping=d,u.autoClear=h,t.background=f}_textureToCubeUV(t,e){const n=this._renderer,r=t.mapping===yr||t.mapping===Ar;r?(this._cubemapMaterial===null&&(this._cubemapMaterial=Yu()),this._cubemapMaterial.uniforms.flipEnvMap.value=t.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=_u());const s=r?this._cubemapMaterial:this._equirectMaterial,a=new pe(this._lodPlanes[0],s),o=s.uniforms;o.envMap.value=t;const l=this._cubeSize;ta(e,0,0,3*l,2*l),n.setRenderTarget(e),n.render(a,Oo)}_applyPMREM(t){const e=this._renderer,n=e.autoClear;e.autoClear=!1;for(let r=1;r<this._lodPlanes.length;r++){const s=Math.sqrt(this._sigmas[r]*this._sigmas[r]-this._sigmas[r-1]*this._sigmas[r-1]),a=zu[(r-1)%zu.length];this._blur(t,r-1,r,s,a)}e.autoClear=n}_blur(t,e,n,r,s){const a=this._pingPongRenderTarget;this._halfBlur(t,a,e,n,r,"latitudinal",s),this._halfBlur(a,t,n,n,r,"longitudinal",s)}_halfBlur(t,e,n,r,s,a,o){const l=this._renderer,c=this._blurMaterial;a!=="latitudinal"&&a!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const u=3,h=new pe(this._lodPlanes[r],c),d=c.uniforms,m=this._sizeLods[n]-1,g=isFinite(s)?Math.PI/(2*m):2*Math.PI/(2*gi-1),p=s/g,f=isFinite(s)?1+Math.floor(u*p):gi;f>gi&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${f} samples when the maximum is set to ${gi}`);const y=[];let M=0;for(let U=0;U<gi;++U){const X=U/p,dt=Math.exp(-X*X/2);y.push(dt),U===0?M+=dt:U<f&&(M+=2*dt)}for(let U=0;U<y.length;U++)y[U]=y[U]/M;d.envMap.value=t.texture,d.samples.value=f,d.weights.value=y,d.latitudinal.value=a==="latitudinal",o&&(d.poleAxis.value=o);const{_lodMax:E}=this;d.dTheta.value=g,d.mipInt.value=E-n;const R=this._sizeLods[r],b=3*R*(r>E-sr?r-E+sr:0),D=4*(this._cubeSize-R);ta(e,b,D,3*R,2*R),l.setRenderTarget(e),l.render(h,Oo)}}function ZS(i){const t=[],e=[],n=[];let r=i;const s=i-sr+1+Ku.length;for(let a=0;a<s;a++){const o=Math.pow(2,r);e.push(o);let l=1/o;a>i-sr?l=Ku[a-i+sr-1]:a===0&&(l=0),n.push(l);const c=1/(o-1),u=-c/2,h=1+c/2,d=[u,u,h,u,h,h,u,u,h,h,u,h],m=6,g=6,p=3,f=2,y=1,M=new Float32Array(p*g*m),E=new Float32Array(f*g*m),R=new Float32Array(y*g*m);for(let D=0;D<m;D++){const U=D%3*2/3-1,X=D>2?0:-1,dt=[U,X,0,U+2/3,X,0,U+2/3,X+1,0,U,X,0,U+2/3,X+1,0,U,X+1,0];M.set(dt,p*g*D),E.set(d,f*g*D);const K=[D,D,D,D,D,D];R.set(K,y*g*D)}const b=new te;b.setAttribute("position",new re(M,p)),b.setAttribute("uv",new re(E,f)),b.setAttribute("faceIndex",new re(R,y)),t.push(b),r>sr&&r--}return{lodPlanes:t,sizeLods:e,sigmas:n}}function Qu(i,t,e){const n=new We(i,t,e);return n.texture.mapping=Ga,n.texture.name="PMREM.cubeUv",n.scissorTest=!0,n}function ta(i,t,e,n,r){i.viewport.set(t,e,n,r),i.scissor.set(t,e,n,r)}function zS(i,t,e){const n=new Float32Array(gi),r=new k(0,1,0);return new Le({name:"SphericalGaussianBlur",defines:{n:gi,CUBEUV_TEXEL_WIDTH:1/t,CUBEUV_TEXEL_HEIGHT:1/e,CUBEUV_MAX_MIP:`${i}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:n},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:r}},vertexShader:uc(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:Yn,depthTest:!1,depthWrite:!1})}function _u(){return new Le({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:uc(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:Yn,depthTest:!1,depthWrite:!1})}function Yu(){return new Le({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:uc(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:Yn,depthTest:!1,depthWrite:!1})}function uc(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function QS(i){let t=new WeakMap,e=null;function n(o){if(o&&o.isTexture){const l=o.mapping,c=l===bl||l===Tl,u=l===yr||l===Ar;if(c||u)if(o.isRenderTargetTexture&&o.needsPMREMUpdate===!0){o.needsPMREMUpdate=!1;let h=t.get(o);return e===null&&(e=new kl(i)),h=c?e.fromEquirectangular(o,h):e.fromCubemap(o,h),t.set(o,h),h.texture}else{if(t.has(o))return t.get(o).texture;{const h=o.image;if(c&&h&&h.height>0||u&&h&&r(h)){e===null&&(e=new kl(i));const d=c?e.fromEquirectangular(o):e.fromCubemap(o);return t.set(o,d),o.addEventListener("dispose",s),d.texture}else return null}}}return o}function r(o){let l=0;const c=6;for(let u=0;u<c;u++)o[u]!==void 0&&l++;return l===c}function s(o){const l=o.target;l.removeEventListener("dispose",s);const c=t.get(l);c!==void 0&&(t.delete(l),c.dispose())}function a(){t=new WeakMap,e!==null&&(e.dispose(),e=null)}return{get:n,dispose:a}}function _S(i){const t={};function e(n){if(t[n]!==void 0)return t[n];let r;switch(n){case"WEBGL_depth_texture":r=i.getExtension("WEBGL_depth_texture")||i.getExtension("MOZ_WEBGL_depth_texture")||i.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=i.getExtension("EXT_texture_filter_anisotropic")||i.getExtension("MOZ_EXT_texture_filter_anisotropic")||i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=i.getExtension("WEBGL_compressed_texture_s3tc")||i.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=i.getExtension("WEBGL_compressed_texture_pvrtc")||i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=i.getExtension(n)}return t[n]=r,r}return{has:function(n){return e(n)!==null},init:function(n){n.isWebGL2?e("EXT_color_buffer_float"):(e("WEBGL_depth_texture"),e("OES_texture_float"),e("OES_texture_half_float"),e("OES_texture_half_float_linear"),e("OES_standard_derivatives"),e("OES_element_index_uint"),e("OES_vertex_array_object"),e("ANGLE_instanced_arrays")),e("OES_texture_float_linear"),e("EXT_color_buffer_half_float"),e("WEBGL_multisampled_render_to_texture")},get:function(n){const r=e(n);return r===null&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),r}}}function YS(i,t,e,n){const r={},s=new WeakMap;function a(h){const d=h.target;d.index!==null&&t.remove(d.index);for(const g in d.attributes)t.remove(d.attributes[g]);d.removeEventListener("dispose",a),delete r[d.id];const m=s.get(d);m&&(t.remove(m),s.delete(d)),n.releaseStatesOfGeometry(d),d.isInstancedBufferGeometry===!0&&delete d._maxInstanceCount,e.memory.geometries--}function o(h,d){return r[d.id]===!0||(d.addEventListener("dispose",a),r[d.id]=!0,e.memory.geometries++),d}function l(h){const d=h.attributes;for(const g in d)t.update(d[g],34962);const m=h.morphAttributes;for(const g in m){const p=m[g];for(let f=0,y=p.length;f<y;f++)t.update(p[f],34962)}}function c(h){const d=[],m=h.index,g=h.attributes.position;let p=0;if(m!==null){const M=m.array;p=m.version;for(let E=0,R=M.length;E<R;E+=3){const b=M[E+0],D=M[E+1],U=M[E+2];d.push(b,D,D,U,U,b)}}else{const M=g.array;p=g.version;for(let E=0,R=M.length/3-1;E<R;E+=3){const b=E+0,D=E+1,U=E+2;d.push(b,D,D,U,U,b)}}const f=new(Gd(d)?zd:Zd)(d,1);f.version=p;const y=s.get(h);y&&t.remove(y),s.set(h,f)}function u(h){const d=s.get(h);if(d){const m=h.index;m!==null&&d.version<m.version&&c(h)}else c(h);return s.get(h)}return{get:o,update:l,getWireframeAttribute:u}}function $S(i,t,e,n){const r=n.isWebGL2;let s;function a(d){s=d}let o,l;function c(d){o=d.type,l=d.bytesPerElement}function u(d,m){i.drawElements(s,m,o,d*l),e.update(m,s,1)}function h(d,m,g){if(g===0)return;let p,f;if(r)p=i,f="drawElementsInstanced";else if(p=t.get("ANGLE_instanced_arrays"),f="drawElementsInstancedANGLE",p===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}p[f](s,m,o,d*l,g),e.update(m,s,g)}this.setMode=a,this.setIndex=c,this.render=u,this.renderInstances=h}function tx(i){const t={geometries:0,textures:0},e={frame:0,calls:0,triangles:0,points:0,lines:0};function n(s,a,o){switch(e.calls++,a){case 4:e.triangles+=o*(s/3);break;case 1:e.lines+=o*(s/2);break;case 3:e.lines+=o*(s-1);break;case 2:e.lines+=o*s;break;case 0:e.points+=o*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",a);break}}function r(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0}return{memory:t,render:e,programs:null,autoReset:!0,reset:r,update:n}}function ex(i,t){return i[0]-t[0]}function nx(i,t){return Math.abs(t[1])-Math.abs(i[1])}function jo(i,t){let e=1;const n=t.isInterleavedBufferAttribute?t.data.array:t.array;n instanceof Int8Array?e=127:n instanceof Int16Array?e=32767:n instanceof Int32Array?e=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",n),i.divideScalar(e)}function ix(i,t,e){const n={},r=new Float32Array(8),s=new WeakMap,a=new Kt,o=[];for(let c=0;c<8;c++)o[c]=[c,0];function l(c,u,h,d){const m=c.morphTargetInfluences;if(t.isWebGL2===!0){const p=u.morphAttributes.position||u.morphAttributes.normal||u.morphAttributes.color,f=p!==void 0?p.length:0;let y=s.get(u);if(y===void 0||y.count!==f){let F=function(){B.dispose(),s.delete(u),u.removeEventListener("dispose",F)};var g=F;y!==void 0&&y.texture.dispose();const R=u.morphAttributes.position!==void 0,b=u.morphAttributes.normal!==void 0,D=u.morphAttributes.color!==void 0,U=u.morphAttributes.position||[],X=u.morphAttributes.normal||[],dt=u.morphAttributes.color||[];let K=0;R===!0&&(K=1),b===!0&&(K=2),D===!0&&(K=3);let v=u.attributes.position.count*K,C=1;v>t.maxTextureSize&&(C=Math.ceil(v/t.maxTextureSize),v=t.maxTextureSize);const it=new Float32Array(v*C*4*f),B=new Xa(it,v,C,f);B.type=Cn,B.needsUpdate=!0;const G=K*4;for(let H=0;H<f;H++){const L=U[H],z=X[H],lt=dt[H],ut=v*C*4*H;for(let ht=0;ht<L.count;ht++){const At=ht*G;R===!0&&(a.fromBufferAttribute(L,ht),L.normalized===!0&&jo(a,L),it[ut+At+0]=a.x,it[ut+At+1]=a.y,it[ut+At+2]=a.z,it[ut+At+3]=0),b===!0&&(a.fromBufferAttribute(z,ht),z.normalized===!0&&jo(a,z),it[ut+At+4]=a.x,it[ut+At+5]=a.y,it[ut+At+6]=a.z,it[ut+At+7]=0),D===!0&&(a.fromBufferAttribute(lt,ht),lt.normalized===!0&&jo(a,lt),it[ut+At+8]=a.x,it[ut+At+9]=a.y,it[ut+At+10]=a.z,it[ut+At+11]=lt.itemSize===4?a.w:1)}}y={count:f,texture:B,size:new ct(v,C)},s.set(u,y),u.addEventListener("dispose",F)}let M=0;for(let R=0;R<m.length;R++)M+=m[R];const E=u.morphTargetsRelative?1:1-M;d.getUniforms().setValue(i,"morphTargetBaseInfluence",E),d.getUniforms().setValue(i,"morphTargetInfluences",m),d.getUniforms().setValue(i,"morphTargetsTexture",y.texture,e),d.getUniforms().setValue(i,"morphTargetsTextureSize",y.size)}else{const p=m===void 0?0:m.length;let f=n[u.id];if(f===void 0||f.length!==p){f=[];for(let b=0;b<p;b++)f[b]=[b,0];n[u.id]=f}for(let b=0;b<p;b++){const D=f[b];D[0]=b,D[1]=m[b]}f.sort(nx);for(let b=0;b<8;b++)b<p&&f[b][1]?(o[b][0]=f[b][0],o[b][1]=f[b][1]):(o[b][0]=Number.MAX_SAFE_INTEGER,o[b][1]=0);o.sort(ex);const y=u.morphAttributes.position,M=u.morphAttributes.normal;let E=0;for(let b=0;b<8;b++){const D=o[b],U=D[0],X=D[1];U!==Number.MAX_SAFE_INTEGER&&X?(y&&u.getAttribute("morphTarget"+b)!==y[U]&&u.setAttribute("morphTarget"+b,y[U]),M&&u.getAttribute("morphNormal"+b)!==M[U]&&u.setAttribute("morphNormal"+b,M[U]),r[b]=X,E+=X):(y&&u.hasAttribute("morphTarget"+b)===!0&&u.deleteAttribute("morphTarget"+b),M&&u.hasAttribute("morphNormal"+b)===!0&&u.deleteAttribute("morphNormal"+b),r[b]=0)}const R=u.morphTargetsRelative?1:1-E;d.getUniforms().setValue(i,"morphTargetBaseInfluence",R),d.getUniforms().setValue(i,"morphTargetInfluences",r)}}return{update:l}}function rx(i,t,e,n){let r=new WeakMap;function s(l){const c=n.render.frame,u=l.geometry,h=t.get(l,u);return r.get(h)!==c&&(t.update(h),r.set(h,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",o)===!1&&l.addEventListener("dispose",o),e.update(l.instanceMatrix,34962),l.instanceColor!==null&&e.update(l.instanceColor,34962)),h}function a(){r=new WeakMap}function o(l){const c=l.target;c.removeEventListener("dispose",o),e.remove(c.instanceMatrix),c.instanceColor!==null&&e.remove(c.instanceColor)}return{update:s,dispose:a}}const Yd=new ge,$d=new Xa,tf=new oc,ef=new za,$u=[],th=[],eh=new Float32Array(16),nh=new Float32Array(9),ih=new Float32Array(4);function Er(i,t,e){const n=i[0];if(n<=0||n>0)return i;const r=t*e;let s=$u[r];if(s===void 0&&(s=new Float32Array(r),$u[r]=s),t!==0){n.toArray(s,0);for(let a=1,o=0;a!==t;++a)o+=e,i[a].toArray(s,o)}return s}function Ne(i,t){if(i.length!==t.length)return!1;for(let e=0,n=i.length;e<n;e++)if(i[e]!==t[e])return!1;return!0}function ke(i,t){for(let e=0,n=t.length;e<n;e++)i[e]=t[e]}function _a(i,t){let e=th[t];e===void 0&&(e=new Int32Array(t),th[t]=e);for(let n=0;n!==t;++n)e[n]=i.allocateTextureUnit();return e}function sx(i,t){const e=this.cache;e[0]!==t&&(i.uniform1f(this.addr,t),e[0]=t)}function ax(i,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(i.uniform2f(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(Ne(e,t))return;i.uniform2fv(this.addr,t),ke(e,t)}}function ox(i,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(i.uniform3f(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else if(t.r!==void 0)(e[0]!==t.r||e[1]!==t.g||e[2]!==t.b)&&(i.uniform3f(this.addr,t.r,t.g,t.b),e[0]=t.r,e[1]=t.g,e[2]=t.b);else{if(Ne(e,t))return;i.uniform3fv(this.addr,t),ke(e,t)}}function lx(i,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(i.uniform4f(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(Ne(e,t))return;i.uniform4fv(this.addr,t),ke(e,t)}}function cx(i,t){const e=this.cache,n=t.elements;if(n===void 0){if(Ne(e,t))return;i.uniformMatrix2fv(this.addr,!1,t),ke(e,t)}else{if(Ne(e,n))return;ih.set(n),i.uniformMatrix2fv(this.addr,!1,ih),ke(e,n)}}function ux(i,t){const e=this.cache,n=t.elements;if(n===void 0){if(Ne(e,t))return;i.uniformMatrix3fv(this.addr,!1,t),ke(e,t)}else{if(Ne(e,n))return;nh.set(n),i.uniformMatrix3fv(this.addr,!1,nh),ke(e,n)}}function hx(i,t){const e=this.cache,n=t.elements;if(n===void 0){if(Ne(e,t))return;i.uniformMatrix4fv(this.addr,!1,t),ke(e,t)}else{if(Ne(e,n))return;eh.set(n),i.uniformMatrix4fv(this.addr,!1,eh),ke(e,n)}}function dx(i,t){const e=this.cache;e[0]!==t&&(i.uniform1i(this.addr,t),e[0]=t)}function fx(i,t){const e=this.cache;Ne(e,t)||(i.uniform2iv(this.addr,t),ke(e,t))}function px(i,t){const e=this.cache;Ne(e,t)||(i.uniform3iv(this.addr,t),ke(e,t))}function mx(i,t){const e=this.cache;Ne(e,t)||(i.uniform4iv(this.addr,t),ke(e,t))}function gx(i,t){const e=this.cache;e[0]!==t&&(i.uniform1ui(this.addr,t),e[0]=t)}function yx(i,t){const e=this.cache;Ne(e,t)||(i.uniform2uiv(this.addr,t),ke(e,t))}function Ax(i,t){const e=this.cache;Ne(e,t)||(i.uniform3uiv(this.addr,t),ke(e,t))}function Sx(i,t){const e=this.cache;Ne(e,t)||(i.uniform4uiv(this.addr,t),ke(e,t))}function xx(i,t,e){const n=this.cache,r=e.allocateTextureUnit();n[0]!==r&&(i.uniform1i(this.addr,r),n[0]=r),e.setTexture2D(t||Yd,r)}function vx(i,t,e){const n=this.cache,r=e.allocateTextureUnit();n[0]!==r&&(i.uniform1i(this.addr,r),n[0]=r),e.setTexture3D(t||tf,r)}function bx(i,t,e){const n=this.cache,r=e.allocateTextureUnit();n[0]!==r&&(i.uniform1i(this.addr,r),n[0]=r),e.setTextureCube(t||ef,r)}function Tx(i,t,e){const n=this.cache,r=e.allocateTextureUnit();n[0]!==r&&(i.uniform1i(this.addr,r),n[0]=r),e.setTexture2DArray(t||$d,r)}function Mx(i){switch(i){case 5126:return sx;case 35664:return ax;case 35665:return ox;case 35666:return lx;case 35674:return cx;case 35675:return ux;case 35676:return hx;case 5124:case 35670:return dx;case 35667:case 35671:return fx;case 35668:case 35672:return px;case 35669:case 35673:return mx;case 5125:return gx;case 36294:return yx;case 36295:return Ax;case 36296:return Sx;case 35678:case 36198:case 36298:case 36306:case 35682:return xx;case 35679:case 36299:case 36307:return vx;case 35680:case 36300:case 36308:case 36293:return bx;case 36289:case 36303:case 36311:case 36292:return Tx}}function wx(i,t){i.uniform1fv(this.addr,t)}function Ix(i,t){const e=Er(t,this.size,2);i.uniform2fv(this.addr,e)}function kx(i,t){const e=Er(t,this.size,3);i.uniform3fv(this.addr,e)}function Rx(i,t){const e=Er(t,this.size,4);i.uniform4fv(this.addr,e)}function Ex(i,t){const e=Er(t,this.size,4);i.uniformMatrix2fv(this.addr,!1,e)}function Wx(i,t){const e=Er(t,this.size,9);i.uniformMatrix3fv(this.addr,!1,e)}function Cx(i,t){const e=Er(t,this.size,16);i.uniformMatrix4fv(this.addr,!1,e)}function Lx(i,t){i.uniform1iv(this.addr,t)}function Nx(i,t){i.uniform2iv(this.addr,t)}function Vx(i,t){i.uniform3iv(this.addr,t)}function Ux(i,t){i.uniform4iv(this.addr,t)}function Px(i,t){i.uniform1uiv(this.addr,t)}function Dx(i,t){i.uniform2uiv(this.addr,t)}function Fx(i,t){i.uniform3uiv(this.addr,t)}function Bx(i,t){i.uniform4uiv(this.addr,t)}function Hx(i,t,e){const n=t.length,r=_a(e,n);i.uniform1iv(this.addr,r);for(let s=0;s!==n;++s)e.setTexture2D(t[s]||Yd,r[s])}function qx(i,t,e){const n=t.length,r=_a(e,n);i.uniform1iv(this.addr,r);for(let s=0;s!==n;++s)e.setTexture3D(t[s]||tf,r[s])}function Jx(i,t,e){const n=t.length,r=_a(e,n);i.uniform1iv(this.addr,r);for(let s=0;s!==n;++s)e.setTextureCube(t[s]||ef,r[s])}function Ox(i,t,e){const n=t.length,r=_a(e,n);i.uniform1iv(this.addr,r);for(let s=0;s!==n;++s)e.setTexture2DArray(t[s]||$d,r[s])}function Gx(i){switch(i){case 5126:return wx;case 35664:return Ix;case 35665:return kx;case 35666:return Rx;case 35674:return Ex;case 35675:return Wx;case 35676:return Cx;case 5124:case 35670:return Lx;case 35667:case 35671:return Nx;case 35668:case 35672:return Vx;case 35669:case 35673:return Ux;case 5125:return Px;case 36294:return Dx;case 36295:return Fx;case 36296:return Bx;case 35678:case 36198:case 36298:case 36306:case 35682:return Hx;case 35679:case 36299:case 36307:return qx;case 35680:case 36300:case 36308:case 36293:return Jx;case 36289:case 36303:case 36311:case 36292:return Ox}}function jx(i,t,e){this.id=i,this.addr=e,this.cache=[],this.setValue=Mx(t.type)}function nf(i,t,e){this.id=i,this.addr=e,this.cache=[],this.size=t.size,this.setValue=Gx(t.type)}nf.prototype.updateCache=function(i){const t=this.cache;i instanceof Float32Array&&t.length!==i.length&&(this.cache=new Float32Array(i.length)),ke(t,i)};function rf(i){this.id=i,this.seq=[],this.map={}}rf.prototype.setValue=function(i,t,e){const n=this.seq;for(let r=0,s=n.length;r!==s;++r){const a=n[r];a.setValue(i,t[a.id],e)}};const Xo=/(\w+)(\])?(\[|\.)?/g;function rh(i,t){i.seq.push(t),i.map[t.id]=t}function Xx(i,t,e){const n=i.name,r=n.length;for(Xo.lastIndex=0;;){const s=Xo.exec(n),a=Xo.lastIndex;let o=s[1];const l=s[2]==="]",c=s[3];if(l&&(o=o|0),c===void 0||c==="["&&a+2===r){rh(e,c===void 0?new jx(o,i,t):new nf(o,i,t));break}else{let h=e.map[o];h===void 0&&(h=new rf(o),rh(e,h)),e=h}}}function $n(i,t){this.seq=[],this.map={};const e=i.getProgramParameter(t,35718);for(let n=0;n<e;++n){const r=i.getActiveUniform(t,n),s=i.getUniformLocation(t,r.name);Xx(r,s,this)}}$n.prototype.setValue=function(i,t,e,n){const r=this.map[t];r!==void 0&&r.setValue(i,e,n)};$n.prototype.setOptional=function(i,t,e){const n=t[e];n!==void 0&&this.setValue(i,e,n)};$n.upload=function(i,t,e,n){for(let r=0,s=t.length;r!==s;++r){const a=t[r],o=e[a.id];o.needsUpdate!==!1&&a.setValue(i,o.value,n)}};$n.seqWithValue=function(i,t){const e=[];for(let n=0,r=i.length;n!==r;++n){const s=i[n];s.id in t&&e.push(s)}return e};function sh(i,t,e){const n=i.createShader(t);return i.shaderSource(n,e),i.compileShader(n),n}let Kx=0;function Zx(i,t){const e=i.split(`
`),n=[],r=Math.max(t-6,0),s=Math.min(t+6,e.length);for(let a=r;a<s;a++)n.push(a+1+": "+e[a]);return n.join(`
`)}function zx(i){switch(i){case Vn:return["Linear","( value )"];case ee:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",i),["Linear","( value )"]}}function ah(i,t,e){const n=i.getShaderParameter(t,35713),r=i.getShaderInfoLog(t).trim();if(n&&r==="")return"";const s=parseInt(/ERROR: 0:(\d+)/.exec(r)[1]);return e.toUpperCase()+`

`+r+`

`+Zx(i.getShaderSource(t),s)}function Qx(i,t){const e=zx(t);return"vec4 "+i+"( vec4 value ) { return LinearTo"+e[0]+e[1]+"; }"}function _x(i,t){let e;switch(t){case sy:e="Linear";break;case ay:e="Reinhard";break;case oy:e="OptimizedCineon";break;case qd:e="ACESFilmic";break;case ly:e="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),e="Linear"}return"vec3 "+i+"( vec3 color ) { return "+e+"ToneMapping( color ); }"}function Yx(i){return[i.extensionDerivatives||!!i.envMapCubeUVHeight||i.bumpMap||i.tangentSpaceNormalMap||i.clearcoatNormalMap||i.flatShading||i.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(i.extensionFragDepth||i.logarithmicDepthBuffer)&&i.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",i.extensionDrawBuffers&&i.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(i.extensionShaderTextureLOD||i.envMap||i.transmission)&&i.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Qr).join(`
`)}function $x(i){const t=[];for(const e in i){const n=i[e];n!==!1&&t.push("#define "+e+" "+n)}return t.join(`
`)}function tv(i,t){const e={},n=i.getProgramParameter(t,35721);for(let r=0;r<n;r++){const s=i.getActiveAttrib(t,r),a=s.name;let o=1;s.type===35674&&(o=2),s.type===35675&&(o=3),s.type===35676&&(o=4),e[a]={type:s.type,location:i.getAttribLocation(t,a),locationSize:o}}return e}function Qr(i){return i!==""}function oh(i,t){return i.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function lh(i,t){return i.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const ev=/^[ \t]*#include +<([\w\d./]+)>/gm;function Rl(i){return i.replace(ev,nv)}function nv(i,t){const e=Bt[t];if(e===void 0)throw new Error("Can not resolve #include <"+t+">");return Rl(e)}const iv=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,rv=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function ch(i){return i.replace(rv,sf).replace(iv,sv)}function sv(i,t,e,n){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),sf(i,t,e,n)}function sf(i,t,e,n){let r="";for(let s=parseInt(t);s<parseInt(e);s++)r+=n.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return r}function uh(i){let t="precision "+i.precision+` float;
precision `+i.precision+" int;";return i.precision==="highp"?t+=`
#define HIGH_PRECISION`:i.precision==="mediump"?t+=`
#define MEDIUM_PRECISION`:i.precision==="lowp"&&(t+=`
#define LOW_PRECISION`),t}function av(i){let t="SHADOWMAP_TYPE_BASIC";return i.shadowMapType===Dd?t="SHADOWMAP_TYPE_PCF":i.shadowMapType===Dg?t="SHADOWMAP_TYPE_PCF_SOFT":i.shadowMapType===zr&&(t="SHADOWMAP_TYPE_VSM"),t}function ov(i){let t="ENVMAP_TYPE_CUBE";if(i.envMap)switch(i.envMapMode){case yr:case Ar:t="ENVMAP_TYPE_CUBE";break;case Ga:t="ENVMAP_TYPE_CUBE_UV";break}return t}function lv(i){let t="ENVMAP_MODE_REFLECTION";if(i.envMap)switch(i.envMapMode){case Ar:t="ENVMAP_MODE_REFRACTION";break}return t}function cv(i){let t="ENVMAP_BLENDING_NONE";if(i.envMap)switch(i.combine){case Oa:t="ENVMAP_BLENDING_MULTIPLY";break;case iy:t="ENVMAP_BLENDING_MIX";break;case ry:t="ENVMAP_BLENDING_ADD";break}return t}function uv(i){const t=i.envMapCubeUVHeight;if(t===null)return null;const e=Math.log2(t/32+1)+3,n=1/t;return{texelWidth:1/(3*Math.max(Math.pow(2,e),7*16)),texelHeight:n,maxMip:e}}function hv(i,t,e,n){const r=i.getContext(),s=e.defines;let a=e.vertexShader,o=e.fragmentShader;const l=av(e),c=ov(e),u=lv(e),h=cv(e),d=uv(e),m=e.isWebGL2?"":Yx(e),g=$x(s),p=r.createProgram();let f,y,M=e.glslVersion?"#version "+e.glslVersion+`
`:"";e.isRawShaderMaterial?(f=[g].filter(Qr).join(`
`),f.length>0&&(f+=`
`),y=[m,g].filter(Qr).join(`
`),y.length>0&&(y+=`
`)):(f=[uh(e),"#define SHADER_NAME "+e.shaderName,g,e.instancing?"#define USE_INSTANCING":"",e.instancingColor?"#define USE_INSTANCING_COLOR":"",e.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define MAX_BONES "+e.maxBones,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+u:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.displacementMap&&e.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",e.specularColorMap?"#define USE_SPECULARCOLORMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.sheenColorMap?"#define USE_SHEENCOLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.flatShading?"#define FLAT_SHADED":"",e.skinning?"#define USE_SKINNING":"",e.useVertexTexture?"#define BONE_TEXTURE":"",e.morphTargets?"#define USE_MORPHTARGETS":"",e.morphNormals&&e.flatShading===!1?"#define USE_MORPHNORMALS":"",e.morphColors&&e.isWebGL2?"#define USE_MORPHCOLORS":"",e.morphTargetsCount>0&&e.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",e.morphTargetsCount>0&&e.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+e.morphTextureStride:"",e.morphTargetsCount>0&&e.isWebGL2?"#define MORPHTARGETS_COUNT "+e.morphTargetsCount:"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+l:"",e.sizeAttenuation?"#define USE_SIZEATTENUATION":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Qr).join(`
`),y=[m,uh(e),"#define SHADER_NAME "+e.shaderName,g,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.matcap?"#define USE_MATCAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+c:"",e.envMap?"#define "+u:"",e.envMap?"#define "+h:"",d?"#define CUBEUV_TEXEL_WIDTH "+d.texelWidth:"",d?"#define CUBEUV_TEXEL_HEIGHT "+d.texelHeight:"",d?"#define CUBEUV_MAX_MIP "+d.maxMip+".0":"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoat?"#define USE_CLEARCOAT":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",e.specularColorMap?"#define USE_SPECULARCOLORMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.alphaTest?"#define USE_ALPHATEST":"",e.sheen?"#define USE_SHEEN":"",e.sheenColorMap?"#define USE_SHEENCOLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors||e.instancingColor?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.gradientMap?"#define USE_GRADIENTMAP":"",e.flatShading?"#define FLAT_SHADED":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+l:"",e.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",e.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",e.toneMapping!==Ln?"#define TONE_MAPPING":"",e.toneMapping!==Ln?Bt.tonemapping_pars_fragment:"",e.toneMapping!==Ln?_x("toneMapping",e.toneMapping):"",e.dithering?"#define DITHERING":"",e.opaque?"#define OPAQUE":"",Bt.encodings_pars_fragment,Qx("linearToOutputTexel",e.outputEncoding),e.depthPacking?"#define DEPTH_PACKING "+e.depthPacking:"",`
`].filter(Qr).join(`
`)),a=Rl(a),a=oh(a,e),a=lh(a,e),o=Rl(o),o=oh(o,e),o=lh(o,e),a=ch(a),o=ch(o),e.isWebGL2&&e.isRawShaderMaterial!==!0&&(M=`#version 300 es
`,f=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+f,y=["#define varying in",e.glslVersion===Nu?"":"layout(location = 0) out highp vec4 pc_fragColor;",e.glslVersion===Nu?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+y);const E=M+f+a,R=M+y+o,b=sh(r,35633,E),D=sh(r,35632,R);if(r.attachShader(p,b),r.attachShader(p,D),e.index0AttributeName!==void 0?r.bindAttribLocation(p,0,e.index0AttributeName):e.morphTargets===!0&&r.bindAttribLocation(p,0,"position"),r.linkProgram(p),i.debug.checkShaderErrors){const dt=r.getProgramInfoLog(p).trim(),K=r.getShaderInfoLog(b).trim(),v=r.getShaderInfoLog(D).trim();let C=!0,it=!0;if(r.getProgramParameter(p,35714)===!1){C=!1;const B=ah(r,b,"vertex"),G=ah(r,D,"fragment");console.error("THREE.WebGLProgram: Shader Error "+r.getError()+" - VALIDATE_STATUS "+r.getProgramParameter(p,35715)+`

Program Info Log: `+dt+`
`+B+`
`+G)}else dt!==""?console.warn("THREE.WebGLProgram: Program Info Log:",dt):(K===""||v==="")&&(it=!1);it&&(this.diagnostics={runnable:C,programLog:dt,vertexShader:{log:K,prefix:f},fragmentShader:{log:v,prefix:y}})}r.deleteShader(b),r.deleteShader(D);let U;this.getUniforms=function(){return U===void 0&&(U=new $n(r,p)),U};let X;return this.getAttributes=function(){return X===void 0&&(X=tv(r,p)),X},this.destroy=function(){n.releaseStatesOfProgram(this),r.deleteProgram(p),this.program=void 0},this.name=e.shaderName,this.id=Kx++,this.cacheKey=t,this.usedTimes=1,this.program=p,this.vertexShader=b,this.fragmentShader=D,this}let dv=0;class fv{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(t){const e=t.vertexShader,n=t.fragmentShader,r=this._getShaderStage(e),s=this._getShaderStage(n),a=this._getShaderCacheForMaterial(t);return a.has(r)===!1&&(a.add(r),r.usedTimes++),a.has(s)===!1&&(a.add(s),s.usedTimes++),this}remove(t){const e=this.materialCache.get(t);for(const n of e)n.usedTimes--,n.usedTimes===0&&this.shaderCache.delete(n.code);return this.materialCache.delete(t),this}getVertexShaderID(t){return this._getShaderStage(t.vertexShader).id}getFragmentShaderID(t){return this._getShaderStage(t.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(t){const e=this.materialCache;return e.has(t)===!1&&e.set(t,new Set),e.get(t)}_getShaderStage(t){const e=this.shaderCache;if(e.has(t)===!1){const n=new pv(t);e.set(t,n)}return e.get(t)}}class pv{constructor(t){this.id=dv++,this.code=t,this.usedTimes=0}}function mv(i,t,e,n,r,s,a){const o=new Kd,l=new fv,c=[],u=r.isWebGL2,h=r.logarithmicDepthBuffer,d=r.floatVertexTextures,m=r.maxVertexUniforms,g=r.vertexTextures;let p=r.precision;const f={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function y(v){const it=v.skeleton.bones;if(d)return 1024;{const G=Math.floor((m-20)/4),F=Math.min(G,it.length);return F<it.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+it.length+" bones. This GPU supports "+F+"."),0):F}}function M(v,C,it,B,G){const F=B.fog,H=G.geometry,L=v.isMeshStandardMaterial?B.environment:null,z=(v.isMeshStandardMaterial?e:t).get(v.envMap||L),lt=!!z&&z.mapping===Ga?z.image.height:null,ut=f[v.type],ht=G.isSkinnedMesh?y(G):0;v.precision!==null&&(p=r.getMaxPrecision(v.precision),p!==v.precision&&console.warn("THREE.WebGLProgram.getParameters:",v.precision,"not supported, using",p,"instead."));const At=H.morphAttributes.position||H.morphAttributes.normal||H.morphAttributes.color,Lt=At!==void 0?At.length:0;let kt=0;H.morphAttributes.position!==void 0&&(kt=1),H.morphAttributes.normal!==void 0&&(kt=2),H.morphAttributes.color!==void 0&&(kt=3);let et,Nt,Rt,Et;if(ut){const w=mn[ut];et=w.vertexShader,Nt=w.fragmentShader}else et=v.vertexShader,Nt=v.fragmentShader,l.update(v),Rt=l.getVertexShaderID(v),Et=l.getFragmentShaderID(v);const ft=i.getRenderTarget(),Ct=v.alphaTest>0,$=v.clearcoat>0;return{isWebGL2:u,shaderID:ut,shaderName:v.type,vertexShader:et,fragmentShader:Nt,defines:v.defines,customVertexShaderID:Rt,customFragmentShaderID:Et,isRawShaderMaterial:v.isRawShaderMaterial===!0,glslVersion:v.glslVersion,precision:p,instancing:G.isInstancedMesh===!0,instancingColor:G.isInstancedMesh===!0&&G.instanceColor!==null,supportsVertexTextures:g,outputEncoding:ft===null?i.outputEncoding:ft.isXRRenderTarget===!0?ft.texture.encoding:Vn,map:!!v.map,matcap:!!v.matcap,envMap:!!z,envMapMode:z&&z.mapping,envMapCubeUVHeight:lt,lightMap:!!v.lightMap,aoMap:!!v.aoMap,emissiveMap:!!v.emissiveMap,bumpMap:!!v.bumpMap,normalMap:!!v.normalMap,objectSpaceNormalMap:v.normalMapType===Cy,tangentSpaceNormalMap:v.normalMapType===wr,decodeVideoTexture:!!v.map&&v.map.isVideoTexture===!0&&v.map.encoding===ee,clearcoat:$,clearcoatMap:$&&!!v.clearcoatMap,clearcoatRoughnessMap:$&&!!v.clearcoatRoughnessMap,clearcoatNormalMap:$&&!!v.clearcoatNormalMap,displacementMap:!!v.displacementMap,roughnessMap:!!v.roughnessMap,metalnessMap:!!v.metalnessMap,specularMap:!!v.specularMap,specularIntensityMap:!!v.specularIntensityMap,specularColorMap:!!v.specularColorMap,opaque:v.transparent===!1&&v.blending===hr,alphaMap:!!v.alphaMap,alphaTest:Ct,gradientMap:!!v.gradientMap,sheen:v.sheen>0,sheenColorMap:!!v.sheenColorMap,sheenRoughnessMap:!!v.sheenRoughnessMap,transmission:v.transmission>0,transmissionMap:!!v.transmissionMap,thicknessMap:!!v.thicknessMap,combine:v.combine,vertexTangents:!!v.normalMap&&!!H.attributes.tangent,vertexColors:v.vertexColors,vertexAlphas:v.vertexColors===!0&&!!H.attributes.color&&H.attributes.color.itemSize===4,vertexUvs:!!v.map||!!v.bumpMap||!!v.normalMap||!!v.specularMap||!!v.alphaMap||!!v.emissiveMap||!!v.roughnessMap||!!v.metalnessMap||!!v.clearcoatMap||!!v.clearcoatRoughnessMap||!!v.clearcoatNormalMap||!!v.displacementMap||!!v.transmissionMap||!!v.thicknessMap||!!v.specularIntensityMap||!!v.specularColorMap||!!v.sheenColorMap||!!v.sheenRoughnessMap,uvsVertexOnly:!(!!v.map||!!v.bumpMap||!!v.normalMap||!!v.specularMap||!!v.alphaMap||!!v.emissiveMap||!!v.roughnessMap||!!v.metalnessMap||!!v.clearcoatNormalMap||v.transmission>0||!!v.transmissionMap||!!v.thicknessMap||!!v.specularIntensityMap||!!v.specularColorMap||v.sheen>0||!!v.sheenColorMap||!!v.sheenRoughnessMap)&&!!v.displacementMap,fog:!!F,useFog:v.fog,fogExp2:F&&F.isFogExp2,flatShading:!!v.flatShading,sizeAttenuation:v.sizeAttenuation,logarithmicDepthBuffer:h,skinning:G.isSkinnedMesh===!0&&ht>0,maxBones:ht,useVertexTexture:d,morphTargets:H.morphAttributes.position!==void 0,morphNormals:H.morphAttributes.normal!==void 0,morphColors:H.morphAttributes.color!==void 0,morphTargetsCount:Lt,morphTextureStride:kt,numDirLights:C.directional.length,numPointLights:C.point.length,numSpotLights:C.spot.length,numRectAreaLights:C.rectArea.length,numHemiLights:C.hemi.length,numDirLightShadows:C.directionalShadowMap.length,numPointLightShadows:C.pointShadowMap.length,numSpotLightShadows:C.spotShadowMap.length,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,dithering:v.dithering,shadowMapEnabled:i.shadowMap.enabled&&it.length>0,shadowMapType:i.shadowMap.type,toneMapping:v.toneMapped?i.toneMapping:Ln,physicallyCorrectLights:i.physicallyCorrectLights,premultipliedAlpha:v.premultipliedAlpha,doubleSided:v.side===Mi,flipSided:v.side===Ke,depthPacking:v.depthPacking!==void 0?v.depthPacking:!1,index0AttributeName:v.index0AttributeName,extensionDerivatives:v.extensions&&v.extensions.derivatives,extensionFragDepth:v.extensions&&v.extensions.fragDepth,extensionDrawBuffers:v.extensions&&v.extensions.drawBuffers,extensionShaderTextureLOD:v.extensions&&v.extensions.shaderTextureLOD,rendererExtensionFragDepth:u||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:u||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:u||n.has("EXT_shader_texture_lod"),customProgramCacheKey:v.customProgramCacheKey()}}function E(v){const C=[];if(v.shaderID?C.push(v.shaderID):(C.push(v.customVertexShaderID),C.push(v.customFragmentShaderID)),v.defines!==void 0)for(const it in v.defines)C.push(it),C.push(v.defines[it]);return v.isRawShaderMaterial===!1&&(R(C,v),b(C,v),C.push(i.outputEncoding)),C.push(v.customProgramCacheKey),C.join()}function R(v,C){v.push(C.precision),v.push(C.outputEncoding),v.push(C.envMapMode),v.push(C.envMapCubeUVHeight),v.push(C.combine),v.push(C.vertexUvs),v.push(C.fogExp2),v.push(C.sizeAttenuation),v.push(C.maxBones),v.push(C.morphTargetsCount),v.push(C.morphAttributeCount),v.push(C.numDirLights),v.push(C.numPointLights),v.push(C.numSpotLights),v.push(C.numHemiLights),v.push(C.numRectAreaLights),v.push(C.numDirLightShadows),v.push(C.numPointLightShadows),v.push(C.numSpotLightShadows),v.push(C.shadowMapType),v.push(C.toneMapping),v.push(C.numClippingPlanes),v.push(C.numClipIntersection)}function b(v,C){o.disableAll(),C.isWebGL2&&o.enable(0),C.supportsVertexTextures&&o.enable(1),C.instancing&&o.enable(2),C.instancingColor&&o.enable(3),C.map&&o.enable(4),C.matcap&&o.enable(5),C.envMap&&o.enable(6),C.lightMap&&o.enable(7),C.aoMap&&o.enable(8),C.emissiveMap&&o.enable(9),C.bumpMap&&o.enable(10),C.normalMap&&o.enable(11),C.objectSpaceNormalMap&&o.enable(12),C.tangentSpaceNormalMap&&o.enable(13),C.clearcoat&&o.enable(14),C.clearcoatMap&&o.enable(15),C.clearcoatRoughnessMap&&o.enable(16),C.clearcoatNormalMap&&o.enable(17),C.displacementMap&&o.enable(18),C.specularMap&&o.enable(19),C.roughnessMap&&o.enable(20),C.metalnessMap&&o.enable(21),C.gradientMap&&o.enable(22),C.alphaMap&&o.enable(23),C.alphaTest&&o.enable(24),C.vertexColors&&o.enable(25),C.vertexAlphas&&o.enable(26),C.vertexUvs&&o.enable(27),C.vertexTangents&&o.enable(28),C.uvsVertexOnly&&o.enable(29),C.fog&&o.enable(30),v.push(o.mask),o.disableAll(),C.useFog&&o.enable(0),C.flatShading&&o.enable(1),C.logarithmicDepthBuffer&&o.enable(2),C.skinning&&o.enable(3),C.useVertexTexture&&o.enable(4),C.morphTargets&&o.enable(5),C.morphNormals&&o.enable(6),C.morphColors&&o.enable(7),C.premultipliedAlpha&&o.enable(8),C.shadowMapEnabled&&o.enable(9),C.physicallyCorrectLights&&o.enable(10),C.doubleSided&&o.enable(11),C.flipSided&&o.enable(12),C.depthPacking&&o.enable(13),C.dithering&&o.enable(14),C.specularIntensityMap&&o.enable(15),C.specularColorMap&&o.enable(16),C.transmission&&o.enable(17),C.transmissionMap&&o.enable(18),C.thicknessMap&&o.enable(19),C.sheen&&o.enable(20),C.sheenColorMap&&o.enable(21),C.sheenRoughnessMap&&o.enable(22),C.decodeVideoTexture&&o.enable(23),C.opaque&&o.enable(24),v.push(o.mask)}function D(v){const C=f[v.type];let it;if(C){const B=mn[C];it=La.clone(B.uniforms)}else it=v.uniforms;return it}function U(v,C){let it;for(let B=0,G=c.length;B<G;B++){const F=c[B];if(F.cacheKey===C){it=F,++it.usedTimes;break}}return it===void 0&&(it=new hv(i,C,v,s),c.push(it)),it}function X(v){if(--v.usedTimes===0){const C=c.indexOf(v);c[C]=c[c.length-1],c.pop(),v.destroy()}}function dt(v){l.remove(v)}function K(){l.dispose()}return{getParameters:M,getProgramCacheKey:E,getUniforms:D,acquireProgram:U,releaseProgram:X,releaseShaderCache:dt,programs:c,dispose:K}}function gv(){let i=new WeakMap;function t(s){let a=i.get(s);return a===void 0&&(a={},i.set(s,a)),a}function e(s){i.delete(s)}function n(s,a,o){i.get(s)[a]=o}function r(){i=new WeakMap}return{get:t,remove:e,update:n,dispose:r}}function yv(i,t){return i.groupOrder!==t.groupOrder?i.groupOrder-t.groupOrder:i.renderOrder!==t.renderOrder?i.renderOrder-t.renderOrder:i.material.id!==t.material.id?i.material.id-t.material.id:i.z!==t.z?i.z-t.z:i.id-t.id}function hh(i,t){return i.groupOrder!==t.groupOrder?i.groupOrder-t.groupOrder:i.renderOrder!==t.renderOrder?i.renderOrder-t.renderOrder:i.z!==t.z?t.z-i.z:i.id-t.id}function dh(){const i=[];let t=0;const e=[],n=[],r=[];function s(){t=0,e.length=0,n.length=0,r.length=0}function a(h,d,m,g,p,f){let y=i[t];return y===void 0?(y={id:h.id,object:h,geometry:d,material:m,groupOrder:g,renderOrder:h.renderOrder,z:p,group:f},i[t]=y):(y.id=h.id,y.object=h,y.geometry=d,y.material=m,y.groupOrder=g,y.renderOrder=h.renderOrder,y.z=p,y.group=f),t++,y}function o(h,d,m,g,p,f){const y=a(h,d,m,g,p,f);m.transmission>0?n.push(y):m.transparent===!0?r.push(y):e.push(y)}function l(h,d,m,g,p,f){const y=a(h,d,m,g,p,f);m.transmission>0?n.unshift(y):m.transparent===!0?r.unshift(y):e.unshift(y)}function c(h,d){e.length>1&&e.sort(h||yv),n.length>1&&n.sort(d||hh),r.length>1&&r.sort(d||hh)}function u(){for(let h=t,d=i.length;h<d;h++){const m=i[h];if(m.id===null)break;m.id=null,m.object=null,m.geometry=null,m.material=null,m.group=null}}return{opaque:e,transmissive:n,transparent:r,init:s,push:o,unshift:l,finish:u,sort:c}}function Av(){let i=new WeakMap;function t(n,r){let s;return i.has(n)===!1?(s=new dh,i.set(n,[s])):r>=i.get(n).length?(s=new dh,i.get(n).push(s)):s=i.get(n)[r],s}function e(){i=new WeakMap}return{get:t,dispose:e}}function Sv(){const i={};return{get:function(t){if(i[t.id]!==void 0)return i[t.id];let e;switch(t.type){case"DirectionalLight":e={direction:new k,color:new Mt};break;case"SpotLight":e={position:new k,direction:new k,color:new Mt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":e={position:new k,color:new Mt,distance:0,decay:0};break;case"HemisphereLight":e={direction:new k,skyColor:new Mt,groundColor:new Mt};break;case"RectAreaLight":e={color:new Mt,position:new k,halfWidth:new k,halfHeight:new k};break}return i[t.id]=e,e}}}function xv(){const i={};return{get:function(t){if(i[t.id]!==void 0)return i[t.id];let e;switch(t.type){case"DirectionalLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new ct};break;case"SpotLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new ct};break;case"PointLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new ct,shadowCameraNear:1,shadowCameraFar:1e3};break}return i[t.id]=e,e}}}let vv=0;function bv(i,t){return(t.castShadow?1:0)-(i.castShadow?1:0)}function Tv(i,t){const e=new Sv,n=xv(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let u=0;u<9;u++)r.probe.push(new k);const s=new k,a=new It,o=new It;function l(u,h){let d=0,m=0,g=0;for(let dt=0;dt<9;dt++)r.probe[dt].set(0,0,0);let p=0,f=0,y=0,M=0,E=0,R=0,b=0,D=0;u.sort(bv);const U=h!==!0?Math.PI:1;for(let dt=0,K=u.length;dt<K;dt++){const v=u[dt],C=v.color,it=v.intensity,B=v.distance,G=v.shadow&&v.shadow.map?v.shadow.map.texture:null;if(v.isAmbientLight)d+=C.r*it*U,m+=C.g*it*U,g+=C.b*it*U;else if(v.isLightProbe)for(let F=0;F<9;F++)r.probe[F].addScaledVector(v.sh.coefficients[F],it);else if(v.isDirectionalLight){const F=e.get(v);if(F.color.copy(v.color).multiplyScalar(v.intensity*U),v.castShadow){const H=v.shadow,L=n.get(v);L.shadowBias=H.bias,L.shadowNormalBias=H.normalBias,L.shadowRadius=H.radius,L.shadowMapSize=H.mapSize,r.directionalShadow[p]=L,r.directionalShadowMap[p]=G,r.directionalShadowMatrix[p]=v.shadow.matrix,R++}r.directional[p]=F,p++}else if(v.isSpotLight){const F=e.get(v);if(F.position.setFromMatrixPosition(v.matrixWorld),F.color.copy(C).multiplyScalar(it*U),F.distance=B,F.coneCos=Math.cos(v.angle),F.penumbraCos=Math.cos(v.angle*(1-v.penumbra)),F.decay=v.decay,v.castShadow){const H=v.shadow,L=n.get(v);L.shadowBias=H.bias,L.shadowNormalBias=H.normalBias,L.shadowRadius=H.radius,L.shadowMapSize=H.mapSize,r.spotShadow[y]=L,r.spotShadowMap[y]=G,r.spotShadowMatrix[y]=v.shadow.matrix,D++}r.spot[y]=F,y++}else if(v.isRectAreaLight){const F=e.get(v);F.color.copy(C).multiplyScalar(it),F.halfWidth.set(v.width*.5,0,0),F.halfHeight.set(0,v.height*.5,0),r.rectArea[M]=F,M++}else if(v.isPointLight){const F=e.get(v);if(F.color.copy(v.color).multiplyScalar(v.intensity*U),F.distance=v.distance,F.decay=v.decay,v.castShadow){const H=v.shadow,L=n.get(v);L.shadowBias=H.bias,L.shadowNormalBias=H.normalBias,L.shadowRadius=H.radius,L.shadowMapSize=H.mapSize,L.shadowCameraNear=H.camera.near,L.shadowCameraFar=H.camera.far,r.pointShadow[f]=L,r.pointShadowMap[f]=G,r.pointShadowMatrix[f]=v.shadow.matrix,b++}r.point[f]=F,f++}else if(v.isHemisphereLight){const F=e.get(v);F.skyColor.copy(v.color).multiplyScalar(it*U),F.groundColor.copy(v.groundColor).multiplyScalar(it*U),r.hemi[E]=F,E++}}M>0&&(t.isWebGL2||i.has("OES_texture_float_linear")===!0?(r.rectAreaLTC1=vt.LTC_FLOAT_1,r.rectAreaLTC2=vt.LTC_FLOAT_2):i.has("OES_texture_half_float_linear")===!0?(r.rectAreaLTC1=vt.LTC_HALF_1,r.rectAreaLTC2=vt.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),r.ambient[0]=d,r.ambient[1]=m,r.ambient[2]=g;const X=r.hash;(X.directionalLength!==p||X.pointLength!==f||X.spotLength!==y||X.rectAreaLength!==M||X.hemiLength!==E||X.numDirectionalShadows!==R||X.numPointShadows!==b||X.numSpotShadows!==D)&&(r.directional.length=p,r.spot.length=y,r.rectArea.length=M,r.point.length=f,r.hemi.length=E,r.directionalShadow.length=R,r.directionalShadowMap.length=R,r.pointShadow.length=b,r.pointShadowMap.length=b,r.spotShadow.length=D,r.spotShadowMap.length=D,r.directionalShadowMatrix.length=R,r.pointShadowMatrix.length=b,r.spotShadowMatrix.length=D,X.directionalLength=p,X.pointLength=f,X.spotLength=y,X.rectAreaLength=M,X.hemiLength=E,X.numDirectionalShadows=R,X.numPointShadows=b,X.numSpotShadows=D,r.version=vv++)}function c(u,h){let d=0,m=0,g=0,p=0,f=0;const y=h.matrixWorldInverse;for(let M=0,E=u.length;M<E;M++){const R=u[M];if(R.isDirectionalLight){const b=r.directional[d];b.direction.setFromMatrixPosition(R.matrixWorld),s.setFromMatrixPosition(R.target.matrixWorld),b.direction.sub(s),b.direction.transformDirection(y),d++}else if(R.isSpotLight){const b=r.spot[g];b.position.setFromMatrixPosition(R.matrixWorld),b.position.applyMatrix4(y),b.direction.setFromMatrixPosition(R.matrixWorld),s.setFromMatrixPosition(R.target.matrixWorld),b.direction.sub(s),b.direction.transformDirection(y),g++}else if(R.isRectAreaLight){const b=r.rectArea[p];b.position.setFromMatrixPosition(R.matrixWorld),b.position.applyMatrix4(y),o.identity(),a.copy(R.matrixWorld),a.premultiply(y),o.extractRotation(a),b.halfWidth.set(R.width*.5,0,0),b.halfHeight.set(0,R.height*.5,0),b.halfWidth.applyMatrix4(o),b.halfHeight.applyMatrix4(o),p++}else if(R.isPointLight){const b=r.point[m];b.position.setFromMatrixPosition(R.matrixWorld),b.position.applyMatrix4(y),m++}else if(R.isHemisphereLight){const b=r.hemi[f];b.direction.setFromMatrixPosition(R.matrixWorld),b.direction.transformDirection(y),b.direction.normalize(),f++}}}return{setup:l,setupView:c,state:r}}function fh(i,t){const e=new Tv(i,t),n=[],r=[];function s(){n.length=0,r.length=0}function a(h){n.push(h)}function o(h){r.push(h)}function l(h){e.setup(n,h)}function c(h){e.setupView(n,h)}return{init:s,state:{lightsArray:n,shadowsArray:r,lights:e},setupLights:l,setupLightsView:c,pushLight:a,pushShadow:o}}function Mv(i,t){let e=new WeakMap;function n(s,a=0){let o;return e.has(s)===!1?(o=new fh(i,t),e.set(s,[o])):a>=e.get(s).length?(o=new fh(i,t),e.get(s).push(o)):o=e.get(s)[a],o}function r(){e=new WeakMap}return{get:n,dispose:r}}class hc extends he{constructor(t){super();this.type="MeshDepthMaterial",this.depthPacking=Ey,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}hc.prototype.isMeshDepthMaterial=!0;class dc extends he{constructor(t){super();this.type="MeshDistanceMaterial",this.referencePosition=new k,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}dc.prototype.isMeshDistanceMaterial=!0;const wv=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,Iv=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function af(i,t,e){let n=new Qa;const r=new ct,s=new ct,a=new Kt,o=new hc({depthPacking:Wy}),l=new dc,c={},u=e.maxTextureSize,h={0:Ke,1:gr,2:Mi},d=new Le({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new ct},radius:{value:4}},vertexShader:wv,fragmentShader:Iv}),m=d.clone();m.defines.HORIZONTAL_PASS=1;const g=new te;g.setAttribute("position",new re(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const p=new pe(g,d),f=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=Dd,this.render=function(R,b,D){if(f.enabled===!1||f.autoUpdate===!1&&f.needsUpdate===!1||R.length===0)return;const U=i.getRenderTarget(),X=i.getActiveCubeFace(),dt=i.getActiveMipmapLevel(),K=i.state;K.setBlending(Yn),K.buffers.color.setClear(1,1,1,1),K.buffers.depth.setTest(!0),K.setScissorTest(!1);for(let v=0,C=R.length;v<C;v++){const it=R[v],B=it.shadow;if(B===void 0){console.warn("THREE.WebGLShadowMap:",it,"has no shadow.");continue}if(B.autoUpdate===!1&&B.needsUpdate===!1)continue;r.copy(B.mapSize);const G=B.getFrameExtents();if(r.multiply(G),s.copy(B.mapSize),(r.x>u||r.y>u)&&(r.x>u&&(s.x=Math.floor(u/G.x),r.x=s.x*G.x,B.mapSize.x=s.x),r.y>u&&(s.y=Math.floor(u/G.y),r.y=s.y*G.y,B.mapSize.y=s.y)),B.map===null&&!B.isPointLightShadow&&this.type===zr&&(B.map=new We(r.x,r.y),B.map.texture.name=it.name+".shadowMap",B.mapPass=new We(r.x,r.y),B.camera.updateProjectionMatrix()),B.map===null){const H={minFilter:ae,magFilter:ae,format:qe};B.map=new We(r.x,r.y,H),B.map.texture.name=it.name+".shadowMap",B.camera.updateProjectionMatrix()}i.setRenderTarget(B.map),i.clear();const F=B.getViewportCount();for(let H=0;H<F;H++){const L=B.getViewport(H);a.set(s.x*L.x,s.y*L.y,s.x*L.z,s.y*L.w),K.viewport(a),B.updateMatrices(it,H),n=B.getFrustum(),E(b,D,B.camera,it,this.type)}!B.isPointLightShadow&&this.type===zr&&y(B,D),B.needsUpdate=!1}f.needsUpdate=!1,i.setRenderTarget(U,X,dt)};function y(R,b){const D=t.update(p);d.defines.VSM_SAMPLES!==R.blurSamples&&(d.defines.VSM_SAMPLES=R.blurSamples,m.defines.VSM_SAMPLES=R.blurSamples,d.needsUpdate=!0,m.needsUpdate=!0),d.uniforms.shadow_pass.value=R.map.texture,d.uniforms.resolution.value=R.mapSize,d.uniforms.radius.value=R.radius,i.setRenderTarget(R.mapPass),i.clear(),i.renderBufferDirect(b,null,D,d,p,null),m.uniforms.shadow_pass.value=R.mapPass.texture,m.uniforms.resolution.value=R.mapSize,m.uniforms.radius.value=R.radius,i.setRenderTarget(R.map),i.clear(),i.renderBufferDirect(b,null,D,m,p,null)}function M(R,b,D,U,X,dt){let K=null;const v=D.isPointLight===!0?R.customDistanceMaterial:R.customDepthMaterial;if(v!==void 0?K=v:K=D.isPointLight===!0?l:o,i.localClippingEnabled&&b.clipShadows===!0&&b.clippingPlanes.length!==0||b.displacementMap&&b.displacementScale!==0||b.alphaMap&&b.alphaTest>0){const C=K.uuid,it=b.uuid;let B=c[C];B===void 0&&(B={},c[C]=B);let G=B[it];G===void 0&&(G=K.clone(),B[it]=G),K=G}return K.visible=b.visible,K.wireframe=b.wireframe,dt===zr?K.side=b.shadowSide!==null?b.shadowSide:b.side:K.side=b.shadowSide!==null?b.shadowSide:h[b.side],K.alphaMap=b.alphaMap,K.alphaTest=b.alphaTest,K.clipShadows=b.clipShadows,K.clippingPlanes=b.clippingPlanes,K.clipIntersection=b.clipIntersection,K.displacementMap=b.displacementMap,K.displacementScale=b.displacementScale,K.displacementBias=b.displacementBias,K.wireframeLinewidth=b.wireframeLinewidth,K.linewidth=b.linewidth,D.isPointLight===!0&&K.isMeshDistanceMaterial===!0&&(K.referencePosition.setFromMatrixPosition(D.matrixWorld),K.nearDistance=U,K.farDistance=X),K}function E(R,b,D,U,X){if(R.visible===!1)return;if(R.layers.test(b.layers)&&(R.isMesh||R.isLine||R.isPoints)&&(R.castShadow||R.receiveShadow&&X===zr)&&(!R.frustumCulled||n.intersectsObject(R))){R.modelViewMatrix.multiplyMatrices(D.matrixWorldInverse,R.matrixWorld);const v=t.update(R),C=R.material;if(Array.isArray(C)){const it=v.groups;for(let B=0,G=it.length;B<G;B++){const F=it[B],H=C[F.materialIndex];if(H&&H.visible){const L=M(R,H,U,D.near,D.far,X);i.renderBufferDirect(D,null,v,L,R,F)}}}else if(C.visible){const it=M(R,C,U,D.near,D.far,X);i.renderBufferDirect(D,null,v,it,R,null)}}const K=R.children;for(let v=0,C=K.length;v<C;v++)E(K[v],b,D,U,X)}}function kv(i,t,e){const n=e.isWebGL2;function r(){let W=!1;const pt=new Kt;let gt=null;const Tt=new Kt(0,0,0,0);return{setMask:function(yt){gt!==yt&&!W&&(i.colorMask(yt,yt,yt,yt),gt=yt)},setLocked:function(yt){W=yt},setClear:function(yt,wt,xt,Vt,$t){$t===!0&&(yt*=Vt,wt*=Vt,xt*=Vt),pt.set(yt,wt,xt,Vt),Tt.equals(pt)===!1&&(i.clearColor(yt,wt,xt,Vt),Tt.copy(pt))},reset:function(){W=!1,gt=null,Tt.set(-1,0,0,0)}}}function s(){let W=!1,pt=null,gt=null,Tt=null;return{setTest:function(yt){yt?kt(2929):et(2929)},setMask:function(yt){pt!==yt&&!W&&(i.depthMask(yt),pt=yt)},setFunc:function(yt){if(gt!==yt){if(yt)switch(yt){case Qg:i.depthFunc(512);break;case _g:i.depthFunc(519);break;case Yg:i.depthFunc(513);break;case vl:i.depthFunc(515);break;case $g:i.depthFunc(514);break;case ty:i.depthFunc(518);break;case ey:i.depthFunc(516);break;case ny:i.depthFunc(517);break;default:i.depthFunc(515)}else i.depthFunc(515);gt=yt}},setLocked:function(yt){W=yt},setClear:function(yt){Tt!==yt&&(i.clearDepth(yt),Tt=yt)},reset:function(){W=!1,pt=null,gt=null,Tt=null}}}function a(){let W=!1,pt=null,gt=null,Tt=null,yt=null,wt=null,xt=null,Vt=null,$t=null;return{setTest:function(qt){W||(qt?kt(2960):et(2960))},setMask:function(qt){pt!==qt&&!W&&(i.stencilMask(qt),pt=qt)},setFunc:function(qt,an,on){(gt!==qt||Tt!==an||yt!==on)&&(i.stencilFunc(qt,an,on),gt=qt,Tt=an,yt=on)},setOp:function(qt,an,on){(wt!==qt||xt!==an||Vt!==on)&&(i.stencilOp(qt,an,on),wt=qt,xt=an,Vt=on)},setLocked:function(qt){W=qt},setClear:function(qt){$t!==qt&&(i.clearStencil(qt),$t=qt)},reset:function(){W=!1,pt=null,gt=null,Tt=null,yt=null,wt=null,xt=null,Vt=null,$t=null}}}const o=new r,l=new s,c=new a;let u={},h={},d=new WeakMap,m=[],g=null,p=!1,f=null,y=null,M=null,E=null,R=null,b=null,D=null,U=!1,X=null,dt=null,K=null,v=null,C=null;const it=i.getParameter(35661);let B=!1,G=0;const F=i.getParameter(7938);F.indexOf("WebGL")!==-1?(G=parseFloat(/^WebGL (\d)/.exec(F)[1]),B=G>=1):F.indexOf("OpenGL ES")!==-1&&(G=parseFloat(/^OpenGL ES (\d)/.exec(F)[1]),B=G>=2);let H=null,L={};const z=i.getParameter(3088),lt=i.getParameter(2978),ut=new Kt().fromArray(z),ht=new Kt().fromArray(lt);function At(W,pt,gt){const Tt=new Uint8Array(4),yt=i.createTexture();i.bindTexture(W,yt),i.texParameteri(W,10241,9728),i.texParameteri(W,10240,9728);for(let wt=0;wt<gt;wt++)i.texImage2D(pt+wt,0,6408,1,1,0,6408,5121,Tt);return yt}const Lt={};Lt[3553]=At(3553,3553,1),Lt[34067]=At(34067,34069,6),o.setClear(0,0,0,1),l.setClear(1),c.setClear(0),kt(2929),l.setFunc(vl),w(!1),V(ru),kt(2884),$(Yn);function kt(W){u[W]!==!0&&(i.enable(W),u[W]=!0)}function et(W){u[W]!==!1&&(i.disable(W),u[W]=!1)}function Nt(W,pt){return h[W]!==pt?(i.bindFramebuffer(W,pt),h[W]=pt,n&&(W===36009&&(h[36160]=pt),W===36160&&(h[36009]=pt)),!0):!1}function Rt(W,pt){let gt=m,Tt=!1;if(W)if(gt=d.get(pt),gt===void 0&&(gt=[],d.set(pt,gt)),W.isWebGLMultipleRenderTargets){const yt=W.texture;if(gt.length!==yt.length||gt[0]!==36064){for(let wt=0,xt=yt.length;wt<xt;wt++)gt[wt]=36064+wt;gt.length=yt.length,Tt=!0}}else gt[0]!==36064&&(gt[0]=36064,Tt=!0);else gt[0]!==1029&&(gt[0]=1029,Tt=!0);Tt&&(e.isWebGL2?i.drawBuffers(gt):t.get("WEBGL_draw_buffers").drawBuffersWEBGL(gt))}function Et(W){return g!==W?(i.useProgram(W),g=W,!0):!1}const ft={[tr]:32774,[Bg]:32778,[Hg]:32779};if(n)ft[lu]=32775,ft[cu]=32776;else{const W=t.get("EXT_blend_minmax");W!==null&&(ft[lu]=W.MIN_EXT,ft[cu]=W.MAX_EXT)}const Ct={[qg]:0,[Jg]:1,[Og]:768,[Bd]:770,[zg]:776,[Kg]:774,[jg]:772,[Gg]:769,[Hd]:771,[Zg]:775,[Xg]:773};function $(W,pt,gt,Tt,yt,wt,xt,Vt){if(W===Yn){p===!0&&(et(3042),p=!1);return}if(p===!1&&(kt(3042),p=!0),W!==Fg){if(W!==f||Vt!==U){if((y!==tr||R!==tr)&&(i.blendEquation(32774),y=tr,R=tr),Vt)switch(W){case hr:i.blendFuncSeparate(1,771,1,771);break;case su:i.blendFunc(1,1);break;case au:i.blendFuncSeparate(0,769,0,1);break;case ou:i.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",W);break}else switch(W){case hr:i.blendFuncSeparate(770,771,1,771);break;case su:i.blendFunc(770,1);break;case au:i.blendFuncSeparate(0,769,0,1);break;case ou:i.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",W);break}M=null,E=null,b=null,D=null,f=W,U=Vt}return}yt=yt||pt,wt=wt||gt,xt=xt||Tt,(pt!==y||yt!==R)&&(i.blendEquationSeparate(ft[pt],ft[yt]),y=pt,R=yt),(gt!==M||Tt!==E||wt!==b||xt!==D)&&(i.blendFuncSeparate(Ct[gt],Ct[Tt],Ct[wt],Ct[xt]),M=gt,E=Tt,b=wt,D=xt),f=W,U=null}function x(W,pt){W.side===Mi?et(2884):kt(2884);let gt=W.side===Ke;pt&&(gt=!gt),w(gt),W.blending===hr&&W.transparent===!1?$(Yn):$(W.blending,W.blendEquation,W.blendSrc,W.blendDst,W.blendEquationAlpha,W.blendSrcAlpha,W.blendDstAlpha,W.premultipliedAlpha),l.setFunc(W.depthFunc),l.setTest(W.depthTest),l.setMask(W.depthWrite),o.setMask(W.colorWrite);const Tt=W.stencilWrite;c.setTest(Tt),Tt&&(c.setMask(W.stencilWriteMask),c.setFunc(W.stencilFunc,W.stencilRef,W.stencilFuncMask),c.setOp(W.stencilFail,W.stencilZFail,W.stencilZPass)),O(W.polygonOffset,W.polygonOffsetFactor,W.polygonOffsetUnits),W.alphaToCoverage===!0?kt(32926):et(32926)}function w(W){X!==W&&(W?i.frontFace(2304):i.frontFace(2305),X=W)}function V(W){W!==Ug?(kt(2884),W!==dt&&(W===ru?i.cullFace(1029):W===Pg?i.cullFace(1028):i.cullFace(1032))):et(2884),dt=W}function P(W){W!==K&&(B&&i.lineWidth(W),K=W)}function O(W,pt,gt){W?(kt(32823),(v!==pt||C!==gt)&&(i.polygonOffset(pt,gt),v=pt,C=gt)):et(32823)}function Z(W){W?kt(3089):et(3089)}function Y(W){W===void 0&&(W=33984+it-1),H!==W&&(i.activeTexture(W),H=W)}function rt(W,pt){H===null&&Y();let gt=L[H];gt===void 0&&(gt={type:void 0,texture:void 0},L[H]=gt),(gt.type!==W||gt.texture!==pt)&&(i.bindTexture(W,pt||Lt[W]),gt.type=W,gt.texture=pt)}function st(){const W=L[H];W!==void 0&&W.type!==void 0&&(i.bindTexture(W.type,null),W.type=void 0,W.texture=void 0)}function S(){try{i.compressedTexImage2D.apply(i,arguments)}catch(W){console.error("THREE.WebGLState:",W)}}function A(){try{i.texSubImage2D.apply(i,arguments)}catch(W){console.error("THREE.WebGLState:",W)}}function N(){try{i.texSubImage3D.apply(i,arguments)}catch(W){console.error("THREE.WebGLState:",W)}}function q(){try{i.compressedTexSubImage2D.apply(i,arguments)}catch(W){console.error("THREE.WebGLState:",W)}}function tt(){try{i.texStorage2D.apply(i,arguments)}catch(W){console.error("THREE.WebGLState:",W)}}function ot(){try{i.texStorage3D.apply(i,arguments)}catch(W){console.error("THREE.WebGLState:",W)}}function St(){try{i.texImage2D.apply(i,arguments)}catch(W){console.error("THREE.WebGLState:",W)}}function T(){try{i.texImage3D.apply(i,arguments)}catch(W){console.error("THREE.WebGLState:",W)}}function nt(W){ut.equals(W)===!1&&(i.scissor(W.x,W.y,W.z,W.w),ut.copy(W))}function bt(W){ht.equals(W)===!1&&(i.viewport(W.x,W.y,W.z,W.w),ht.copy(W))}function mt(){i.disable(3042),i.disable(2884),i.disable(2929),i.disable(32823),i.disable(3089),i.disable(2960),i.disable(32926),i.blendEquation(32774),i.blendFunc(1,0),i.blendFuncSeparate(1,0,1,0),i.colorMask(!0,!0,!0,!0),i.clearColor(0,0,0,0),i.depthMask(!0),i.depthFunc(513),i.clearDepth(1),i.stencilMask(4294967295),i.stencilFunc(519,0,4294967295),i.stencilOp(7680,7680,7680),i.clearStencil(0),i.cullFace(1029),i.frontFace(2305),i.polygonOffset(0,0),i.activeTexture(33984),i.bindFramebuffer(36160,null),n===!0&&(i.bindFramebuffer(36009,null),i.bindFramebuffer(36008,null)),i.useProgram(null),i.lineWidth(1),i.scissor(0,0,i.canvas.width,i.canvas.height),i.viewport(0,0,i.canvas.width,i.canvas.height),u={},H=null,L={},h={},d=new WeakMap,m=[],g=null,p=!1,f=null,y=null,M=null,E=null,R=null,b=null,D=null,U=!1,X=null,dt=null,K=null,v=null,C=null,ut.set(0,0,i.canvas.width,i.canvas.height),ht.set(0,0,i.canvas.width,i.canvas.height),o.reset(),l.reset(),c.reset()}return{buffers:{color:o,depth:l,stencil:c},enable:kt,disable:et,bindFramebuffer:Nt,drawBuffers:Rt,useProgram:Et,setBlending:$,setMaterial:x,setFlipSided:w,setCullFace:V,setLineWidth:P,setPolygonOffset:O,setScissorTest:Z,activeTexture:Y,bindTexture:rt,unbindTexture:st,compressedTexImage2D:S,texImage2D:St,texImage3D:T,texStorage2D:tt,texStorage3D:ot,texSubImage2D:A,texSubImage3D:N,compressedTexSubImage2D:q,scissor:nt,viewport:bt,reset:mt}}function Rv(i,t,e,n,r,s,a){const o=r.isWebGL2,l=r.maxTextures,c=r.maxCubemapSize,u=r.maxTextureSize,h=r.maxSamples,d=t.has("WEBGL_multisampled_render_to_texture")?t.get("WEBGL_multisampled_render_to_texture"):null,m=/OculusBrowser/g.test(navigator.userAgent),g=new WeakMap;let p;const f=new WeakMap;let y=!1;try{y=typeof OffscreenCanvas!="undefined"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function M(S,A){return y?new OffscreenCanvas(S,A):ys("canvas")}function E(S,A,N,q){let tt=1;if((S.width>q||S.height>q)&&(tt=q/Math.max(S.width,S.height)),tt<1||A===!0)if(typeof HTMLImageElement!="undefined"&&S instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&S instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&S instanceof ImageBitmap){const ot=A?Ca:Math.floor,St=ot(tt*S.width),T=ot(tt*S.height);p===void 0&&(p=M(St,T));const nt=N?M(St,T):p;return nt.width=St,nt.height=T,nt.getContext("2d").drawImage(S,0,0,St,T),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+S.width+"x"+S.height+") to ("+St+"x"+T+")."),nt}else return"data"in S&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+S.width+"x"+S.height+")."),S;return S}function R(S){return Il(S.width)&&Il(S.height)}function b(S){return o?!1:S.wrapS!==He||S.wrapT!==He||S.minFilter!==ae&&S.minFilter!==Pe}function D(S,A){return S.generateMipmaps&&A&&S.minFilter!==ae&&S.minFilter!==Pe}function U(S){i.generateMipmap(S)}function X(S,A,N,q,tt=!1){if(o===!1)return A;if(S!==null){if(i[S]!==void 0)return i[S];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+S+"'")}let ot=A;return A===6403&&(N===5126&&(ot=33326),N===5131&&(ot=33325),N===5121&&(ot=33321)),A===33319&&(N===5126&&(ot=33328),N===5131&&(ot=33327),N===5121&&(ot=33323)),A===6408&&(N===5126&&(ot=34836),N===5131&&(ot=34842),N===5121&&(ot=q===ee&&tt===!1?35907:32856),N===32819&&(ot=32854),N===32820&&(ot=32855)),(ot===33325||ot===33326||ot===33327||ot===33328||ot===34842||ot===34836)&&t.get("EXT_color_buffer_float"),ot}function dt(S,A,N){return D(S,N)===!0||S.isFramebufferTexture&&S.minFilter!==ae&&S.minFilter!==Pe?Math.log2(Math.max(A.width,A.height))+1:S.mipmaps!==void 0&&S.mipmaps.length>0?S.mipmaps.length:S.isCompressedTexture&&Array.isArray(S.image)?A.mipmaps.length:1}function K(S){return S===ae||S===uu||S===hu?9728:9729}function v(S){const A=S.target;A.removeEventListener("dispose",v),it(A),A.isVideoTexture&&g.delete(A)}function C(S){const A=S.target;A.removeEventListener("dispose",C),G(A)}function it(S){const A=n.get(S);if(A.__webglInit===void 0)return;const N=S.source,q=f.get(N);if(q){const tt=q[A.__cacheKey];tt.usedTimes--,tt.usedTimes===0&&B(S),Object.keys(q).length===0&&f.delete(N)}n.remove(S)}function B(S){const A=n.get(S);i.deleteTexture(A.__webglTexture);const N=S.source,q=f.get(N);delete q[A.__cacheKey],a.memory.textures--}function G(S){const A=S.texture,N=n.get(S),q=n.get(A);if(q.__webglTexture!==void 0&&(i.deleteTexture(q.__webglTexture),a.memory.textures--),S.depthTexture&&S.depthTexture.dispose(),S.isWebGLCubeRenderTarget)for(let tt=0;tt<6;tt++)i.deleteFramebuffer(N.__webglFramebuffer[tt]),N.__webglDepthbuffer&&i.deleteRenderbuffer(N.__webglDepthbuffer[tt]);else i.deleteFramebuffer(N.__webglFramebuffer),N.__webglDepthbuffer&&i.deleteRenderbuffer(N.__webglDepthbuffer),N.__webglMultisampledFramebuffer&&i.deleteFramebuffer(N.__webglMultisampledFramebuffer),N.__webglColorRenderbuffer&&i.deleteRenderbuffer(N.__webglColorRenderbuffer),N.__webglDepthRenderbuffer&&i.deleteRenderbuffer(N.__webglDepthRenderbuffer);if(S.isWebGLMultipleRenderTargets)for(let tt=0,ot=A.length;tt<ot;tt++){const St=n.get(A[tt]);St.__webglTexture&&(i.deleteTexture(St.__webglTexture),a.memory.textures--),n.remove(A[tt])}n.remove(A),n.remove(S)}let F=0;function H(){F=0}function L(){const S=F;return S>=l&&console.warn("THREE.WebGLTextures: Trying to use "+S+" texture units while this GPU supports only "+l),F+=1,S}function z(S){const A=[];return A.push(S.wrapS),A.push(S.wrapT),A.push(S.magFilter),A.push(S.minFilter),A.push(S.anisotropy),A.push(S.internalFormat),A.push(S.format),A.push(S.type),A.push(S.generateMipmaps),A.push(S.premultiplyAlpha),A.push(S.flipY),A.push(S.unpackAlignment),A.push(S.encoding),A.join()}function lt(S,A){const N=n.get(S);if(S.isVideoTexture&&rt(S),S.isRenderTargetTexture===!1&&S.version>0&&N.__version!==S.version){const q=S.image;if(q===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(q.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{Rt(N,S,A);return}}e.activeTexture(33984+A),e.bindTexture(3553,N.__webglTexture)}function ut(S,A){const N=n.get(S);if(S.version>0&&N.__version!==S.version){Rt(N,S,A);return}e.activeTexture(33984+A),e.bindTexture(35866,N.__webglTexture)}function ht(S,A){const N=n.get(S);if(S.version>0&&N.__version!==S.version){Rt(N,S,A);return}e.activeTexture(33984+A),e.bindTexture(32879,N.__webglTexture)}function At(S,A){const N=n.get(S);if(S.version>0&&N.__version!==S.version){Et(N,S,A);return}e.activeTexture(33984+A),e.bindTexture(34067,N.__webglTexture)}const Lt={[zn]:10497,[He]:33071,[Ml]:33648},kt={[ae]:9728,[uu]:9984,[hu]:9986,[Pe]:9729,[cy]:9985,[ja]:9987};function et(S,A,N){if(N?(i.texParameteri(S,10242,Lt[A.wrapS]),i.texParameteri(S,10243,Lt[A.wrapT]),(S===32879||S===35866)&&i.texParameteri(S,32882,Lt[A.wrapR]),i.texParameteri(S,10240,kt[A.magFilter]),i.texParameteri(S,10241,kt[A.minFilter])):(i.texParameteri(S,10242,33071),i.texParameteri(S,10243,33071),(S===32879||S===35866)&&i.texParameteri(S,32882,33071),(A.wrapS!==He||A.wrapT!==He)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),i.texParameteri(S,10240,K(A.magFilter)),i.texParameteri(S,10241,K(A.minFilter)),A.minFilter!==ae&&A.minFilter!==Pe&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),t.has("EXT_texture_filter_anisotropic")===!0){const q=t.get("EXT_texture_filter_anisotropic");if(A.type===Cn&&t.has("OES_texture_float_linear")===!1||o===!1&&A.type===vi&&t.has("OES_texture_half_float_linear")===!1)return;(A.anisotropy>1||n.get(A).__currentAnisotropy)&&(i.texParameterf(S,q.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(A.anisotropy,r.getMaxAnisotropy())),n.get(A).__currentAnisotropy=A.anisotropy)}}function Nt(S,A){let N=!1;S.__webglInit===void 0&&(S.__webglInit=!0,A.addEventListener("dispose",v));const q=A.source;let tt=f.get(q);tt===void 0&&(tt={},f.set(q,tt));const ot=z(A);if(ot!==S.__cacheKey){tt[ot]===void 0&&(tt[ot]={texture:i.createTexture(),usedTimes:0},a.memory.textures++,N=!0),tt[ot].usedTimes++;const St=tt[S.__cacheKey];St!==void 0&&(tt[S.__cacheKey].usedTimes--,St.usedTimes===0&&B(A)),S.__cacheKey=ot,S.__webglTexture=tt[ot].texture}return N}function Rt(S,A,N){let q=3553;A.isDataArrayTexture&&(q=35866),A.isData3DTexture&&(q=32879);const tt=Nt(S,A),ot=A.source;if(e.activeTexture(33984+N),e.bindTexture(q,S.__webglTexture),ot.version!==ot.__currentVersion||tt===!0){i.pixelStorei(37440,A.flipY),i.pixelStorei(37441,A.premultiplyAlpha),i.pixelStorei(3317,A.unpackAlignment),i.pixelStorei(37443,0);const St=b(A)&&R(A.image)===!1;let T=E(A.image,St,!1,u);T=st(A,T);const nt=R(T)||o,bt=s.convert(A.format,A.encoding);let mt=s.convert(A.type),W=X(A.internalFormat,bt,mt,A.encoding,A.isVideoTexture);et(q,A,nt);let pt;const gt=A.mipmaps,Tt=o&&A.isVideoTexture!==!0,yt=S.__version===void 0,wt=dt(A,T,nt);if(A.isDepthTexture)W=6402,o?A.type===Cn?W=36012:A.type===ya?W=33190:A.type===dr?W=35056:W=33189:A.type===Cn&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),A.format===bi&&W===6402&&A.type!==ps&&A.type!==ya&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),A.type=ps,mt=s.convert(A.type)),A.format===Sr&&W===6402&&(W=34041,A.type!==dr&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),A.type=dr,mt=s.convert(A.type))),Tt&&yt?e.texStorage2D(3553,1,W,T.width,T.height):e.texImage2D(3553,0,W,T.width,T.height,0,bt,mt,null);else if(A.isDataTexture)if(gt.length>0&&nt){Tt&&yt&&e.texStorage2D(3553,wt,W,gt[0].width,gt[0].height);for(let xt=0,Vt=gt.length;xt<Vt;xt++)pt=gt[xt],Tt?e.texSubImage2D(3553,xt,0,0,pt.width,pt.height,bt,mt,pt.data):e.texImage2D(3553,xt,W,pt.width,pt.height,0,bt,mt,pt.data);A.generateMipmaps=!1}else Tt?(yt&&e.texStorage2D(3553,wt,W,T.width,T.height),e.texSubImage2D(3553,0,0,0,T.width,T.height,bt,mt,T.data)):e.texImage2D(3553,0,W,T.width,T.height,0,bt,mt,T.data);else if(A.isCompressedTexture){Tt&&yt&&e.texStorage2D(3553,wt,W,gt[0].width,gt[0].height);for(let xt=0,Vt=gt.length;xt<Vt;xt++)pt=gt[xt],A.format!==qe?bt!==null?Tt?e.compressedTexSubImage2D(3553,xt,0,0,pt.width,pt.height,bt,pt.data):e.compressedTexImage2D(3553,xt,W,pt.width,pt.height,0,pt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Tt?e.texSubImage2D(3553,xt,0,0,pt.width,pt.height,bt,mt,pt.data):e.texImage2D(3553,xt,W,pt.width,pt.height,0,bt,mt,pt.data)}else if(A.isDataArrayTexture)Tt?(yt&&e.texStorage3D(35866,wt,W,T.width,T.height,T.depth),e.texSubImage3D(35866,0,0,0,0,T.width,T.height,T.depth,bt,mt,T.data)):e.texImage3D(35866,0,W,T.width,T.height,T.depth,0,bt,mt,T.data);else if(A.isData3DTexture)Tt?(yt&&e.texStorage3D(32879,wt,W,T.width,T.height,T.depth),e.texSubImage3D(32879,0,0,0,0,T.width,T.height,T.depth,bt,mt,T.data)):e.texImage3D(32879,0,W,T.width,T.height,T.depth,0,bt,mt,T.data);else if(A.isFramebufferTexture)Tt&&yt?e.texStorage2D(3553,wt,W,T.width,T.height):e.texImage2D(3553,0,W,T.width,T.height,0,bt,mt,null);else if(gt.length>0&&nt){Tt&&yt&&e.texStorage2D(3553,wt,W,gt[0].width,gt[0].height);for(let xt=0,Vt=gt.length;xt<Vt;xt++)pt=gt[xt],Tt?e.texSubImage2D(3553,xt,0,0,bt,mt,pt):e.texImage2D(3553,xt,W,bt,mt,pt);A.generateMipmaps=!1}else Tt?(yt&&e.texStorage2D(3553,wt,W,T.width,T.height),e.texSubImage2D(3553,0,0,0,bt,mt,T)):e.texImage2D(3553,0,W,bt,mt,T);D(A,nt)&&U(q),ot.__currentVersion=ot.version,A.onUpdate&&A.onUpdate(A)}S.__version=A.version}function Et(S,A,N){if(A.image.length!==6)return;const q=Nt(S,A),tt=A.source;if(e.activeTexture(33984+N),e.bindTexture(34067,S.__webglTexture),tt.version!==tt.__currentVersion||q===!0){i.pixelStorei(37440,A.flipY),i.pixelStorei(37441,A.premultiplyAlpha),i.pixelStorei(3317,A.unpackAlignment),i.pixelStorei(37443,0);const ot=A.isCompressedTexture||A.image[0].isCompressedTexture,St=A.image[0]&&A.image[0].isDataTexture,T=[];for(let xt=0;xt<6;xt++)!ot&&!St?T[xt]=E(A.image[xt],!1,!0,c):T[xt]=St?A.image[xt].image:A.image[xt],T[xt]=st(A,T[xt]);const nt=T[0],bt=R(nt)||o,mt=s.convert(A.format,A.encoding),W=s.convert(A.type),pt=X(A.internalFormat,mt,W,A.encoding),gt=o&&A.isVideoTexture!==!0,Tt=S.__version===void 0;let yt=dt(A,nt,bt);et(34067,A,bt);let wt;if(ot){gt&&Tt&&e.texStorage2D(34067,yt,pt,nt.width,nt.height);for(let xt=0;xt<6;xt++){wt=T[xt].mipmaps;for(let Vt=0;Vt<wt.length;Vt++){const $t=wt[Vt];A.format!==qe?mt!==null?gt?e.compressedTexSubImage2D(34069+xt,Vt,0,0,$t.width,$t.height,mt,$t.data):e.compressedTexImage2D(34069+xt,Vt,pt,$t.width,$t.height,0,$t.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):gt?e.texSubImage2D(34069+xt,Vt,0,0,$t.width,$t.height,mt,W,$t.data):e.texImage2D(34069+xt,Vt,pt,$t.width,$t.height,0,mt,W,$t.data)}}}else{wt=A.mipmaps,gt&&Tt&&(wt.length>0&&yt++,e.texStorage2D(34067,yt,pt,T[0].width,T[0].height));for(let xt=0;xt<6;xt++)if(St){gt?e.texSubImage2D(34069+xt,0,0,0,T[xt].width,T[xt].height,mt,W,T[xt].data):e.texImage2D(34069+xt,0,pt,T[xt].width,T[xt].height,0,mt,W,T[xt].data);for(let Vt=0;Vt<wt.length;Vt++){const qt=wt[Vt].image[xt].image;gt?e.texSubImage2D(34069+xt,Vt+1,0,0,qt.width,qt.height,mt,W,qt.data):e.texImage2D(34069+xt,Vt+1,pt,qt.width,qt.height,0,mt,W,qt.data)}}else{gt?e.texSubImage2D(34069+xt,0,0,0,mt,W,T[xt]):e.texImage2D(34069+xt,0,pt,mt,W,T[xt]);for(let Vt=0;Vt<wt.length;Vt++){const $t=wt[Vt];gt?e.texSubImage2D(34069+xt,Vt+1,0,0,mt,W,$t.image[xt]):e.texImage2D(34069+xt,Vt+1,pt,mt,W,$t.image[xt])}}}D(A,bt)&&U(34067),tt.__currentVersion=tt.version,A.onUpdate&&A.onUpdate(A)}S.__version=A.version}function ft(S,A,N,q,tt){const ot=s.convert(N.format,N.encoding),St=s.convert(N.type),T=X(N.internalFormat,ot,St,N.encoding);n.get(A).__hasExternalTextures||(tt===32879||tt===35866?e.texImage3D(tt,0,T,A.width,A.height,A.depth,0,ot,St,null):e.texImage2D(tt,0,T,A.width,A.height,0,ot,St,null)),e.bindFramebuffer(36160,S),Y(A)?d.framebufferTexture2DMultisampleEXT(36160,q,tt,n.get(N).__webglTexture,0,Z(A)):i.framebufferTexture2D(36160,q,tt,n.get(N).__webglTexture,0),e.bindFramebuffer(36160,null)}function Ct(S,A,N){if(i.bindRenderbuffer(36161,S),A.depthBuffer&&!A.stencilBuffer){let q=33189;if(N||Y(A)){const tt=A.depthTexture;tt&&tt.isDepthTexture&&(tt.type===Cn?q=36012:tt.type===ya&&(q=33190));const ot=Z(A);Y(A)?d.renderbufferStorageMultisampleEXT(36161,ot,q,A.width,A.height):i.renderbufferStorageMultisample(36161,ot,q,A.width,A.height)}else i.renderbufferStorage(36161,q,A.width,A.height);i.framebufferRenderbuffer(36160,36096,36161,S)}else if(A.depthBuffer&&A.stencilBuffer){const q=Z(A);N&&Y(A)===!1?i.renderbufferStorageMultisample(36161,q,35056,A.width,A.height):Y(A)?d.renderbufferStorageMultisampleEXT(36161,q,35056,A.width,A.height):i.renderbufferStorage(36161,34041,A.width,A.height),i.framebufferRenderbuffer(36160,33306,36161,S)}else{const q=A.isWebGLMultipleRenderTargets===!0?A.texture[0]:A.texture,tt=s.convert(q.format,q.encoding),ot=s.convert(q.type),St=X(q.internalFormat,tt,ot,q.encoding),T=Z(A);N&&Y(A)===!1?i.renderbufferStorageMultisample(36161,T,St,A.width,A.height):Y(A)?d.renderbufferStorageMultisampleEXT(36161,T,St,A.width,A.height):i.renderbufferStorage(36161,St,A.width,A.height)}i.bindRenderbuffer(36161,null)}function $(S,A){if(A&&A.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(36160,S),!(A.depthTexture&&A.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!n.get(A.depthTexture).__webglTexture||A.depthTexture.image.width!==A.width||A.depthTexture.image.height!==A.height)&&(A.depthTexture.image.width=A.width,A.depthTexture.image.height=A.height,A.depthTexture.needsUpdate=!0),lt(A.depthTexture,0);const q=n.get(A.depthTexture).__webglTexture,tt=Z(A);if(A.depthTexture.format===bi)Y(A)?d.framebufferTexture2DMultisampleEXT(36160,36096,3553,q,0,tt):i.framebufferTexture2D(36160,36096,3553,q,0);else if(A.depthTexture.format===Sr)Y(A)?d.framebufferTexture2DMultisampleEXT(36160,33306,3553,q,0,tt):i.framebufferTexture2D(36160,33306,3553,q,0);else throw new Error("Unknown depthTexture format")}function x(S){const A=n.get(S),N=S.isWebGLCubeRenderTarget===!0;if(S.depthTexture&&!A.__autoAllocateDepthBuffer){if(N)throw new Error("target.depthTexture not supported in Cube render targets");$(A.__webglFramebuffer,S)}else if(N){A.__webglDepthbuffer=[];for(let q=0;q<6;q++)e.bindFramebuffer(36160,A.__webglFramebuffer[q]),A.__webglDepthbuffer[q]=i.createRenderbuffer(),Ct(A.__webglDepthbuffer[q],S,!1)}else e.bindFramebuffer(36160,A.__webglFramebuffer),A.__webglDepthbuffer=i.createRenderbuffer(),Ct(A.__webglDepthbuffer,S,!1);e.bindFramebuffer(36160,null)}function w(S,A,N){const q=n.get(S);A!==void 0&&ft(q.__webglFramebuffer,S,S.texture,36064,3553),N!==void 0&&x(S)}function V(S){const A=S.texture,N=n.get(S),q=n.get(A);S.addEventListener("dispose",C),S.isWebGLMultipleRenderTargets!==!0&&(q.__webglTexture===void 0&&(q.__webglTexture=i.createTexture()),q.__version=A.version,a.memory.textures++);const tt=S.isWebGLCubeRenderTarget===!0,ot=S.isWebGLMultipleRenderTargets===!0,St=R(S)||o;if(tt){N.__webglFramebuffer=[];for(let T=0;T<6;T++)N.__webglFramebuffer[T]=i.createFramebuffer()}else if(N.__webglFramebuffer=i.createFramebuffer(),ot)if(r.drawBuffers){const T=S.texture;for(let nt=0,bt=T.length;nt<bt;nt++){const mt=n.get(T[nt]);mt.__webglTexture===void 0&&(mt.__webglTexture=i.createTexture(),a.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(o&&S.samples>0&&Y(S)===!1){N.__webglMultisampledFramebuffer=i.createFramebuffer(),N.__webglColorRenderbuffer=i.createRenderbuffer(),i.bindRenderbuffer(36161,N.__webglColorRenderbuffer);const T=s.convert(A.format,A.encoding),nt=s.convert(A.type),bt=X(A.internalFormat,T,nt,A.encoding),mt=Z(S);i.renderbufferStorageMultisample(36161,mt,bt,S.width,S.height),e.bindFramebuffer(36160,N.__webglMultisampledFramebuffer),i.framebufferRenderbuffer(36160,36064,36161,N.__webglColorRenderbuffer),i.bindRenderbuffer(36161,null),S.depthBuffer&&(N.__webglDepthRenderbuffer=i.createRenderbuffer(),Ct(N.__webglDepthRenderbuffer,S,!0)),e.bindFramebuffer(36160,null)}if(tt){e.bindTexture(34067,q.__webglTexture),et(34067,A,St);for(let T=0;T<6;T++)ft(N.__webglFramebuffer[T],S,A,36064,34069+T);D(A,St)&&U(34067),e.unbindTexture()}else if(ot){const T=S.texture;for(let nt=0,bt=T.length;nt<bt;nt++){const mt=T[nt],W=n.get(mt);e.bindTexture(3553,W.__webglTexture),et(3553,mt,St),ft(N.__webglFramebuffer,S,mt,36064+nt,3553),D(mt,St)&&U(3553)}e.unbindTexture()}else{let T=3553;(S.isWebGL3DRenderTarget||S.isWebGLArrayRenderTarget)&&(o?T=S.isWebGL3DRenderTarget?32879:35866:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),e.bindTexture(T,q.__webglTexture),et(T,A,St),ft(N.__webglFramebuffer,S,A,36064,T),D(A,St)&&U(T),e.unbindTexture()}S.depthBuffer&&x(S)}function P(S){const A=R(S)||o,N=S.isWebGLMultipleRenderTargets===!0?S.texture:[S.texture];for(let q=0,tt=N.length;q<tt;q++){const ot=N[q];if(D(ot,A)){const St=S.isWebGLCubeRenderTarget?34067:3553,T=n.get(ot).__webglTexture;e.bindTexture(St,T),U(St),e.unbindTexture()}}}function O(S){if(o&&S.samples>0&&Y(S)===!1){const A=S.width,N=S.height;let q=16384;const tt=[36064],ot=S.stencilBuffer?33306:36096;S.depthBuffer&&tt.push(ot);const St=n.get(S),T=St.__ignoreDepthValues!==void 0?St.__ignoreDepthValues:!1;T===!1&&(S.depthBuffer&&(q|=256),S.stencilBuffer&&(q|=1024)),e.bindFramebuffer(36008,St.__webglMultisampledFramebuffer),e.bindFramebuffer(36009,St.__webglFramebuffer),T===!0&&(i.invalidateFramebuffer(36008,[ot]),i.invalidateFramebuffer(36009,[ot])),i.blitFramebuffer(0,0,A,N,0,0,A,N,q,9728),m&&i.invalidateFramebuffer(36008,tt),e.bindFramebuffer(36008,null),e.bindFramebuffer(36009,St.__webglMultisampledFramebuffer)}}function Z(S){return Math.min(h,S.samples)}function Y(S){const A=n.get(S);return o&&S.samples>0&&t.has("WEBGL_multisampled_render_to_texture")===!0&&A.__useRenderToTexture!==!1}function rt(S){const A=a.render.frame;g.get(S)!==A&&(g.set(S,A),S.update())}function st(S,A){const N=S.encoding,q=S.format,tt=S.type;return S.isCompressedTexture===!0||S.isVideoTexture===!0||S.format===wl||N!==Vn&&(N===ee?o===!1?t.has("EXT_sRGB")===!0&&q===qe?(S.format=wl,S.minFilter=Pe,S.generateMipmaps=!1):A=Ii.sRGBToLinear(A):(q!==qe||tt!==wi)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",N)),A}this.allocateTextureUnit=L,this.resetTextureUnits=H,this.setTexture2D=lt,this.setTexture2DArray=ut,this.setTexture3D=ht,this.setTextureCube=At,this.rebindTextures=w,this.setupRenderTarget=V,this.updateRenderTargetMipmap=P,this.updateMultisampleRenderTarget=O,this.setupDepthRenderbuffer=x,this.setupFrameBufferTexture=ft,this.useMultisampledRTT=Y}function Ev(i,t,e){const n=e.isWebGL2;function r(s,a=null){let o;if(s===wi)return 5121;if(s===fy)return 32819;if(s===py)return 32820;if(s===uy)return 5120;if(s===hy)return 5122;if(s===ps)return 5123;if(s===dy)return 5124;if(s===ya)return 5125;if(s===Cn)return 5126;if(s===vi)return n?5131:(o=t.get("OES_texture_half_float"),o!==null?o.HALF_FLOAT_OES:null);if(s===my)return 6406;if(s===qe)return 6408;if(s===yy)return 6409;if(s===Ay)return 6410;if(s===bi)return 6402;if(s===Sr)return 34041;if(s===Sy)return 6403;if(s===gy)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),6408;if(s===wl)return o=t.get("EXT_sRGB"),o!==null?o.SRGB_ALPHA_EXT:null;if(s===xy)return 36244;if(s===vy)return 33319;if(s===by)return 33320;if(s===Ty)return 36249;if(s===go||s===yo||s===Ao||s===So)if(a===ee)if(o=t.get("WEBGL_compressed_texture_s3tc_srgb"),o!==null){if(s===go)return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(s===yo)return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(s===Ao)return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(s===So)return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(o=t.get("WEBGL_compressed_texture_s3tc"),o!==null){if(s===go)return o.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===yo)return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===Ao)return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===So)return o.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(s===du||s===fu||s===pu||s===mu)if(o=t.get("WEBGL_compressed_texture_pvrtc"),o!==null){if(s===du)return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===fu)return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===pu)return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===mu)return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(s===My)return o=t.get("WEBGL_compressed_texture_etc1"),o!==null?o.COMPRESSED_RGB_ETC1_WEBGL:null;if(s===gu||s===yu)if(o=t.get("WEBGL_compressed_texture_etc"),o!==null){if(s===gu)return a===ee?o.COMPRESSED_SRGB8_ETC2:o.COMPRESSED_RGB8_ETC2;if(s===yu)return a===ee?o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:o.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(s===Au||s===Su||s===xu||s===vu||s===bu||s===Tu||s===Mu||s===wu||s===Iu||s===ku||s===Ru||s===Eu||s===Wu||s===Cu)if(o=t.get("WEBGL_compressed_texture_astc"),o!==null){if(s===Au)return a===ee?o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:o.COMPRESSED_RGBA_ASTC_4x4_KHR;if(s===Su)return a===ee?o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:o.COMPRESSED_RGBA_ASTC_5x4_KHR;if(s===xu)return a===ee?o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:o.COMPRESSED_RGBA_ASTC_5x5_KHR;if(s===vu)return a===ee?o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:o.COMPRESSED_RGBA_ASTC_6x5_KHR;if(s===bu)return a===ee?o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:o.COMPRESSED_RGBA_ASTC_6x6_KHR;if(s===Tu)return a===ee?o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:o.COMPRESSED_RGBA_ASTC_8x5_KHR;if(s===Mu)return a===ee?o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:o.COMPRESSED_RGBA_ASTC_8x6_KHR;if(s===wu)return a===ee?o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:o.COMPRESSED_RGBA_ASTC_8x8_KHR;if(s===Iu)return a===ee?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:o.COMPRESSED_RGBA_ASTC_10x5_KHR;if(s===ku)return a===ee?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:o.COMPRESSED_RGBA_ASTC_10x6_KHR;if(s===Ru)return a===ee?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:o.COMPRESSED_RGBA_ASTC_10x8_KHR;if(s===Eu)return a===ee?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:o.COMPRESSED_RGBA_ASTC_10x10_KHR;if(s===Wu)return a===ee?o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:o.COMPRESSED_RGBA_ASTC_12x10_KHR;if(s===Cu)return a===ee?o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:o.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(s===Lu)if(o=t.get("EXT_texture_compression_bptc"),o!==null){if(s===Lu)return a===ee?o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:o.COMPRESSED_RGBA_BPTC_UNORM_EXT}else return null;if(s===dr)return n?34042:(o=t.get("WEBGL_depth_texture"),o!==null?o.UNSIGNED_INT_24_8_WEBGL:null)}return{convert:r}}class of extends Te{constructor(t=[]){super();this.cameras=t}}of.prototype.isArrayCamera=!0;class _r extends Qt{constructor(){super();this.type="Group"}}_r.prototype.isGroup=!0;const Wv={type:"move"};class Ko{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new _r,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new _r,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new k,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new k),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new _r,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new k,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new k),this._grip}dispatchEvent(t){return this._targetRay!==null&&this._targetRay.dispatchEvent(t),this._grip!==null&&this._grip.dispatchEvent(t),this._hand!==null&&this._hand.dispatchEvent(t),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(t,e,n){let r=null,s=null,a=null;const o=this._targetRay,l=this._grip,c=this._hand;if(t&&e.session.visibilityState!=="visible-blurred")if(o!==null&&(r=e.getPose(t.targetRaySpace,n),r!==null&&(o.matrix.fromArray(r.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),r.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(r.linearVelocity)):o.hasLinearVelocity=!1,r.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(r.angularVelocity)):o.hasAngularVelocity=!1,this.dispatchEvent(Wv))),c&&t.hand){a=!0;for(const p of t.hand.values()){const f=e.getJointPose(p,n);if(c.joints[p.jointName]===void 0){const M=new _r;M.matrixAutoUpdate=!1,M.visible=!1,c.joints[p.jointName]=M,c.add(M)}const y=c.joints[p.jointName];f!==null&&(y.matrix.fromArray(f.transform.matrix),y.matrix.decompose(y.position,y.rotation,y.scale),y.jointRadius=f.radius),y.visible=f!==null}const u=c.joints["index-finger-tip"],h=c.joints["thumb-tip"],d=u.position.distanceTo(h.position),m=.02,g=.005;c.inputState.pinching&&d>m+g?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!c.inputState.pinching&&d<=m-g&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else l!==null&&t.gripSpace&&(s=e.getPose(t.gripSpace,n),s!==null&&(l.matrix.fromArray(s.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),s.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(s.linearVelocity)):l.hasLinearVelocity=!1,s.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(s.angularVelocity)):l.hasAngularVelocity=!1));return o!==null&&(o.visible=r!==null),l!==null&&(l.visible=s!==null),c!==null&&(c.visible=a!==null),this}}class lf extends ge{constructor(t,e,n,r,s,a,o,l,c,u){if(u=u!==void 0?u:bi,u!==bi&&u!==Sr)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&u===bi&&(n=ps),n===void 0&&u===Sr&&(n=dr);super(null,r,s,a,o,l,u,n,c);this.image={width:t,height:e},this.magFilter=o!==void 0?o:ae,this.minFilter=l!==void 0?l:ae,this.flipY=!1,this.generateMipmaps=!1}}lf.prototype.isDepthTexture=!0;class Cv extends ri{constructor(t,e){super();const n=this;let r=null,s=1,a=null,o="local-floor",l=null,c=null,u=null,h=null,d=null;const m=e.getContextAttributes();let g=null,p=null;const f=[],y=new Map,M=new Te;M.layers.enable(1),M.viewport=new Kt;const E=new Te;E.layers.enable(2),E.viewport=new Kt;const R=[M,E],b=new of;b.layers.enable(1),b.layers.enable(2);let D=null,U=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(L){let z=f[L];return z===void 0&&(z=new Ko,f[L]=z),z.getTargetRaySpace()},this.getControllerGrip=function(L){let z=f[L];return z===void 0&&(z=new Ko,f[L]=z),z.getGripSpace()},this.getHand=function(L){let z=f[L];return z===void 0&&(z=new Ko,f[L]=z),z.getHandSpace()};function X(L){const z=y.get(L.inputSource);z&&z.dispatchEvent({type:L.type,data:L.inputSource})}function dt(){y.forEach(function(L,z){L.disconnect(z)}),y.clear(),D=null,U=null,t.setRenderTarget(g),h=null,u=null,c=null,r=null,p=null,H.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(L){s=L,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(L){o=L,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return a},this.getBaseLayer=function(){return u!==null?u:h},this.getBinding=function(){return c},this.getFrame=function(){return d},this.getSession=function(){return r},this.setSession=async function(L){if(r=L,r!==null){if(g=t.getRenderTarget(),r.addEventListener("select",X),r.addEventListener("selectstart",X),r.addEventListener("selectend",X),r.addEventListener("squeeze",X),r.addEventListener("squeezestart",X),r.addEventListener("squeezeend",X),r.addEventListener("end",dt),r.addEventListener("inputsourceschange",K),m.xrCompatible!==!0&&await e.makeXRCompatible(),r.renderState.layers===void 0||t.capabilities.isWebGL2===!1){const z={antialias:r.renderState.layers===void 0?m.antialias:!0,alpha:m.alpha,depth:m.depth,stencil:m.stencil,framebufferScaleFactor:s};h=new XRWebGLLayer(r,e,z),r.updateRenderState({baseLayer:h}),p=new We(h.framebufferWidth,h.framebufferHeight,{format:qe,type:wi,encoding:t.outputEncoding})}else{let z=null,lt=null,ut=null;m.depth&&(ut=m.stencil?35056:33190,z=m.stencil?Sr:bi,lt=m.stencil?dr:ps);const ht={colorFormat:t.outputEncoding===ee?35907:32856,depthFormat:ut,scaleFactor:s};c=new XRWebGLBinding(r,e),u=c.createProjectionLayer(ht),r.updateRenderState({layers:[u]}),p=new We(u.textureWidth,u.textureHeight,{format:qe,type:wi,depthTexture:new lf(u.textureWidth,u.textureHeight,lt,void 0,void 0,void 0,void 0,void 0,void 0,z),stencilBuffer:m.stencil,encoding:t.outputEncoding,samples:m.antialias?4:0});const At=t.properties.get(p);At.__ignoreDepthValues=u.ignoreDepthValues}p.isXRRenderTarget=!0,this.setFoveation(1),a=await r.requestReferenceSpace(o),H.setContext(r),H.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};function K(L){const z=r.inputSources;for(let lt=0;lt<f.length;lt++)y.set(z[lt],f[lt]);for(let lt=0;lt<L.removed.length;lt++){const ut=L.removed[lt],ht=y.get(ut);ht&&(ht.dispatchEvent({type:"disconnected",data:ut}),y.delete(ut))}for(let lt=0;lt<L.added.length;lt++){const ut=L.added[lt],ht=y.get(ut);ht&&ht.dispatchEvent({type:"connected",data:ut})}}const v=new k,C=new k;function it(L,z,lt){v.setFromMatrixPosition(z.matrixWorld),C.setFromMatrixPosition(lt.matrixWorld);const ut=v.distanceTo(C),ht=z.projectionMatrix.elements,At=lt.projectionMatrix.elements,Lt=ht[14]/(ht[10]-1),kt=ht[14]/(ht[10]+1),et=(ht[9]+1)/ht[5],Nt=(ht[9]-1)/ht[5],Rt=(ht[8]-1)/ht[0],Et=(At[8]+1)/At[0],ft=Lt*Rt,Ct=Lt*Et,$=ut/(-Rt+Et),x=$*-Rt;z.matrixWorld.decompose(L.position,L.quaternion,L.scale),L.translateX(x),L.translateZ($),L.matrixWorld.compose(L.position,L.quaternion,L.scale),L.matrixWorldInverse.copy(L.matrixWorld).invert();const w=Lt+$,V=kt+$,P=ft-x,O=Ct+(ut-x),Z=et*kt/V*w,Y=Nt*kt/V*w;L.projectionMatrix.makePerspective(P,O,Z,Y,w,V)}function B(L,z){z===null?L.matrixWorld.copy(L.matrix):L.matrixWorld.multiplyMatrices(z.matrixWorld,L.matrix),L.matrixWorldInverse.copy(L.matrixWorld).invert()}this.updateCamera=function(L){if(r===null)return;b.near=E.near=M.near=L.near,b.far=E.far=M.far=L.far,(D!==b.near||U!==b.far)&&(r.updateRenderState({depthNear:b.near,depthFar:b.far}),D=b.near,U=b.far);const z=L.parent,lt=b.cameras;B(b,z);for(let ht=0;ht<lt.length;ht++)B(lt[ht],z);b.matrixWorld.decompose(b.position,b.quaternion,b.scale),L.position.copy(b.position),L.quaternion.copy(b.quaternion),L.scale.copy(b.scale),L.matrix.copy(b.matrix),L.matrixWorld.copy(b.matrixWorld);const ut=L.children;for(let ht=0,At=ut.length;ht<At;ht++)ut[ht].updateMatrixWorld(!0);lt.length===2?it(b,M,E):b.projectionMatrix.copy(M.projectionMatrix)},this.getCamera=function(){return b},this.getFoveation=function(){if(u!==null)return u.fixedFoveation;if(h!==null)return h.fixedFoveation},this.setFoveation=function(L){u!==null&&(u.fixedFoveation=L),h!==null&&h.fixedFoveation!==void 0&&(h.fixedFoveation=L)};let G=null;function F(L,z){if(l=z.getViewerPose(a),d=z,l!==null){const ut=l.views;h!==null&&(t.setRenderTargetFramebuffer(p,h.framebuffer),t.setRenderTarget(p));let ht=!1;ut.length!==b.cameras.length&&(b.cameras.length=0,ht=!0);for(let At=0;At<ut.length;At++){const Lt=ut[At];let kt=null;if(h!==null)kt=h.getViewport(Lt);else{const Nt=c.getViewSubImage(u,Lt);kt=Nt.viewport,At===0&&(t.setRenderTargetTextures(p,Nt.colorTexture,u.ignoreDepthValues?void 0:Nt.depthStencilTexture),t.setRenderTarget(p))}const et=R[At];et.matrix.fromArray(Lt.transform.matrix),et.projectionMatrix.fromArray(Lt.projectionMatrix),et.viewport.set(kt.x,kt.y,kt.width,kt.height),At===0&&b.matrix.copy(et.matrix),ht===!0&&b.cameras.push(et)}}const lt=r.inputSources;for(let ut=0;ut<f.length;ut++){const ht=f[ut],At=lt[ut];ht.update(At,z,a)}G&&G(L,z),d=null}const H=new _d;H.setAnimationLoop(F),this.setAnimationLoop=function(L){G=L},this.dispose=function(){}}}function Lv(i,t){function e(p,f){p.fogColor.value.copy(f.color),f.isFog?(p.fogNear.value=f.near,p.fogFar.value=f.far):f.isFogExp2&&(p.fogDensity.value=f.density)}function n(p,f,y,M,E){f.isMeshBasicMaterial||f.isMeshLambertMaterial?r(p,f):f.isMeshToonMaterial?(r(p,f),u(p,f)):f.isMeshPhongMaterial?(r(p,f),c(p,f)):f.isMeshStandardMaterial?(r(p,f),h(p,f),f.isMeshPhysicalMaterial&&d(p,f,E)):f.isMeshMatcapMaterial?(r(p,f),m(p,f)):f.isMeshDepthMaterial?r(p,f):f.isMeshDistanceMaterial?(r(p,f),g(p,f)):f.isMeshNormalMaterial?r(p,f):f.isLineBasicMaterial?(s(p,f),f.isLineDashedMaterial&&a(p,f)):f.isPointsMaterial?o(p,f,y,M):f.isSpriteMaterial?l(p,f):f.isShadowMaterial?(p.color.value.copy(f.color),p.opacity.value=f.opacity):f.isShaderMaterial&&(f.uniformsNeedUpdate=!1)}function r(p,f){p.opacity.value=f.opacity,f.color&&p.diffuse.value.copy(f.color),f.emissive&&p.emissive.value.copy(f.emissive).multiplyScalar(f.emissiveIntensity),f.map&&(p.map.value=f.map),f.alphaMap&&(p.alphaMap.value=f.alphaMap),f.bumpMap&&(p.bumpMap.value=f.bumpMap,p.bumpScale.value=f.bumpScale,f.side===Ke&&(p.bumpScale.value*=-1)),f.displacementMap&&(p.displacementMap.value=f.displacementMap,p.displacementScale.value=f.displacementScale,p.displacementBias.value=f.displacementBias),f.emissiveMap&&(p.emissiveMap.value=f.emissiveMap),f.normalMap&&(p.normalMap.value=f.normalMap,p.normalScale.value.copy(f.normalScale),f.side===Ke&&p.normalScale.value.negate()),f.specularMap&&(p.specularMap.value=f.specularMap),f.alphaTest>0&&(p.alphaTest.value=f.alphaTest);const y=t.get(f).envMap;if(y&&(p.envMap.value=y,p.flipEnvMap.value=y.isCubeTexture&&y.isRenderTargetTexture===!1?-1:1,p.reflectivity.value=f.reflectivity,p.ior.value=f.ior,p.refractionRatio.value=f.refractionRatio),f.lightMap){p.lightMap.value=f.lightMap;const R=i.physicallyCorrectLights!==!0?Math.PI:1;p.lightMapIntensity.value=f.lightMapIntensity*R}f.aoMap&&(p.aoMap.value=f.aoMap,p.aoMapIntensity.value=f.aoMapIntensity);let M;f.map?M=f.map:f.specularMap?M=f.specularMap:f.displacementMap?M=f.displacementMap:f.normalMap?M=f.normalMap:f.bumpMap?M=f.bumpMap:f.roughnessMap?M=f.roughnessMap:f.metalnessMap?M=f.metalnessMap:f.alphaMap?M=f.alphaMap:f.emissiveMap?M=f.emissiveMap:f.clearcoatMap?M=f.clearcoatMap:f.clearcoatNormalMap?M=f.clearcoatNormalMap:f.clearcoatRoughnessMap?M=f.clearcoatRoughnessMap:f.specularIntensityMap?M=f.specularIntensityMap:f.specularColorMap?M=f.specularColorMap:f.transmissionMap?M=f.transmissionMap:f.thicknessMap?M=f.thicknessMap:f.sheenColorMap?M=f.sheenColorMap:f.sheenRoughnessMap&&(M=f.sheenRoughnessMap),M!==void 0&&(M.isWebGLRenderTarget&&(M=M.texture),M.matrixAutoUpdate===!0&&M.updateMatrix(),p.uvTransform.value.copy(M.matrix));let E;f.aoMap?E=f.aoMap:f.lightMap&&(E=f.lightMap),E!==void 0&&(E.isWebGLRenderTarget&&(E=E.texture),E.matrixAutoUpdate===!0&&E.updateMatrix(),p.uv2Transform.value.copy(E.matrix))}function s(p,f){p.diffuse.value.copy(f.color),p.opacity.value=f.opacity}function a(p,f){p.dashSize.value=f.dashSize,p.totalSize.value=f.dashSize+f.gapSize,p.scale.value=f.scale}function o(p,f,y,M){p.diffuse.value.copy(f.color),p.opacity.value=f.opacity,p.size.value=f.size*y,p.scale.value=M*.5,f.map&&(p.map.value=f.map),f.alphaMap&&(p.alphaMap.value=f.alphaMap),f.alphaTest>0&&(p.alphaTest.value=f.alphaTest);let E;f.map?E=f.map:f.alphaMap&&(E=f.alphaMap),E!==void 0&&(E.matrixAutoUpdate===!0&&E.updateMatrix(),p.uvTransform.value.copy(E.matrix))}function l(p,f){p.diffuse.value.copy(f.color),p.opacity.value=f.opacity,p.rotation.value=f.rotation,f.map&&(p.map.value=f.map),f.alphaMap&&(p.alphaMap.value=f.alphaMap),f.alphaTest>0&&(p.alphaTest.value=f.alphaTest);let y;f.map?y=f.map:f.alphaMap&&(y=f.alphaMap),y!==void 0&&(y.matrixAutoUpdate===!0&&y.updateMatrix(),p.uvTransform.value.copy(y.matrix))}function c(p,f){p.specular.value.copy(f.specular),p.shininess.value=Math.max(f.shininess,1e-4)}function u(p,f){f.gradientMap&&(p.gradientMap.value=f.gradientMap)}function h(p,f){p.roughness.value=f.roughness,p.metalness.value=f.metalness,f.roughnessMap&&(p.roughnessMap.value=f.roughnessMap),f.metalnessMap&&(p.metalnessMap.value=f.metalnessMap),t.get(f).envMap&&(p.envMapIntensity.value=f.envMapIntensity)}function d(p,f,y){p.ior.value=f.ior,f.sheen>0&&(p.sheenColor.value.copy(f.sheenColor).multiplyScalar(f.sheen),p.sheenRoughness.value=f.sheenRoughness,f.sheenColorMap&&(p.sheenColorMap.value=f.sheenColorMap),f.sheenRoughnessMap&&(p.sheenRoughnessMap.value=f.sheenRoughnessMap)),f.clearcoat>0&&(p.clearcoat.value=f.clearcoat,p.clearcoatRoughness.value=f.clearcoatRoughness,f.clearcoatMap&&(p.clearcoatMap.value=f.clearcoatMap),f.clearcoatRoughnessMap&&(p.clearcoatRoughnessMap.value=f.clearcoatRoughnessMap),f.clearcoatNormalMap&&(p.clearcoatNormalScale.value.copy(f.clearcoatNormalScale),p.clearcoatNormalMap.value=f.clearcoatNormalMap,f.side===Ke&&p.clearcoatNormalScale.value.negate())),f.transmission>0&&(p.transmission.value=f.transmission,p.transmissionSamplerMap.value=y.texture,p.transmissionSamplerSize.value.set(y.width,y.height),f.transmissionMap&&(p.transmissionMap.value=f.transmissionMap),p.thickness.value=f.thickness,f.thicknessMap&&(p.thicknessMap.value=f.thicknessMap),p.attenuationDistance.value=f.attenuationDistance,p.attenuationColor.value.copy(f.attenuationColor)),p.specularIntensity.value=f.specularIntensity,p.specularColor.value.copy(f.specularColor),f.specularIntensityMap&&(p.specularIntensityMap.value=f.specularIntensityMap),f.specularColorMap&&(p.specularColorMap.value=f.specularColorMap)}function m(p,f){f.matcap&&(p.matcap.value=f.matcap)}function g(p,f){p.referencePosition.value.copy(f.referencePosition),p.nearDistance.value=f.nearDistance,p.farDistance.value=f.farDistance}return{refreshFogUniforms:e,refreshMaterialUniforms:n}}function Nv(){const i=ys("canvas");return i.style.display="block",i}function _t(i={}){const t=i.canvas!==void 0?i.canvas:Nv(),e=i.context!==void 0?i.context:null,n=i.depth!==void 0?i.depth:!0,r=i.stencil!==void 0?i.stencil:!0,s=i.antialias!==void 0?i.antialias:!1,a=i.premultipliedAlpha!==void 0?i.premultipliedAlpha:!0,o=i.preserveDrawingBuffer!==void 0?i.preserveDrawingBuffer:!1,l=i.powerPreference!==void 0?i.powerPreference:"default",c=i.failIfMajorPerformanceCaveat!==void 0?i.failIfMajorPerformanceCaveat:!1;let u;i.context!==void 0?u=e.getContextAttributes().alpha:u=i.alpha!==void 0?i.alpha:!1;let h=null,d=null;const m=[],g=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=Vn,this.physicallyCorrectLights=!1,this.toneMapping=Ln,this.toneMappingExposure=1;const p=this;let f=!1,y=0,M=0,E=null,R=-1,b=null;const D=new Kt,U=new Kt;let X=null,dt=t.width,K=t.height,v=1,C=null,it=null;const B=new Kt(0,0,dt,K),G=new Kt(0,0,dt,K);let F=!1;const H=new Qa;let L=!1,z=!1,lt=null;const ut=new It,ht=new ct,At=new k,Lt={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function kt(){return E===null?v:1}let et=e;function Nt(I,J){for(let Q=0;Q<I.length;Q++){const j=I[Q],at=t.getContext(j,J);if(at!==null)return at}return null}try{const I={alpha:!0,depth:n,stencil:r,antialias:s,premultipliedAlpha:a,preserveDrawingBuffer:o,powerPreference:l,failIfMajorPerformanceCaveat:c};if("setAttribute"in t&&t.setAttribute("data-engine",`three.js r${rc}`),t.addEventListener("webglcontextlost",W,!1),t.addEventListener("webglcontextrestored",pt,!1),et===null){const J=["webgl2","webgl","experimental-webgl"];if(p.isWebGL1Renderer===!0&&J.shift(),et=Nt(J,I),et===null)throw Nt(J)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}et.getShaderPrecisionFormat===void 0&&(et.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(I){throw console.error("THREE.WebGLRenderer: "+I.message),I}let Rt,Et,ft,Ct,$,x,w,V,P,O,Z,Y,rt,st,S,A,N,q,tt,ot,St,T,nt;function bt(){Rt=new _S(et),Et=new jS(et,Rt,i),Rt.init(Et),T=new Ev(et,Rt,Et),ft=new kv(et,Rt,Et),Ct=new tx(et),$=new gv,x=new Rv(et,Rt,ft,$,Et,T,Ct),w=new KS(p),V=new QS(p),P=new p0(et,Et),nt=new OS(et,Rt,P,Et),O=new YS(et,P,Ct,nt),Z=new rx(et,O,P,Ct),tt=new ix(et,Et,x),A=new XS($),Y=new mv(p,w,V,Rt,Et,nt,A),rt=new Lv(p,$),st=new Av,S=new Mv(Rt,Et),q=new JS(p,w,ft,Z,u,a),N=new af(p,Z,Et),ot=new GS(et,Rt,Ct,Et),St=new $S(et,Rt,Ct,Et),Ct.programs=Y.programs,p.capabilities=Et,p.extensions=Rt,p.properties=$,p.renderLists=st,p.shadowMap=N,p.state=ft,p.info=Ct}bt();const mt=new Cv(p,et);this.xr=mt,this.getContext=function(){return et},this.getContextAttributes=function(){return et.getContextAttributes()},this.forceContextLoss=function(){const I=Rt.get("WEBGL_lose_context");I&&I.loseContext()},this.forceContextRestore=function(){const I=Rt.get("WEBGL_lose_context");I&&I.restoreContext()},this.getPixelRatio=function(){return v},this.setPixelRatio=function(I){I!==void 0&&(v=I,this.setSize(dt,K,!1))},this.getSize=function(I){return I.set(dt,K)},this.setSize=function(I,J,Q){if(mt.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}dt=I,K=J,t.width=Math.floor(I*v),t.height=Math.floor(J*v),Q!==!1&&(t.style.width=I+"px",t.style.height=J+"px"),this.setViewport(0,0,I,J)},this.getDrawingBufferSize=function(I){return I.set(dt*v,K*v).floor()},this.setDrawingBufferSize=function(I,J,Q){dt=I,K=J,v=Q,t.width=Math.floor(I*Q),t.height=Math.floor(J*Q),this.setViewport(0,0,I,J)},this.getCurrentViewport=function(I){return I.copy(D)},this.getViewport=function(I){return I.copy(B)},this.setViewport=function(I,J,Q,j){I.isVector4?B.set(I.x,I.y,I.z,I.w):B.set(I,J,Q,j),ft.viewport(D.copy(B).multiplyScalar(v).floor())},this.getScissor=function(I){return I.copy(G)},this.setScissor=function(I,J,Q,j){I.isVector4?G.set(I.x,I.y,I.z,I.w):G.set(I,J,Q,j),ft.scissor(U.copy(G).multiplyScalar(v).floor())},this.getScissorTest=function(){return F},this.setScissorTest=function(I){ft.setScissorTest(F=I)},this.setOpaqueSort=function(I){C=I},this.setTransparentSort=function(I){it=I},this.getClearColor=function(I){return I.copy(q.getClearColor())},this.setClearColor=function(){q.setClearColor.apply(q,arguments)},this.getClearAlpha=function(){return q.getClearAlpha()},this.setClearAlpha=function(){q.setClearAlpha.apply(q,arguments)},this.clear=function(I=!0,J=!0,Q=!0){let j=0;I&&(j|=16384),J&&(j|=256),Q&&(j|=1024),et.clear(j)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",W,!1),t.removeEventListener("webglcontextrestored",pt,!1),st.dispose(),S.dispose(),$.dispose(),w.dispose(),V.dispose(),Z.dispose(),nt.dispose(),Y.dispose(),mt.dispose(),mt.removeEventListener("sessionstart",Vt),mt.removeEventListener("sessionend",$t),lt&&(lt.dispose(),lt=null),qt.stop()};function W(I){I.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),f=!0}function pt(){console.log("THREE.WebGLRenderer: Context Restored."),f=!1;const I=Ct.autoReset,J=N.enabled,Q=N.autoUpdate,j=N.needsUpdate,at=N.type;bt(),Ct.autoReset=I,N.enabled=J,N.autoUpdate=Q,N.needsUpdate=j,N.type=at}function gt(I){const J=I.target;J.removeEventListener("dispose",gt),Tt(J)}function Tt(I){yt(I),$.remove(I)}function yt(I){const J=$.get(I).programs;J!==void 0&&(J.forEach(function(Q){Y.releaseProgram(Q)}),I.isShaderMaterial&&Y.releaseShaderCache(I))}this.renderBufferDirect=function(I,J,Q,j,at,Wt){J===null&&(J=Lt);const Ut=at.isMesh&&at.matrixWorld.determinant()<0,Dt=Jf(I,J,Q,j,at);ft.setMaterial(j,Ut);let Pt=Q.index;const Zt=Q.attributes.position;if(Pt===null){if(Zt===void 0||Zt.count===0)return}else if(Pt.count===0)return;let Jt=1;j.wireframe===!0&&(Pt=O.getWireframeAttribute(Q),Jt=2),nt.setup(at,j,Dt,Q,Pt);let Ot,se=ot;Pt!==null&&(Ot=P.get(Pt),se=St,se.setIndex(Ot));const ai=Pt!==null?Pt.count:Zt.count,Ri=Q.drawRange.start*Jt,Ei=Q.drawRange.count*Jt,ln=Wt!==null?Wt.start*Jt:0,Xt=Wt!==null?Wt.count*Jt:1/0,Wi=Math.max(Ri,ln),oe=Math.min(ai,Ri+Ei,ln+Xt)-1,cn=Math.max(0,oe-Wi+1);if(cn!==0){if(at.isMesh)j.wireframe===!0?(ft.setLineWidth(j.wireframeLinewidth*kt()),se.setMode(1)):se.setMode(4);else if(at.isLine){let Pn=j.linewidth;Pn===void 0&&(Pn=1),ft.setLineWidth(Pn*kt()),at.isLineSegments?se.setMode(1):at.isLineLoop?se.setMode(2):se.setMode(3)}else at.isPoints?se.setMode(0):at.isSprite&&se.setMode(4);if(at.isInstancedMesh)se.renderInstances(Wi,cn,at.count);else if(Q.isInstancedBufferGeometry){const Pn=Math.min(Q.instanceCount,Q._maxInstanceCount);se.renderInstances(Wi,cn,Pn)}else se.render(Wi,cn)}},this.compile=function(I,J){d=S.get(I),d.init(),g.push(d),I.traverseVisible(function(Q){Q.isLight&&Q.layers.test(J.layers)&&(d.pushLight(Q),Q.castShadow&&d.pushShadow(Q))}),d.setupLights(p.physicallyCorrectLights),I.traverse(function(Q){const j=Q.material;if(j)if(Array.isArray(j))for(let at=0;at<j.length;at++){const Wt=j[at];no(Wt,I,Q)}else no(j,I,Q)}),g.pop(),d=null};let wt=null;function xt(I){wt&&wt(I)}function Vt(){qt.stop()}function $t(){qt.start()}const qt=new _d;qt.setAnimationLoop(xt),typeof self!="undefined"&&qt.setContext(self),this.setAnimationLoop=function(I){wt=I,mt.setAnimationLoop(I),I===null?qt.stop():qt.start()},mt.addEventListener("sessionstart",Vt),mt.addEventListener("sessionend",$t),this.render=function(I,J){if(J!==void 0&&J.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(f===!0)return;I.autoUpdate===!0&&I.updateMatrixWorld(),J.parent===null&&J.updateMatrixWorld(),mt.enabled===!0&&mt.isPresenting===!0&&(mt.cameraAutoUpdate===!0&&mt.updateCamera(J),J=mt.getCamera()),I.isScene===!0&&I.onBeforeRender(p,I,J,E),d=S.get(I,g.length),d.init(),g.push(d),ut.multiplyMatrices(J.projectionMatrix,J.matrixWorldInverse),H.setFromProjectionMatrix(ut),z=this.localClippingEnabled,L=A.init(this.clippingPlanes,z,J),h=st.get(I,m.length),h.init(),m.push(h),an(I,J,0,p.sortObjects),h.finish(),p.sortObjects===!0&&h.sort(C,it),L===!0&&A.beginShadows();const Q=d.state.shadowsArray;if(N.render(Q,I,J),L===!0&&A.endShadows(),this.info.autoReset===!0&&this.info.reset(),q.render(h,I),d.setupLights(p.physicallyCorrectLights),J.isArrayCamera){const j=J.cameras;for(let at=0,Wt=j.length;at<Wt;at++){const Ut=j[at];on(h,I,Ut,Ut.viewport)}}else on(h,I,J);E!==null&&(x.updateMultisampleRenderTarget(E),x.updateRenderTargetMipmap(E)),I.isScene===!0&&I.onAfterRender(p,I,J),nt.resetDefaultState(),R=-1,b=null,g.pop(),g.length>0?d=g[g.length-1]:d=null,m.pop(),m.length>0?h=m[m.length-1]:h=null};function an(I,J,Q,j){if(I.visible===!1)return;if(I.layers.test(J.layers)){if(I.isGroup)Q=I.renderOrder;else if(I.isLOD)I.autoUpdate===!0&&I.update(J);else if(I.isLight)d.pushLight(I),I.castShadow&&d.pushShadow(I);else if(I.isSprite){if(!I.frustumCulled||H.intersectsSprite(I)){j&&At.setFromMatrixPosition(I.matrixWorld).applyMatrix4(ut);const Ut=Z.update(I),Dt=I.material;Dt.visible&&h.push(I,Ut,Dt,Q,At.z,null)}}else if((I.isMesh||I.isLine||I.isPoints)&&(I.isSkinnedMesh&&I.skeleton.frame!==Ct.render.frame&&(I.skeleton.update(),I.skeleton.frame=Ct.render.frame),!I.frustumCulled||H.intersectsObject(I))){j&&At.setFromMatrixPosition(I.matrixWorld).applyMatrix4(ut);const Ut=Z.update(I),Dt=I.material;if(Array.isArray(Dt)){const Pt=Ut.groups;for(let Zt=0,Jt=Pt.length;Zt<Jt;Zt++){const Ot=Pt[Zt],se=Dt[Ot.materialIndex];se&&se.visible&&h.push(I,Ut,se,Q,At.z,Ot)}}else Dt.visible&&h.push(I,Ut,Dt,Q,At.z,null)}}const Wt=I.children;for(let Ut=0,Dt=Wt.length;Ut<Dt;Ut++)an(Wt[Ut],J,Q,j)}function on(I,J,Q,j){const at=I.opaque,Wt=I.transmissive,Ut=I.transparent;d.setupLightsView(Q),Wt.length>0&&Hf(at,J,Q),j&&ft.viewport(D.copy(j)),at.length>0&&Rs(at,J,Q),Wt.length>0&&Rs(Wt,J,Q),Ut.length>0&&Rs(Ut,J,Q),ft.buffers.depth.setTest(!0),ft.buffers.depth.setMask(!0),ft.buffers.color.setMask(!0),ft.setPolygonOffset(!1)}function Hf(I,J,Q){const j=Et.isWebGL2;lt===null&&(lt=new We(1,1,{generateMipmaps:!0,type:T.convert(vi)!==null?vi:wi,minFilter:ja,samples:j&&s===!0?4:0})),p.getDrawingBufferSize(ht),j?lt.setSize(ht.x,ht.y):lt.setSize(Ca(ht.x),Ca(ht.y));const at=p.getRenderTarget();p.setRenderTarget(lt),p.clear();const Wt=p.toneMapping;p.toneMapping=Ln,Rs(I,J,Q),p.toneMapping=Wt,x.updateMultisampleRenderTarget(lt),x.updateRenderTargetMipmap(lt),p.setRenderTarget(at)}function Rs(I,J,Q){const j=J.isScene===!0?J.overrideMaterial:null;for(let at=0,Wt=I.length;at<Wt;at++){const Ut=I[at],Dt=Ut.object,Pt=Ut.geometry,Zt=j===null?Ut.material:j,Jt=Ut.group;Dt.layers.test(Q.layers)&&qf(Dt,J,Q,Pt,Zt,Jt)}}function qf(I,J,Q,j,at,Wt){I.onBeforeRender(p,J,Q,j,at,Wt),I.modelViewMatrix.multiplyMatrices(Q.matrixWorldInverse,I.matrixWorld),I.normalMatrix.getNormalMatrix(I.modelViewMatrix),at.onBeforeRender(p,J,Q,j,I,Wt),at.transparent===!0&&at.side===Mi?(at.side=Ke,at.needsUpdate=!0,p.renderBufferDirect(Q,J,j,at,I,Wt),at.side=gr,at.needsUpdate=!0,p.renderBufferDirect(Q,J,j,at,I,Wt),at.side=Mi):p.renderBufferDirect(Q,J,j,at,I,Wt),I.onAfterRender(p,J,Q,j,at,Wt)}function no(I,J,Q){J.isScene!==!0&&(J=Lt);const j=$.get(I),at=d.state.lights,Wt=d.state.shadowsArray,Ut=at.state.version,Dt=Y.getParameters(I,at.state,Wt,J,Q),Pt=Y.getProgramCacheKey(Dt);let Zt=j.programs;j.environment=I.isMeshStandardMaterial?J.environment:null,j.fog=J.fog,j.envMap=(I.isMeshStandardMaterial?V:w).get(I.envMap||j.environment),Zt===void 0&&(I.addEventListener("dispose",gt),Zt=new Map,j.programs=Zt);let Jt=Zt.get(Pt);if(Jt!==void 0){if(j.currentProgram===Jt&&j.lightsStateVersion===Ut)return kc(I,Dt),Jt}else Dt.uniforms=Y.getUniforms(I),I.onBuild(Q,Dt,p),I.onBeforeCompile(Dt,p),Jt=Y.acquireProgram(Dt,Pt),Zt.set(Pt,Jt),j.uniforms=Dt.uniforms;const Ot=j.uniforms;(!I.isShaderMaterial&&!I.isRawShaderMaterial||I.clipping===!0)&&(Ot.clippingPlanes=A.uniform),kc(I,Dt),j.needsLights=Gf(I),j.lightsStateVersion=Ut,j.needsLights&&(Ot.ambientLightColor.value=at.state.ambient,Ot.lightProbe.value=at.state.probe,Ot.directionalLights.value=at.state.directional,Ot.directionalLightShadows.value=at.state.directionalShadow,Ot.spotLights.value=at.state.spot,Ot.spotLightShadows.value=at.state.spotShadow,Ot.rectAreaLights.value=at.state.rectArea,Ot.ltc_1.value=at.state.rectAreaLTC1,Ot.ltc_2.value=at.state.rectAreaLTC2,Ot.pointLights.value=at.state.point,Ot.pointLightShadows.value=at.state.pointShadow,Ot.hemisphereLights.value=at.state.hemi,Ot.directionalShadowMap.value=at.state.directionalShadowMap,Ot.directionalShadowMatrix.value=at.state.directionalShadowMatrix,Ot.spotShadowMap.value=at.state.spotShadowMap,Ot.spotShadowMatrix.value=at.state.spotShadowMatrix,Ot.pointShadowMap.value=at.state.pointShadowMap,Ot.pointShadowMatrix.value=at.state.pointShadowMatrix);const se=Jt.getUniforms(),ai=$n.seqWithValue(se.seq,Ot);return j.currentProgram=Jt,j.uniformsList=ai,Jt}function kc(I,J){const Q=$.get(I);Q.outputEncoding=J.outputEncoding,Q.instancing=J.instancing,Q.skinning=J.skinning,Q.morphTargets=J.morphTargets,Q.morphNormals=J.morphNormals,Q.morphColors=J.morphColors,Q.morphTargetsCount=J.morphTargetsCount,Q.numClippingPlanes=J.numClippingPlanes,Q.numIntersection=J.numClipIntersection,Q.vertexAlphas=J.vertexAlphas,Q.vertexTangents=J.vertexTangents,Q.toneMapping=J.toneMapping}function Jf(I,J,Q,j,at){J.isScene!==!0&&(J=Lt),x.resetTextureUnits();const Wt=J.fog,Ut=j.isMeshStandardMaterial?J.environment:null,Dt=E===null?p.outputEncoding:E.isXRRenderTarget===!0?E.texture.encoding:Vn,Pt=(j.isMeshStandardMaterial?V:w).get(j.envMap||Ut),Zt=j.vertexColors===!0&&!!Q.attributes.color&&Q.attributes.color.itemSize===4,Jt=!!j.normalMap&&!!Q.attributes.tangent,Ot=!!Q.morphAttributes.position,se=!!Q.morphAttributes.normal,ai=!!Q.morphAttributes.color,Ri=j.toneMapped?p.toneMapping:Ln,Ei=Q.morphAttributes.position||Q.morphAttributes.normal||Q.morphAttributes.color,ln=Ei!==void 0?Ei.length:0,Xt=$.get(j),Wi=d.state.lights;if(L===!0&&(z===!0||I!==b)){const ze=I===b&&j.id===R;A.setState(j,I,ze)}let oe=!1;j.version===Xt.__version?(Xt.needsLights&&Xt.lightsStateVersion!==Wi.state.version||Xt.outputEncoding!==Dt||at.isInstancedMesh&&Xt.instancing===!1||!at.isInstancedMesh&&Xt.instancing===!0||at.isSkinnedMesh&&Xt.skinning===!1||!at.isSkinnedMesh&&Xt.skinning===!0||Xt.envMap!==Pt||j.fog&&Xt.fog!==Wt||Xt.numClippingPlanes!==void 0&&(Xt.numClippingPlanes!==A.numPlanes||Xt.numIntersection!==A.numIntersection)||Xt.vertexAlphas!==Zt||Xt.vertexTangents!==Jt||Xt.morphTargets!==Ot||Xt.morphNormals!==se||Xt.morphColors!==ai||Xt.toneMapping!==Ri||Et.isWebGL2===!0&&Xt.morphTargetsCount!==ln)&&(oe=!0):(oe=!0,Xt.__version=j.version);let cn=Xt.currentProgram;oe===!0&&(cn=no(j,J,at));let Pn=!1,Vr=!1,io=!1;const ve=cn.getUniforms(),Ur=Xt.uniforms;if(ft.useProgram(cn.program)&&(Pn=!0,Vr=!0,io=!0),j.id!==R&&(R=j.id,Vr=!0),Pn||b!==I){if(ve.setValue(et,"projectionMatrix",I.projectionMatrix),Et.logarithmicDepthBuffer&&ve.setValue(et,"logDepthBufFC",2/(Math.log(I.far+1)/Math.LN2)),b!==I&&(b=I,Vr=!0,io=!0),j.isShaderMaterial||j.isMeshPhongMaterial||j.isMeshToonMaterial||j.isMeshStandardMaterial||j.envMap){const ze=ve.map.cameraPosition;ze!==void 0&&ze.setValue(et,At.setFromMatrixPosition(I.matrixWorld))}(j.isMeshPhongMaterial||j.isMeshToonMaterial||j.isMeshLambertMaterial||j.isMeshBasicMaterial||j.isMeshStandardMaterial||j.isShaderMaterial)&&ve.setValue(et,"isOrthographic",I.isOrthographicCamera===!0),(j.isMeshPhongMaterial||j.isMeshToonMaterial||j.isMeshLambertMaterial||j.isMeshBasicMaterial||j.isMeshStandardMaterial||j.isShaderMaterial||j.isShadowMaterial||at.isSkinnedMesh)&&ve.setValue(et,"viewMatrix",I.matrixWorldInverse)}if(at.isSkinnedMesh){ve.setOptional(et,at,"bindMatrix"),ve.setOptional(et,at,"bindMatrixInverse");const ze=at.skeleton;ze&&(Et.floatVertexTextures?(ze.boneTexture===null&&ze.computeBoneTexture(),ve.setValue(et,"boneTexture",ze.boneTexture,x),ve.setValue(et,"boneTextureSize",ze.boneTextureSize)):ve.setOptional(et,ze,"boneMatrices"))}const ro=Q.morphAttributes;return(ro.position!==void 0||ro.normal!==void 0||ro.color!==void 0&&Et.isWebGL2===!0)&&tt.update(at,Q,j,cn),(Vr||Xt.receiveShadow!==at.receiveShadow)&&(Xt.receiveShadow=at.receiveShadow,ve.setValue(et,"receiveShadow",at.receiveShadow)),Vr&&(ve.setValue(et,"toneMappingExposure",p.toneMappingExposure),Xt.needsLights&&Of(Ur,io),Wt&&j.fog&&rt.refreshFogUniforms(Ur,Wt),rt.refreshMaterialUniforms(Ur,j,v,K,lt),$n.upload(et,Xt.uniformsList,Ur,x)),j.isShaderMaterial&&j.uniformsNeedUpdate===!0&&($n.upload(et,Xt.uniformsList,Ur,x),j.uniformsNeedUpdate=!1),j.isSpriteMaterial&&ve.setValue(et,"center",at.center),ve.setValue(et,"modelViewMatrix",at.modelViewMatrix),ve.setValue(et,"normalMatrix",at.normalMatrix),ve.setValue(et,"modelMatrix",at.matrixWorld),cn}function Of(I,J){I.ambientLightColor.needsUpdate=J,I.lightProbe.needsUpdate=J,I.directionalLights.needsUpdate=J,I.directionalLightShadows.needsUpdate=J,I.pointLights.needsUpdate=J,I.pointLightShadows.needsUpdate=J,I.spotLights.needsUpdate=J,I.spotLightShadows.needsUpdate=J,I.rectAreaLights.needsUpdate=J,I.hemisphereLights.needsUpdate=J}function Gf(I){return I.isMeshLambertMaterial||I.isMeshToonMaterial||I.isMeshPhongMaterial||I.isMeshStandardMaterial||I.isShadowMaterial||I.isShaderMaterial&&I.lights===!0}this.getActiveCubeFace=function(){return y},this.getActiveMipmapLevel=function(){return M},this.getRenderTarget=function(){return E},this.setRenderTargetTextures=function(I,J,Q){$.get(I.texture).__webglTexture=J,$.get(I.depthTexture).__webglTexture=Q;const j=$.get(I);j.__hasExternalTextures=!0,j.__hasExternalTextures&&(j.__autoAllocateDepthBuffer=Q===void 0,j.__autoAllocateDepthBuffer||Rt.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),j.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(I,J){const Q=$.get(I);Q.__webglFramebuffer=J,Q.__useDefaultFramebuffer=J===void 0},this.setRenderTarget=function(I,J=0,Q=0){E=I,y=J,M=Q;let j=!0;if(I){const Pt=$.get(I);Pt.__useDefaultFramebuffer!==void 0?(ft.bindFramebuffer(36160,null),j=!1):Pt.__webglFramebuffer===void 0?x.setupRenderTarget(I):Pt.__hasExternalTextures&&x.rebindTextures(I,$.get(I.texture).__webglTexture,$.get(I.depthTexture).__webglTexture)}let at=null,Wt=!1,Ut=!1;if(I){const Pt=I.texture;(Pt.isData3DTexture||Pt.isDataArrayTexture)&&(Ut=!0);const Zt=$.get(I).__webglFramebuffer;I.isWebGLCubeRenderTarget?(at=Zt[J],Wt=!0):Et.isWebGL2&&I.samples>0&&x.useMultisampledRTT(I)===!1?at=$.get(I).__webglMultisampledFramebuffer:at=Zt,D.copy(I.viewport),U.copy(I.scissor),X=I.scissorTest}else D.copy(B).multiplyScalar(v).floor(),U.copy(G).multiplyScalar(v).floor(),X=F;if(ft.bindFramebuffer(36160,at)&&Et.drawBuffers&&j&&ft.drawBuffers(I,at),ft.viewport(D),ft.scissor(U),ft.setScissorTest(X),Wt){const Pt=$.get(I.texture);et.framebufferTexture2D(36160,36064,34069+J,Pt.__webglTexture,Q)}else if(Ut){const Pt=$.get(I.texture),Zt=J||0;et.framebufferTextureLayer(36160,36064,Pt.__webglTexture,Q||0,Zt)}R=-1},this.readRenderTargetPixels=function(I,J,Q,j,at,Wt,Ut){if(!(I&&I.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let Dt=$.get(I).__webglFramebuffer;if(I.isWebGLCubeRenderTarget&&Ut!==void 0&&(Dt=Dt[Ut]),Dt){ft.bindFramebuffer(36160,Dt);try{const Pt=I.texture,Zt=Pt.format,Jt=Pt.type;if(Zt!==qe&&T.convert(Zt)!==et.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const Ot=Jt===vi&&(Rt.has("EXT_color_buffer_half_float")||Et.isWebGL2&&Rt.has("EXT_color_buffer_float"));if(Jt!==wi&&T.convert(Jt)!==et.getParameter(35738)&&!(Jt===Cn&&(Et.isWebGL2||Rt.has("OES_texture_float")||Rt.has("WEBGL_color_buffer_float")))&&!Ot){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}J>=0&&J<=I.width-j&&Q>=0&&Q<=I.height-at&&et.readPixels(J,Q,j,at,T.convert(Zt),T.convert(Jt),Wt)}finally{const Pt=E!==null?$.get(E).__webglFramebuffer:null;ft.bindFramebuffer(36160,Pt)}}},this.copyFramebufferToTexture=function(I,J,Q=0){if(J.isFramebufferTexture!==!0){console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");return}const j=Math.pow(2,-Q),at=Math.floor(J.image.width*j),Wt=Math.floor(J.image.height*j);x.setTexture2D(J,0),et.copyTexSubImage2D(3553,Q,0,0,I.x,I.y,at,Wt),ft.unbindTexture()},this.copyTextureToTexture=function(I,J,Q,j=0){const at=J.image.width,Wt=J.image.height,Ut=T.convert(Q.format),Dt=T.convert(Q.type);x.setTexture2D(Q,0),et.pixelStorei(37440,Q.flipY),et.pixelStorei(37441,Q.premultiplyAlpha),et.pixelStorei(3317,Q.unpackAlignment),J.isDataTexture?et.texSubImage2D(3553,j,I.x,I.y,at,Wt,Ut,Dt,J.image.data):J.isCompressedTexture?et.compressedTexSubImage2D(3553,j,I.x,I.y,J.mipmaps[0].width,J.mipmaps[0].height,Ut,J.mipmaps[0].data):et.texSubImage2D(3553,j,I.x,I.y,Ut,Dt,J.image),j===0&&Q.generateMipmaps&&et.generateMipmap(3553),ft.unbindTexture()},this.copyTextureToTexture3D=function(I,J,Q,j,at=0){if(p.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const Wt=I.max.x-I.min.x+1,Ut=I.max.y-I.min.y+1,Dt=I.max.z-I.min.z+1,Pt=T.convert(j.format),Zt=T.convert(j.type);let Jt;if(j.isData3DTexture)x.setTexture3D(j,0),Jt=32879;else if(j.isDataArrayTexture)x.setTexture2DArray(j,0),Jt=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}et.pixelStorei(37440,j.flipY),et.pixelStorei(37441,j.premultiplyAlpha),et.pixelStorei(3317,j.unpackAlignment);const Ot=et.getParameter(3314),se=et.getParameter(32878),ai=et.getParameter(3316),Ri=et.getParameter(3315),Ei=et.getParameter(32877),ln=Q.isCompressedTexture?Q.mipmaps[0]:Q.image;et.pixelStorei(3314,ln.width),et.pixelStorei(32878,ln.height),et.pixelStorei(3316,I.min.x),et.pixelStorei(3315,I.min.y),et.pixelStorei(32877,I.min.z),Q.isDataTexture||Q.isData3DTexture?et.texSubImage3D(Jt,at,J.x,J.y,J.z,Wt,Ut,Dt,Pt,Zt,ln.data):Q.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),et.compressedTexSubImage3D(Jt,at,J.x,J.y,J.z,Wt,Ut,Dt,Pt,ln.data)):et.texSubImage3D(Jt,at,J.x,J.y,J.z,Wt,Ut,Dt,Pt,Zt,ln),et.pixelStorei(3314,Ot),et.pixelStorei(32878,se),et.pixelStorei(3316,ai),et.pixelStorei(3315,Ri),et.pixelStorei(32877,Ei),at===0&&j.generateMipmaps&&et.generateMipmap(Jt),ft.unbindTexture()},this.initTexture=function(I){x.setTexture2D(I,0),ft.unbindTexture()},this.resetState=function(){y=0,M=0,E=null,ft.reset(),nt.reset()},typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}_t.prototype.isWebGLRenderer=!0;class Vv extends _t{}Vv.prototype.isWebGL1Renderer=!0;class Ya extends Qt{constructor(){super();this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),t.background!==null&&(this.background=t.background.clone()),t.environment!==null&&(this.environment=t.environment.clone()),t.fog!==null&&(this.fog=t.fog.clone()),t.overrideMaterial!==null&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return this.fog!==null&&(e.object.fog=this.fog.toJSON()),e}}Ya.prototype.isScene=!0;class Ts{constructor(t,e){this.array=t,this.stride=e,this.count=t!==void 0?t.length/e:0,this.usage=ms,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=rn()}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,n){t*=this.stride,n*=e.stride;for(let r=0,s=this.stride;r<s;r++)this.array[t+r]=e.array[n+r];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=rn()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(e,this.stride);return n.setUsage(this.usage),n}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=rn()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}Ts.prototype.isInterleavedBuffer=!0;const Re=new k;class As{constructor(t,e,n,r=!1){this.name="",this.data=t,this.itemSize=e,this.offset=n,this.normalized=r===!0}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,n=this.data.count;e<n;e++)Re.fromBufferAttribute(this,e),Re.applyMatrix4(t),this.setXYZ(e,Re.x,Re.y,Re.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)Re.fromBufferAttribute(this,e),Re.applyNormalMatrix(t),this.setXYZ(e,Re.x,Re.y,Re.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)Re.fromBufferAttribute(this,e),Re.transformDirection(t),this.setXYZ(e,Re.x,Re.y,Re.z);return this}setX(t,e){return this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){return this.data.array[t*this.data.stride+this.offset]}getY(t){return this.data.array[t*this.data.stride+this.offset+1]}getZ(t){return this.data.array[t*this.data.stride+this.offset+2]}getW(t){return this.data.array[t*this.data.stride+this.offset+3]}setXY(t,e,n){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this}setXYZ(t,e,n,r){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=r,this}setXYZW(t,e,n,r,s){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=r,this.data.array[t+3]=s,this}clone(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let n=0;n<this.count;n++){const r=n*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)e.push(this.data.array[r+s])}return new re(new this.array.constructor(e),this.itemSize,this.normalized)}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new As(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let n=0;n<this.count;n++){const r=n*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)e.push(this.data.array[r+s])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}As.prototype.isInterleavedBufferAttribute=!0;class fc extends he{constructor(t){super();this.type="SpriteMaterial",this.color=new Mt(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this}}fc.prototype.isSpriteMaterial=!0;let Ki;const Hr=new k,Zi=new k,zi=new k,Qi=new ct,qr=new ct,cf=new It,ea=new k,Jr=new k,na=new k,ph=new ct,Zo=new ct,mh=new ct;class Uv extends Qt{constructor(t){super();if(this.type="Sprite",Ki===void 0){Ki=new te;const e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),n=new Ts(e,5);Ki.setIndex([0,1,2,0,2,3]),Ki.setAttribute("position",new As(n,3,0,!1)),Ki.setAttribute("uv",new As(n,2,3,!1))}this.geometry=Ki,this.material=t!==void 0?t:new fc,this.center=new ct(.5,.5)}raycast(t,e){t.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Zi.setFromMatrixScale(this.matrixWorld),cf.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),zi.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&Zi.multiplyScalar(-zi.z);const n=this.material.rotation;let r,s;n!==0&&(s=Math.cos(n),r=Math.sin(n));const a=this.center;ia(ea.set(-.5,-.5,0),zi,a,Zi,r,s),ia(Jr.set(.5,-.5,0),zi,a,Zi,r,s),ia(na.set(.5,.5,0),zi,a,Zi,r,s),ph.set(0,0),Zo.set(1,0),mh.set(1,1);let o=t.ray.intersectTriangle(ea,Jr,na,!1,Hr);if(o===null&&(ia(Jr.set(-.5,.5,0),zi,a,Zi,r,s),Zo.set(0,1),o=t.ray.intersectTriangle(ea,na,Jr,!1,Hr),o===null))return;const l=t.ray.origin.distanceTo(Hr);l<t.near||l>t.far||e.push({distance:l,point:Hr.clone(),uv:ce.getUV(Hr,ea,Jr,na,ph,Zo,mh,new ct),face:null,object:this})}copy(t){return super.copy(t),t.center!==void 0&&this.center.copy(t.center),this.material=t.material,this}}Uv.prototype.isSprite=!0;function ia(i,t,e,n,r,s){Qi.subVectors(i,e).addScalar(.5).multiply(n),r!==void 0?(qr.x=s*Qi.x-r*Qi.y,qr.y=r*Qi.x+s*Qi.y):qr.copy(Qi),i.copy(t),i.x+=qr.x,i.y+=qr.y,i.applyMatrix4(cf)}const gh=new k,yh=new Kt,Ah=new Kt,Pv=new k,Sh=new It;class uf extends pe{constructor(t,e){super(t,e);this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new It,this.bindMatrixInverse=new It}copy(t){return super.copy(t),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,this}bind(t,e){this.skeleton=t,e===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new Kt,e=this.geometry.attributes.skinWeight;for(let n=0,r=e.count;n<r;n++){t.fromBufferAttribute(e,n);const s=1/t.manhattanLength();s!==1/0?t.multiplyScalar(s):t.set(1,0,0,0),e.setXYZW(n,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(t,e){const n=this.skeleton,r=this.geometry;yh.fromBufferAttribute(r.attributes.skinIndex,t),Ah.fromBufferAttribute(r.attributes.skinWeight,t),gh.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let s=0;s<4;s++){const a=Ah.getComponent(s);if(a!==0){const o=yh.getComponent(s);Sh.multiplyMatrices(n.bones[o].matrixWorld,n.boneInverses[o]),e.addScaledVector(Pv.copy(gh).applyMatrix4(Sh),a)}}return e.applyMatrix4(this.bindMatrixInverse)}}uf.prototype.isSkinnedMesh=!0;class Dv extends Qt{constructor(){super();this.type="Bone"}}Dv.prototype.isBone=!0;class hf extends ge{constructor(t=null,e=1,n=1,r,s,a,o,l,c=ae,u=ae,h,d){super(null,a,o,l,c,u,r,s,h,d);this.image={data:t,width:e,height:n},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}hf.prototype.isDataTexture=!0;class El extends re{constructor(t,e,n,r=1){typeof n=="number"&&(r=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."));super(t,e,n);this.meshPerAttribute=r}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}El.prototype.isInstancedBufferAttribute=!0;const xh=new It,vh=new It,ra=[],Or=new pe;class Fv extends pe{constructor(t,e,n){super(t,e);this.instanceMatrix=new El(new Float32Array(n*16),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}copy(t){return super.copy(t),this.instanceMatrix.copy(t.instanceMatrix),t.instanceColor!==null&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,this}getColorAt(t,e){e.fromArray(this.instanceColor.array,t*3)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,t*16)}raycast(t,e){const n=this.matrixWorld,r=this.count;if(Or.geometry=this.geometry,Or.material=this.material,Or.material!==void 0)for(let s=0;s<r;s++){this.getMatrixAt(s,xh),vh.multiplyMatrices(n,xh),Or.matrixWorld=vh,Or.raycast(t,ra);for(let a=0,o=ra.length;a<o;a++){const l=ra[a];l.instanceId=s,l.object=this,e.push(l)}ra.length=0}}setColorAt(t,e){this.instanceColor===null&&(this.instanceColor=new El(new Float32Array(this.instanceMatrix.count*3),3)),e.toArray(this.instanceColor.array,t*3)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,t*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}Fv.prototype.isInstancedMesh=!0;class Wr extends he{constructor(t){super();this.type="LineBasicMaterial",this.color=new Mt(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this}}Wr.prototype.isLineBasicMaterial=!0;const bh=new k,Th=new k,Mh=new It,zo=new kr,sa=new Ir;class pc extends Qt{constructor(t=new te,e=new Wr){super();this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(t.index===null){const e=t.attributes.position,n=[0];for(let r=1,s=e.count;r<s;r++)bh.fromBufferAttribute(e,r-1),Th.fromBufferAttribute(e,r),n[r]=n[r-1],n[r]+=bh.distanceTo(Th);t.setAttribute("lineDistance",new me(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(t,e){const n=this.geometry,r=this.matrixWorld,s=t.params.Line.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),sa.copy(n.boundingSphere),sa.applyMatrix4(r),sa.radius+=s,t.ray.intersectsSphere(sa)===!1)return;Mh.copy(r).invert(),zo.copy(t.ray).applyMatrix4(Mh);const o=s/((this.scale.x+this.scale.y+this.scale.z)/3),l=o*o,c=new k,u=new k,h=new k,d=new k,m=this.isLineSegments?2:1;if(n.isBufferGeometry){const g=n.index,f=n.attributes.position;if(g!==null){const y=Math.max(0,a.start),M=Math.min(g.count,a.start+a.count);for(let E=y,R=M-1;E<R;E+=m){const b=g.getX(E),D=g.getX(E+1);if(c.fromBufferAttribute(f,b),u.fromBufferAttribute(f,D),zo.distanceSqToSegment(c,u,d,h)>l)continue;d.applyMatrix4(this.matrixWorld);const X=t.ray.origin.distanceTo(d);X<t.near||X>t.far||e.push({distance:X,point:h.clone().applyMatrix4(this.matrixWorld),index:E,face:null,faceIndex:null,object:this})}}else{const y=Math.max(0,a.start),M=Math.min(f.count,a.start+a.count);for(let E=y,R=M-1;E<R;E+=m){if(c.fromBufferAttribute(f,E),u.fromBufferAttribute(f,E+1),zo.distanceSqToSegment(c,u,d,h)>l)continue;d.applyMatrix4(this.matrixWorld);const D=t.ray.origin.distanceTo(d);D<t.near||D>t.far||e.push({distance:D,point:h.clone().applyMatrix4(this.matrixWorld),index:E,face:null,faceIndex:null,object:this})}}}else n.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const r=e[n[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=r.length;s<a;s++){const o=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}pc.prototype.isLine=!0;const wh=new k,Ih=new k;class mc extends pc{constructor(t,e){super(t,e);this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(t.index===null){const e=t.attributes.position,n=[];for(let r=0,s=e.count;r<s;r+=2)wh.fromBufferAttribute(e,r),Ih.fromBufferAttribute(e,r+1),n[r]=r===0?0:n[r-1],n[r+1]=n[r]+wh.distanceTo(Ih);t.setAttribute("lineDistance",new me(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}mc.prototype.isLineSegments=!0;class Bv extends pc{constructor(t,e){super(t,e);this.type="LineLoop"}}Bv.prototype.isLineLoop=!0;class gc extends he{constructor(t){super();this.type="PointsMaterial",this.color=new Mt(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this}}gc.prototype.isPointsMaterial=!0;const kh=new It,Wl=new kr,aa=new Ir,oa=new k;class Hv extends Qt{constructor(t=new te,e=new gc){super();this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}raycast(t,e){const n=this.geometry,r=this.matrixWorld,s=t.params.Points.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),aa.copy(n.boundingSphere),aa.applyMatrix4(r),aa.radius+=s,t.ray.intersectsSphere(aa)===!1)return;kh.copy(r).invert(),Wl.copy(t.ray).applyMatrix4(kh);const o=s/((this.scale.x+this.scale.y+this.scale.z)/3),l=o*o;if(n.isBufferGeometry){const c=n.index,h=n.attributes.position;if(c!==null){const d=Math.max(0,a.start),m=Math.min(c.count,a.start+a.count);for(let g=d,p=m;g<p;g++){const f=c.getX(g);oa.fromBufferAttribute(h,f),Rh(oa,f,l,r,t,e,this)}}else{const d=Math.max(0,a.start),m=Math.min(h.count,a.start+a.count);for(let g=d,p=m;g<p;g++)oa.fromBufferAttribute(h,g),Rh(oa,g,l,r,t,e,this)}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const r=e[n[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=r.length;s<a;s++){const o=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}Hv.prototype.isPoints=!0;function Rh(i,t,e,n,r,s,a){const o=Wl.distanceSqToPoint(i);if(o<e){const l=new k;Wl.closestPointToPoint(i,l),l.applyMatrix4(n);const c=r.ray.origin.distanceTo(l);if(c<r.near||c>r.far)return;s.push({distance:c,distanceToRay:Math.sqrt(o),point:l,index:t,face:null,object:a})}}class qv extends ge{constructor(t,e,n,r,s,a,o,l,c){super(t,e,n,r,s,a,o,l,c);this.minFilter=a!==void 0?a:Pe,this.magFilter=s!==void 0?s:Pe,this.generateMipmaps=!1;const u=this;function h(){u.needsUpdate=!0,t.requestVideoFrameCallback(h)}"requestVideoFrameCallback"in t&&t.requestVideoFrameCallback(h)}clone(){return new this.constructor(this.image).copy(this)}update(){const t=this.image;"requestVideoFrameCallback"in t===!1&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}qv.prototype.isVideoTexture=!0;class Jv extends ge{constructor(t,e,n){super({width:t,height:e});this.format=n,this.magFilter=ae,this.minFilter=ae,this.generateMipmaps=!1,this.needsUpdate=!0}}Jv.prototype.isFramebufferTexture=!0;class Ov extends ge{constructor(t,e,n,r,s,a,o,l,c,u,h,d){super(null,a,o,l,c,u,r,s,h,d);this.image={width:e,height:n},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}}Ov.prototype.isCompressedTexture=!0;class Gv extends ge{constructor(t,e,n,r,s,a,o,l,c){super(t,e,n,r,s,a,o,l,c);this.needsUpdate=!0}}Gv.prototype.isCanvasTexture=!0;class Ze{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(t,e){const n=this.getUtoTmapping(t);return this.getPoint(n,e)}getPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return e}getSpacedPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPointAt(n/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let n,r=this.getPoint(0),s=0;e.push(0);for(let a=1;a<=t;a++)n=this.getPoint(a/t),s+=n.distanceTo(r),e.push(s),r=n;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e){const n=this.getLengths();let r=0;const s=n.length;let a;e?a=e:a=t*n[s-1];let o=0,l=s-1,c;for(;o<=l;)if(r=Math.floor(o+(l-o)/2),c=n[r]-a,c<0)o=r+1;else if(c>0)l=r-1;else{l=r;break}if(r=l,n[r]===a)return r/(s-1);const u=n[r],d=n[r+1]-u,m=(a-u)/d;return(r+m)/(s-1)}getTangent(t,e){let r=t-1e-4,s=t+1e-4;r<0&&(r=0),s>1&&(s=1);const a=this.getPoint(r),o=this.getPoint(s),l=e||(a.isVector2?new ct:new k);return l.copy(o).sub(a).normalize(),l}getTangentAt(t,e){const n=this.getUtoTmapping(t);return this.getTangent(n,e)}computeFrenetFrames(t,e){const n=new k,r=[],s=[],a=[],o=new k,l=new It;for(let m=0;m<=t;m++){const g=m/t;r[m]=this.getTangentAt(g,new k)}s[0]=new k,a[0]=new k;let c=Number.MAX_VALUE;const u=Math.abs(r[0].x),h=Math.abs(r[0].y),d=Math.abs(r[0].z);u<=c&&(c=u,n.set(1,0,0)),h<=c&&(c=h,n.set(0,1,0)),d<=c&&n.set(0,0,1),o.crossVectors(r[0],n).normalize(),s[0].crossVectors(r[0],o),a[0].crossVectors(r[0],s[0]);for(let m=1;m<=t;m++){if(s[m]=s[m-1].clone(),a[m]=a[m-1].clone(),o.crossVectors(r[m-1],r[m]),o.length()>Number.EPSILON){o.normalize();const g=Math.acos(fe(r[m-1].dot(r[m]),-1,1));s[m].applyMatrix4(l.makeRotationAxis(o,g))}a[m].crossVectors(r[m],s[m])}if(e===!0){let m=Math.acos(fe(s[0].dot(s[t]),-1,1));m/=t,r[0].dot(o.crossVectors(s[0],s[t]))>0&&(m=-m);for(let g=1;g<=t;g++)s[g].applyMatrix4(l.makeRotationAxis(r[g],m*g)),a[g].crossVectors(r[g],s[g])}return{tangents:r,normals:s,binormals:a}}clone(){return new this.constructor().copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class $a extends Ze{constructor(t=0,e=0,n=1,r=1,s=0,a=Math.PI*2,o=!1,l=0){super();this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=n,this.yRadius=r,this.aStartAngle=s,this.aEndAngle=a,this.aClockwise=o,this.aRotation=l}getPoint(t,e){const n=e||new ct,r=Math.PI*2;let s=this.aEndAngle-this.aStartAngle;const a=Math.abs(s)<Number.EPSILON;for(;s<0;)s+=r;for(;s>r;)s-=r;s<Number.EPSILON&&(a?s=0:s=r),this.aClockwise===!0&&!a&&(s===r?s=-r:s=s-r);const o=this.aStartAngle+t*s;let l=this.aX+this.xRadius*Math.cos(o),c=this.aY+this.yRadius*Math.sin(o);if(this.aRotation!==0){const u=Math.cos(this.aRotation),h=Math.sin(this.aRotation),d=l-this.aX,m=c-this.aY;l=d*u-m*h+this.aX,c=d*h+m*u+this.aY}return n.set(l,c)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){const t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}$a.prototype.isEllipseCurve=!0;class df extends $a{constructor(t,e,n,r,s,a){super(t,e,n,n,r,s,a);this.type="ArcCurve"}}df.prototype.isArcCurve=!0;function yc(){let i=0,t=0,e=0,n=0;function r(s,a,o,l){i=s,t=o,e=-3*s+3*a-2*o-l,n=2*s-2*a+o+l}return{initCatmullRom:function(s,a,o,l,c){r(a,o,c*(o-s),c*(l-a))},initNonuniformCatmullRom:function(s,a,o,l,c,u,h){let d=(a-s)/c-(o-s)/(c+u)+(o-a)/u,m=(o-a)/u-(l-a)/(u+h)+(l-o)/h;d*=u,m*=u,r(a,o,d,m)},calc:function(s){const a=s*s,o=a*s;return i+t*s+e*a+n*o}}}const la=new k,Qo=new yc,_o=new yc,Yo=new yc;class ff extends Ze{constructor(t=[],e=!1,n="centripetal",r=.5){super();this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=n,this.tension=r}getPoint(t,e=new k){const n=e,r=this.points,s=r.length,a=(s-(this.closed?0:1))*t;let o=Math.floor(a),l=a-o;this.closed?o+=o>0?0:(Math.floor(Math.abs(o)/s)+1)*s:l===0&&o===s-1&&(o=s-2,l=1);let c,u;this.closed||o>0?c=r[(o-1)%s]:(la.subVectors(r[0],r[1]).add(r[0]),c=la);const h=r[o%s],d=r[(o+1)%s];if(this.closed||o+2<s?u=r[(o+2)%s]:(la.subVectors(r[s-1],r[s-2]).add(r[s-1]),u=la),this.curveType==="centripetal"||this.curveType==="chordal"){const m=this.curveType==="chordal"?.5:.25;let g=Math.pow(c.distanceToSquared(h),m),p=Math.pow(h.distanceToSquared(d),m),f=Math.pow(d.distanceToSquared(u),m);p<1e-4&&(p=1),g<1e-4&&(g=p),f<1e-4&&(f=p),Qo.initNonuniformCatmullRom(c.x,h.x,d.x,u.x,g,p,f),_o.initNonuniformCatmullRom(c.y,h.y,d.y,u.y,g,p,f),Yo.initNonuniformCatmullRom(c.z,h.z,d.z,u.z,g,p,f)}else this.curveType==="catmullrom"&&(Qo.initCatmullRom(c.x,h.x,d.x,u.x,this.tension),_o.initCatmullRom(c.y,h.y,d.y,u.y,this.tension),Yo.initCatmullRom(c.z,h.z,d.z,u.z,this.tension));return n.set(Qo.calc(l),_o.calc(l),Yo.calc(l)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const r=t.points[e];this.points.push(r.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const r=this.points[e];t.points.push(r.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const r=t.points[e];this.points.push(new k().fromArray(r))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}ff.prototype.isCatmullRomCurve3=!0;function Eh(i,t,e,n,r){const s=(n-t)*.5,a=(r-e)*.5,o=i*i,l=i*o;return(2*e-2*n+s+a)*l+(-3*e+3*n-2*s-a)*o+s*i+e}function jv(i,t){const e=1-i;return e*e*t}function Xv(i,t){return 2*(1-i)*i*t}function Kv(i,t){return i*i*t}function ss(i,t,e,n){return jv(i,t)+Xv(i,e)+Kv(i,n)}function Zv(i,t){const e=1-i;return e*e*e*t}function zv(i,t){const e=1-i;return 3*e*e*i*t}function Qv(i,t){return 3*(1-i)*i*i*t}function _v(i,t){return i*i*i*t}function as(i,t,e,n,r){return Zv(i,t)+zv(i,e)+Qv(i,n)+_v(i,r)}class Ac extends Ze{constructor(t=new ct,e=new ct,n=new ct,r=new ct){super();this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=n,this.v3=r}getPoint(t,e=new ct){const n=e,r=this.v0,s=this.v1,a=this.v2,o=this.v3;return n.set(as(t,r.x,s.x,a.x,o.x),as(t,r.y,s.y,a.y,o.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}Ac.prototype.isCubicBezierCurve=!0;class pf extends Ze{constructor(t=new k,e=new k,n=new k,r=new k){super();this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=n,this.v3=r}getPoint(t,e=new k){const n=e,r=this.v0,s=this.v1,a=this.v2,o=this.v3;return n.set(as(t,r.x,s.x,a.x,o.x),as(t,r.y,s.y,a.y,o.y),as(t,r.z,s.z,a.z,o.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}pf.prototype.isCubicBezierCurve3=!0;class to extends Ze{constructor(t=new ct,e=new ct){super();this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new ct){const n=e;return t===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e){const n=e||new ct;return n.copy(this.v2).sub(this.v1).normalize(),n}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}to.prototype.isLineCurve=!0;class Yv extends Ze{constructor(t=new k,e=new k){super();this.type="LineCurve3",this.isLineCurve3=!0,this.v1=t,this.v2=e}getPoint(t,e=new k){const n=e;return t===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class Sc extends Ze{constructor(t=new ct,e=new ct,n=new ct){super();this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new ct){const n=e,r=this.v0,s=this.v1,a=this.v2;return n.set(ss(t,r.x,s.x,a.x),ss(t,r.y,s.y,a.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}Sc.prototype.isQuadraticBezierCurve=!0;class mf extends Ze{constructor(t=new k,e=new k,n=new k){super();this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new k){const n=e,r=this.v0,s=this.v1,a=this.v2;return n.set(ss(t,r.x,s.x,a.x),ss(t,r.y,s.y,a.y),ss(t,r.z,s.z,a.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}mf.prototype.isQuadraticBezierCurve3=!0;class xc extends Ze{constructor(t=[]){super();this.type="SplineCurve",this.points=t}getPoint(t,e=new ct){const n=e,r=this.points,s=(r.length-1)*t,a=Math.floor(s),o=s-a,l=r[a===0?a:a-1],c=r[a],u=r[a>r.length-2?r.length-1:a+1],h=r[a>r.length-3?r.length-1:a+2];return n.set(Eh(o,l.x,c.x,u.x,h.x),Eh(o,l.y,c.y,u.y,h.y)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const r=t.points[e];this.points.push(r.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const r=this.points[e];t.points.push(r.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const r=t.points[e];this.points.push(new ct().fromArray(r))}return this}}xc.prototype.isSplineCurve=!0;var gf=Object.freeze({__proto__:null,ArcCurve:df,CatmullRomCurve3:ff,CubicBezierCurve:Ac,CubicBezierCurve3:pf,EllipseCurve:$a,LineCurve:to,LineCurve3:Yv,QuadraticBezierCurve:Sc,QuadraticBezierCurve3:mf,SplineCurve:xc});class $v extends Ze{constructor(){super();this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);t.equals(e)||this.curves.push(new to(e,t))}getPoint(t,e){const n=t*this.getLength(),r=this.getCurveLengths();let s=0;for(;s<r.length;){if(r[s]>=n){const a=r[s]-n,o=this.curves[s],l=o.getLength(),c=l===0?0:1-a/l;return o.getPointAt(c,e)}s++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let n=0,r=this.curves.length;n<r;n++)e+=this.curves[n].getLength(),t.push(e);return this.cacheLengths=t,t}getSpacedPoints(t=40){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){const e=[];let n;for(let r=0,s=this.curves;r<s.length;r++){const a=s[r],o=a.isEllipseCurve?t*2:a.isLineCurve||a.isLineCurve3?1:a.isSplineCurve?t*a.points.length:t,l=a.getPoints(o);for(let c=0;c<l.length;c++){const u=l[c];n&&n.equals(u)||(e.push(u),n=u)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e}copy(t){super.copy(t),this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const r=t.curves[e];this.curves.push(r.clone())}return this.autoClose=t.autoClose,this}toJSON(){const t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,n=this.curves.length;e<n;e++){const r=this.curves[e];t.curves.push(r.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const r=t.curves[e];this.curves.push(new gf[r.type]().fromJSON(r))}return this}}class Cl extends $v{constructor(t){super();this.type="Path",this.currentPoint=new ct,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,n=t.length;e<n;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){const n=new to(this.currentPoint.clone(),new ct(t,e));return this.curves.push(n),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,n,r){const s=new Sc(this.currentPoint.clone(),new ct(t,e),new ct(n,r));return this.curves.push(s),this.currentPoint.set(n,r),this}bezierCurveTo(t,e,n,r,s,a){const o=new Ac(this.currentPoint.clone(),new ct(t,e),new ct(n,r),new ct(s,a));return this.curves.push(o),this.currentPoint.set(s,a),this}splineThru(t){const e=[this.currentPoint.clone()].concat(t),n=new xc(e);return this.curves.push(n),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,n,r,s,a){const o=this.currentPoint.x,l=this.currentPoint.y;return this.absarc(t+o,e+l,n,r,s,a),this}absarc(t,e,n,r,s,a){return this.absellipse(t,e,n,n,r,s,a),this}ellipse(t,e,n,r,s,a,o,l){const c=this.currentPoint.x,u=this.currentPoint.y;return this.absellipse(t+c,e+u,n,r,s,a,o,l),this}absellipse(t,e,n,r,s,a,o,l){const c=new $a(t,e,n,r,s,a,o,l);if(this.curves.length>0){const h=c.getPoint(0);h.equals(this.currentPoint)||this.lineTo(h.x,h.y)}this.curves.push(c);const u=c.getPoint(1);return this.currentPoint.copy(u),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){const t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}new k;new k;new k;new ce;class Ms extends Cl{constructor(t){super(t);this.uuid=rn(),this.type="Shape",this.holes=[]}getPointsHoles(t){const e=[];for(let n=0,r=this.holes.length;n<r;n++)e[n]=this.holes[n].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const r=t.holes[e];this.holes.push(r.clone())}return this}toJSON(){const t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,n=this.holes.length;e<n;e++){const r=this.holes[e];t.holes.push(r.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const r=t.holes[e];this.holes.push(new Cl().fromJSON(r))}return this}}const tb={triangulate:function(i,t,e=2){const n=t&&t.length,r=n?t[0]*e:i.length;let s=yf(i,0,r,e,!0);const a=[];if(!s||s.next===s.prev)return a;let o,l,c,u,h,d,m;if(n&&(s=sb(i,t,s,e)),i.length>80*e){o=c=i[0],l=u=i[1];for(let g=e;g<r;g+=e)h=i[g],d=i[g+1],h<o&&(o=h),d<l&&(l=d),h>c&&(c=h),d>u&&(u=d);m=Math.max(c-o,u-l),m=m!==0?1/m:0}return Ss(s,a,e,o,l,m),a}};function yf(i,t,e,n,r){let s,a;if(r===gb(i,t,e,n)>0)for(s=t;s<e;s+=n)a=Wh(s,i[s],i[s+1],a);else for(s=e-n;s>=t;s-=n)a=Wh(s,i[s],i[s+1],a);return a&&eo(a,a.next)&&(vs(a),a=a.next),a}function ni(i,t){if(!i)return i;t||(t=i);let e=i,n;do if(n=!1,!e.steiner&&(eo(e,e.next)||ie(e.prev,e,e.next)===0)){if(vs(e),e=t=e.prev,e===e.next)break;n=!0}else e=e.next;while(n||e!==t);return t}function Ss(i,t,e,n,r,s,a){if(!i)return;!a&&s&&ub(i,n,r,s);let o=i,l,c;for(;i.prev!==i.next;){if(l=i.prev,c=i.next,s?nb(i,n,r,s):eb(i)){t.push(l.i/e),t.push(i.i/e),t.push(c.i/e),vs(i),i=c.next,o=c.next;continue}if(i=c,i===o){a?a===1?(i=ib(ni(i),t,e),Ss(i,t,e,n,r,s,2)):a===2&&rb(i,t,e,n,r,s):Ss(ni(i),t,e,n,r,s,1);break}}}function eb(i){const t=i.prev,e=i,n=i.next;if(ie(t,e,n)>=0)return!1;let r=i.next.next;for(;r!==i.prev;){if(ar(t.x,t.y,e.x,e.y,n.x,n.y,r.x,r.y)&&ie(r.prev,r,r.next)>=0)return!1;r=r.next}return!0}function nb(i,t,e,n){const r=i.prev,s=i,a=i.next;if(ie(r,s,a)>=0)return!1;const o=r.x<s.x?r.x<a.x?r.x:a.x:s.x<a.x?s.x:a.x,l=r.y<s.y?r.y<a.y?r.y:a.y:s.y<a.y?s.y:a.y,c=r.x>s.x?r.x>a.x?r.x:a.x:s.x>a.x?s.x:a.x,u=r.y>s.y?r.y>a.y?r.y:a.y:s.y>a.y?s.y:a.y,h=Ll(o,l,t,e,n),d=Ll(c,u,t,e,n);let m=i.prevZ,g=i.nextZ;for(;m&&m.z>=h&&g&&g.z<=d;){if(m!==i.prev&&m!==i.next&&ar(r.x,r.y,s.x,s.y,a.x,a.y,m.x,m.y)&&ie(m.prev,m,m.next)>=0||(m=m.prevZ,g!==i.prev&&g!==i.next&&ar(r.x,r.y,s.x,s.y,a.x,a.y,g.x,g.y)&&ie(g.prev,g,g.next)>=0))return!1;g=g.nextZ}for(;m&&m.z>=h;){if(m!==i.prev&&m!==i.next&&ar(r.x,r.y,s.x,s.y,a.x,a.y,m.x,m.y)&&ie(m.prev,m,m.next)>=0)return!1;m=m.prevZ}for(;g&&g.z<=d;){if(g!==i.prev&&g!==i.next&&ar(r.x,r.y,s.x,s.y,a.x,a.y,g.x,g.y)&&ie(g.prev,g,g.next)>=0)return!1;g=g.nextZ}return!0}function ib(i,t,e){let n=i;do{const r=n.prev,s=n.next.next;!eo(r,s)&&Af(r,n,n.next,s)&&xs(r,s)&&xs(s,r)&&(t.push(r.i/e),t.push(n.i/e),t.push(s.i/e),vs(n),vs(n.next),n=i=s),n=n.next}while(n!==i);return ni(n)}function rb(i,t,e,n,r,s){let a=i;do{let o=a.next.next;for(;o!==a.prev;){if(a.i!==o.i&&fb(a,o)){let l=Sf(a,o);a=ni(a,a.next),l=ni(l,l.next),Ss(a,t,e,n,r,s),Ss(l,t,e,n,r,s);return}o=o.next}a=a.next}while(a!==i)}function sb(i,t,e,n){const r=[];let s,a,o,l,c;for(s=0,a=t.length;s<a;s++)o=t[s]*n,l=s<a-1?t[s+1]*n:i.length,c=yf(i,o,l,n,!1),c===c.next&&(c.steiner=!0),r.push(db(c));for(r.sort(ab),s=0;s<r.length;s++)ob(r[s],e),e=ni(e,e.next);return e}function ab(i,t){return i.x-t.x}function ob(i,t){if(t=lb(i,t),t){const e=Sf(t,i);ni(t,t.next),ni(e,e.next)}}function lb(i,t){let e=t;const n=i.x,r=i.y;let s=-1/0,a;do{if(r<=e.y&&r>=e.next.y&&e.next.y!==e.y){const d=e.x+(r-e.y)*(e.next.x-e.x)/(e.next.y-e.y);if(d<=n&&d>s){if(s=d,d===n){if(r===e.y)return e;if(r===e.next.y)return e.next}a=e.x<e.next.x?e:e.next}}e=e.next}while(e!==t);if(!a)return null;if(n===s)return a;const o=a,l=a.x,c=a.y;let u=1/0,h;e=a;do n>=e.x&&e.x>=l&&n!==e.x&&ar(r<c?n:s,r,l,c,r<c?s:n,r,e.x,e.y)&&(h=Math.abs(r-e.y)/(n-e.x),xs(e,i)&&(h<u||h===u&&(e.x>a.x||e.x===a.x&&cb(a,e)))&&(a=e,u=h)),e=e.next;while(e!==o);return a}function cb(i,t){return ie(i.prev,i,t.prev)<0&&ie(t.next,i,i.next)<0}function ub(i,t,e,n){let r=i;do r.z===null&&(r.z=Ll(r.x,r.y,t,e,n)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next;while(r!==i);r.prevZ.nextZ=null,r.prevZ=null,hb(r)}function hb(i){let t,e,n,r,s,a,o,l,c=1;do{for(e=i,i=null,s=null,a=0;e;){for(a++,n=e,o=0,t=0;t<c&&(o++,n=n.nextZ,!!n);t++);for(l=c;o>0||l>0&&n;)o!==0&&(l===0||!n||e.z<=n.z)?(r=e,e=e.nextZ,o--):(r=n,n=n.nextZ,l--),s?s.nextZ=r:i=r,r.prevZ=s,s=r;e=n}s.nextZ=null,c*=2}while(a>1);return i}function Ll(i,t,e,n,r){return i=32767*(i-e)*r,t=32767*(t-n)*r,i=(i|i<<8)&16711935,i=(i|i<<4)&252645135,i=(i|i<<2)&858993459,i=(i|i<<1)&1431655765,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,i|t<<1}function db(i){let t=i,e=i;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==i);return e}function ar(i,t,e,n,r,s,a,o){return(r-a)*(t-o)-(i-a)*(s-o)>=0&&(i-a)*(n-o)-(e-a)*(t-o)>=0&&(e-a)*(s-o)-(r-a)*(n-o)>=0}function fb(i,t){return i.next.i!==t.i&&i.prev.i!==t.i&&!pb(i,t)&&(xs(i,t)&&xs(t,i)&&mb(i,t)&&(ie(i.prev,i,t.prev)||ie(i,t.prev,t))||eo(i,t)&&ie(i.prev,i,i.next)>0&&ie(t.prev,t,t.next)>0)}function ie(i,t,e){return(t.y-i.y)*(e.x-t.x)-(t.x-i.x)*(e.y-t.y)}function eo(i,t){return i.x===t.x&&i.y===t.y}function Af(i,t,e,n){const r=ua(ie(i,t,e)),s=ua(ie(i,t,n)),a=ua(ie(e,n,i)),o=ua(ie(e,n,t));return!!(r!==s&&a!==o||r===0&&ca(i,e,t)||s===0&&ca(i,n,t)||a===0&&ca(e,i,n)||o===0&&ca(e,t,n))}function ca(i,t,e){return t.x<=Math.max(i.x,e.x)&&t.x>=Math.min(i.x,e.x)&&t.y<=Math.max(i.y,e.y)&&t.y>=Math.min(i.y,e.y)}function ua(i){return i>0?1:i<0?-1:0}function pb(i,t){let e=i;do{if(e.i!==i.i&&e.next.i!==i.i&&e.i!==t.i&&e.next.i!==t.i&&Af(e,e.next,i,t))return!0;e=e.next}while(e!==i);return!1}function xs(i,t){return ie(i.prev,i,i.next)<0?ie(i,t,i.next)>=0&&ie(i,i.prev,t)>=0:ie(i,t,i.prev)<0||ie(i,i.next,t)<0}function mb(i,t){let e=i,n=!1;const r=(i.x+t.x)/2,s=(i.y+t.y)/2;do e.y>s!=e.next.y>s&&e.next.y!==e.y&&r<(e.next.x-e.x)*(s-e.y)/(e.next.y-e.y)+e.x&&(n=!n),e=e.next;while(e!==i);return n}function Sf(i,t){const e=new Nl(i.i,i.x,i.y),n=new Nl(t.i,t.x,t.y),r=i.next,s=t.prev;return i.next=t,t.prev=i,e.next=r,r.prev=e,n.next=e,e.prev=n,s.next=n,n.prev=s,n}function Wh(i,t,e,n){const r=new Nl(i,t,e);return n?(r.next=n.next,r.prev=n,n.next.prev=r,n.next=r):(r.prev=r,r.next=r),r}function vs(i){i.next.prev=i.prev,i.prev.next=i.next,i.prevZ&&(i.prevZ.nextZ=i.nextZ),i.nextZ&&(i.nextZ.prevZ=i.prevZ)}function Nl(i,t,e){this.i=i,this.x=t,this.y=e,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function gb(i,t,e,n){let r=0;for(let s=t,a=e-n;s<e;s+=n)r+=(i[a]-i[s])*(i[s+1]+i[a+1]),a=s;return r}class ti{static area(t){const e=t.length;let n=0;for(let r=e-1,s=0;s<e;r=s++)n+=t[r].x*t[s].y-t[s].x*t[r].y;return n*.5}static isClockWise(t){return ti.area(t)<0}static triangulateShape(t,e){const n=[],r=[],s=[];Ch(t),Lh(n,t);let a=t.length;e.forEach(Ch);for(let l=0;l<e.length;l++)r.push(a),a+=e[l].length,Lh(n,e[l]);const o=tb.triangulate(n,r);for(let l=0;l<o.length;l+=3)s.push(o.slice(l,l+3));return s}}function Ch(i){const t=i.length;t>2&&i[t-1].equals(i[0])&&i.pop()}function Lh(i,t){for(let e=0;e<t.length;e++)i.push(t[e].x),i.push(t[e].y)}class Cr extends te{constructor(t=new Ms([new ct(.5,.5),new ct(-.5,.5),new ct(-.5,-.5),new ct(.5,-.5)]),e={}){super();this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const n=this,r=[],s=[];for(let o=0,l=t.length;o<l;o++){const c=t[o];a(c)}this.setAttribute("position",new me(r,3)),this.setAttribute("uv",new me(s,2)),this.computeVertexNormals();function a(o){const l=[],c=e.curveSegments!==void 0?e.curveSegments:12,u=e.steps!==void 0?e.steps:1;let h=e.depth!==void 0?e.depth:1,d=e.bevelEnabled!==void 0?e.bevelEnabled:!0,m=e.bevelThickness!==void 0?e.bevelThickness:.2,g=e.bevelSize!==void 0?e.bevelSize:m-.1,p=e.bevelOffset!==void 0?e.bevelOffset:0,f=e.bevelSegments!==void 0?e.bevelSegments:3;const y=e.extrudePath,M=e.UVGenerator!==void 0?e.UVGenerator:yb;e.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),h=e.amount);let E,R=!1,b,D,U,X;y&&(E=y.getSpacedPoints(u),R=!0,d=!1,b=y.computeFrenetFrames(u,!1),D=new k,U=new k,X=new k),d||(f=0,m=0,g=0,p=0);const dt=o.extractPoints(c);let K=dt.shape;const v=dt.holes;if(!ti.isClockWise(K)){K=K.reverse();for(let $=0,x=v.length;$<x;$++){const w=v[$];ti.isClockWise(w)&&(v[$]=w.reverse())}}const it=ti.triangulateShape(K,v),B=K;for(let $=0,x=v.length;$<x;$++){const w=v[$];K=K.concat(w)}function G($,x,w){return x||console.error("THREE.ExtrudeGeometry: vec does not exist"),x.clone().multiplyScalar(w).add($)}const F=K.length,H=it.length;function L($,x,w){let V,P,O;const Z=$.x-x.x,Y=$.y-x.y,rt=w.x-$.x,st=w.y-$.y,S=Z*Z+Y*Y,A=Z*st-Y*rt;if(Math.abs(A)>Number.EPSILON){const N=Math.sqrt(S),q=Math.sqrt(rt*rt+st*st),tt=x.x-Y/N,ot=x.y+Z/N,St=w.x-st/q,T=w.y+rt/q,nt=((St-tt)*st-(T-ot)*rt)/(Z*st-Y*rt);V=tt+Z*nt-$.x,P=ot+Y*nt-$.y;const bt=V*V+P*P;if(bt<=2)return new ct(V,P);O=Math.sqrt(bt/2)}else{let N=!1;Z>Number.EPSILON?rt>Number.EPSILON&&(N=!0):Z<-Number.EPSILON?rt<-Number.EPSILON&&(N=!0):Math.sign(Y)===Math.sign(st)&&(N=!0),N?(V=-Y,P=Z,O=Math.sqrt(S)):(V=Z,P=Y,O=Math.sqrt(S/2))}return new ct(V/O,P/O)}const z=[];for(let $=0,x=B.length,w=x-1,V=$+1;$<x;$++,w++,V++)w===x&&(w=0),V===x&&(V=0),z[$]=L(B[$],B[w],B[V]);const lt=[];let ut,ht=z.concat();for(let $=0,x=v.length;$<x;$++){const w=v[$];ut=[];for(let V=0,P=w.length,O=P-1,Z=V+1;V<P;V++,O++,Z++)O===P&&(O=0),Z===P&&(Z=0),ut[V]=L(w[V],w[O],w[Z]);lt.push(ut),ht=ht.concat(ut)}for(let $=0;$<f;$++){const x=$/f,w=m*Math.cos(x*Math.PI/2),V=g*Math.sin(x*Math.PI/2)+p;for(let P=0,O=B.length;P<O;P++){const Z=G(B[P],z[P],V);Nt(Z.x,Z.y,-w)}for(let P=0,O=v.length;P<O;P++){const Z=v[P];ut=lt[P];for(let Y=0,rt=Z.length;Y<rt;Y++){const st=G(Z[Y],ut[Y],V);Nt(st.x,st.y,-w)}}}const At=g+p;for(let $=0;$<F;$++){const x=d?G(K[$],ht[$],At):K[$];R?(U.copy(b.normals[0]).multiplyScalar(x.x),D.copy(b.binormals[0]).multiplyScalar(x.y),X.copy(E[0]).add(U).add(D),Nt(X.x,X.y,X.z)):Nt(x.x,x.y,0)}for(let $=1;$<=u;$++)for(let x=0;x<F;x++){const w=d?G(K[x],ht[x],At):K[x];R?(U.copy(b.normals[$]).multiplyScalar(w.x),D.copy(b.binormals[$]).multiplyScalar(w.y),X.copy(E[$]).add(U).add(D),Nt(X.x,X.y,X.z)):Nt(w.x,w.y,h/u*$)}for(let $=f-1;$>=0;$--){const x=$/f,w=m*Math.cos(x*Math.PI/2),V=g*Math.sin(x*Math.PI/2)+p;for(let P=0,O=B.length;P<O;P++){const Z=G(B[P],z[P],V);Nt(Z.x,Z.y,h+w)}for(let P=0,O=v.length;P<O;P++){const Z=v[P];ut=lt[P];for(let Y=0,rt=Z.length;Y<rt;Y++){const st=G(Z[Y],ut[Y],V);R?Nt(st.x,st.y+E[u-1].y,E[u-1].x+w):Nt(st.x,st.y,h+w)}}}Lt(),kt();function Lt(){const $=r.length/3;if(d){let x=0,w=F*x;for(let V=0;V<H;V++){const P=it[V];Rt(P[2]+w,P[1]+w,P[0]+w)}x=u+f*2,w=F*x;for(let V=0;V<H;V++){const P=it[V];Rt(P[0]+w,P[1]+w,P[2]+w)}}else{for(let x=0;x<H;x++){const w=it[x];Rt(w[2],w[1],w[0])}for(let x=0;x<H;x++){const w=it[x];Rt(w[0]+F*u,w[1]+F*u,w[2]+F*u)}}n.addGroup($,r.length/3-$,0)}function kt(){const $=r.length/3;let x=0;et(B,x),x+=B.length;for(let w=0,V=v.length;w<V;w++){const P=v[w];et(P,x),x+=P.length}n.addGroup($,r.length/3-$,1)}function et($,x){let w=$.length;for(;--w>=0;){const V=w;let P=w-1;P<0&&(P=$.length-1);for(let O=0,Z=u+f*2;O<Z;O++){const Y=F*O,rt=F*(O+1),st=x+V+Y,S=x+P+Y,A=x+P+rt,N=x+V+rt;Et(st,S,A,N)}}}function Nt($,x,w){l.push($),l.push(x),l.push(w)}function Rt($,x,w){ft($),ft(x),ft(w);const V=r.length/3,P=M.generateTopUV(n,r,V-3,V-2,V-1);Ct(P[0]),Ct(P[1]),Ct(P[2])}function Et($,x,w,V){ft($),ft(x),ft(V),ft(x),ft(w),ft(V);const P=r.length/3,O=M.generateSideWallUV(n,r,P-6,P-3,P-2,P-1);Ct(O[0]),Ct(O[1]),Ct(O[3]),Ct(O[1]),Ct(O[2]),Ct(O[3])}function ft($){r.push(l[$*3+0]),r.push(l[$*3+1]),r.push(l[$*3+2])}function Ct($){s.push($.x),s.push($.y)}}}toJSON(){const t=super.toJSON(),e=this.parameters.shapes,n=this.parameters.options;return Ab(e,n,t)}static fromJSON(t,e){const n=[];for(let s=0,a=t.shapes.length;s<a;s++){const o=e[t.shapes[s]];n.push(o)}const r=t.options.extrudePath;return r!==void 0&&(t.options.extrudePath=new gf[r.type]().fromJSON(r)),new Cr(n,t.options)}}const yb={generateTopUV:function(i,t,e,n,r){const s=t[e*3],a=t[e*3+1],o=t[n*3],l=t[n*3+1],c=t[r*3],u=t[r*3+1];return[new ct(s,a),new ct(o,l),new ct(c,u)]},generateSideWallUV:function(i,t,e,n,r,s){const a=t[e*3],o=t[e*3+1],l=t[e*3+2],c=t[n*3],u=t[n*3+1],h=t[n*3+2],d=t[r*3],m=t[r*3+1],g=t[r*3+2],p=t[s*3],f=t[s*3+1],y=t[s*3+2];return Math.abs(o-u)<Math.abs(a-c)?[new ct(a,1-l),new ct(c,1-h),new ct(d,1-g),new ct(p,1-y)]:[new ct(o,1-l),new ct(u,1-h),new ct(m,1-g),new ct(f,1-y)]}};function Ab(i,t,e){if(e.shapes=[],Array.isArray(i))for(let n=0,r=i.length;n<r;n++){const s=i[n];e.shapes.push(s.uuid)}else e.shapes.push(i.uuid);return t.extrudePath!==void 0&&(e.options.extrudePath=t.extrudePath.toJSON()),e}class vc extends te{constructor(t=new Ms([new ct(0,.5),new ct(-.5,-.5),new ct(.5,-.5)]),e=12){super();this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const n=[],r=[],s=[],a=[];let o=0,l=0;if(Array.isArray(t)===!1)c(t);else for(let u=0;u<t.length;u++)c(t[u]),this.addGroup(o,l,u),o+=l,l=0;this.setIndex(n),this.setAttribute("position",new me(r,3)),this.setAttribute("normal",new me(s,3)),this.setAttribute("uv",new me(a,2));function c(u){const h=r.length/3,d=u.extractPoints(e);let m=d.shape;const g=d.holes;ti.isClockWise(m)===!1&&(m=m.reverse());for(let f=0,y=g.length;f<y;f++){const M=g[f];ti.isClockWise(M)===!0&&(g[f]=M.reverse())}const p=ti.triangulateShape(m,g);for(let f=0,y=g.length;f<y;f++){const M=g[f];m=m.concat(M)}for(let f=0,y=m.length;f<y;f++){const M=m[f];r.push(M.x,M.y,0),s.push(0,0,1),a.push(M.x,M.y)}for(let f=0,y=p.length;f<y;f++){const M=p[f],E=M[0]+h,R=M[1]+h,b=M[2]+h;n.push(E,R,b),l+=3}}}toJSON(){const t=super.toJSON(),e=this.parameters.shapes;return Sb(e,t)}static fromJSON(t,e){const n=[];for(let r=0,s=t.shapes.length;r<s;r++){const a=e[t.shapes[r]];n.push(a)}return new vc(n,t.curveSegments)}}function Sb(i,t){if(t.shapes=[],Array.isArray(i))for(let e=0,n=i.length;e<n;e++){const r=i[e];t.shapes.push(r.uuid)}else t.shapes.push(i.uuid);return t}class xf extends he{constructor(t){super();this.type="ShadowMaterial",this.color=new Mt(0),this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this}}xf.prototype.isShadowMaterial=!0;class vf extends Le{constructor(t){super(t);this.type="RawShaderMaterial"}}vf.prototype.isRawShaderMaterial=!0;class bc extends he{constructor(t){super();this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Mt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Mt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=wr,this.normalScale=new ct(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this}}bc.prototype.isMeshStandardMaterial=!0;class bf extends bc{constructor(t){super();this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new ct(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return fe(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(e){this.ior=(1+.4*e)/(1-.4*e)}}),this.sheenColor=new Mt(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationColor=new Mt(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Mt(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._transmission=0,this.setValues(t)}get sheen(){return this._sheen}set sheen(t){this._sheen>0!=t>0&&this.version++,this._sheen=t}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.ior=t.ior,this.sheen=t.sheen,this.sheenColor.copy(t.sheenColor),this.sheenColorMap=t.sheenColorMap,this.sheenRoughness=t.sheenRoughness,this.sheenRoughnessMap=t.sheenRoughnessMap,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}}bf.prototype.isMeshPhysicalMaterial=!0;class Tf extends he{constructor(t){super();this.type="MeshPhongMaterial",this.color=new Mt(16777215),this.specular=new Mt(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Mt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=wr,this.normalScale=new ct(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Oa,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this}}Tf.prototype.isMeshPhongMaterial=!0;class Mf extends he{constructor(t){super();this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Mt(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Mt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=wr,this.normalScale=new ct(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}Mf.prototype.isMeshToonMaterial=!0;class wf extends he{constructor(t){super();this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=wr,this.normalScale=new ct(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this}}wf.prototype.isMeshNormalMaterial=!0;class If extends he{constructor(t){super();this.type="MeshLambertMaterial",this.color=new Mt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Mt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Oa,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}If.prototype.isMeshLambertMaterial=!0;class kf extends he{constructor(t){super();this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Mt(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=wr,this.normalScale=new ct(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.flatShading=t.flatShading,this}}kf.prototype.isMeshMatcapMaterial=!0;class Rf extends Wr{constructor(t){super();this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}Rf.prototype.isLineDashedMaterial=!0;const xb={ShadowMaterial:xf,SpriteMaterial:fc,RawShaderMaterial:vf,ShaderMaterial:Le,PointsMaterial:gc,MeshPhysicalMaterial:bf,MeshStandardMaterial:bc,MeshPhongMaterial:Tf,MeshToonMaterial:Mf,MeshNormalMaterial:wf,MeshLambertMaterial:If,MeshDepthMaterial:hc,MeshDistanceMaterial:dc,MeshBasicMaterial:Ka,MeshMatcapMaterial:kf,LineDashedMaterial:Rf,LineBasicMaterial:Wr,Material:he};he.fromType=function(i){return new xb[i]};const ne={arraySlice:function(i,t,e){return ne.isTypedArray(i)?new i.constructor(i.subarray(t,e!==void 0?e:i.length)):i.slice(t,e)},convertArray:function(i,t,e){return!i||!e&&i.constructor===t?i:typeof t.BYTES_PER_ELEMENT=="number"?new t(i):Array.prototype.slice.call(i)},isTypedArray:function(i){return ArrayBuffer.isView(i)&&!(i instanceof DataView)},getKeyframeOrder:function(i){function t(r,s){return i[r]-i[s]}const e=i.length,n=new Array(e);for(let r=0;r!==e;++r)n[r]=r;return n.sort(t),n},sortedArray:function(i,t,e){const n=i.length,r=new i.constructor(n);for(let s=0,a=0;a!==n;++s){const o=e[s]*t;for(let l=0;l!==t;++l)r[a++]=i[o+l]}return r},flattenJSON:function(i,t,e,n){let r=1,s=i[0];for(;s!==void 0&&s[n]===void 0;)s=i[r++];if(s===void 0)return;let a=s[n];if(a!==void 0)if(Array.isArray(a))do a=s[n],a!==void 0&&(t.push(s.time),e.push.apply(e,a)),s=i[r++];while(s!==void 0);else if(a.toArray!==void 0)do a=s[n],a!==void 0&&(t.push(s.time),a.toArray(e,e.length)),s=i[r++];while(s!==void 0);else do a=s[n],a!==void 0&&(t.push(s.time),e.push(a)),s=i[r++];while(s!==void 0)},subclip:function(i,t,e,n,r=30){const s=i.clone();s.name=t;const a=[];for(let l=0;l<s.tracks.length;++l){const c=s.tracks[l],u=c.getValueSize(),h=[],d=[];for(let m=0;m<c.times.length;++m){const g=c.times[m]*r;if(!(g<e||g>=n)){h.push(c.times[m]);for(let p=0;p<u;++p)d.push(c.values[m*u+p])}}h.length!==0&&(c.times=ne.convertArray(h,c.times.constructor),c.values=ne.convertArray(d,c.values.constructor),a.push(c))}s.tracks=a;let o=1/0;for(let l=0;l<s.tracks.length;++l)o>s.tracks[l].times[0]&&(o=s.tracks[l].times[0]);for(let l=0;l<s.tracks.length;++l)s.tracks[l].shift(-1*o);return s.resetDuration(),s},makeClipAdditive:function(i,t=0,e=i,n=30){n<=0&&(n=30);const r=e.tracks.length,s=t/n;for(let a=0;a<r;++a){const o=e.tracks[a],l=o.ValueTypeName;if(l==="bool"||l==="string")continue;const c=i.tracks.find(function(y){return y.name===o.name&&y.ValueTypeName===l});if(c===void 0)continue;let u=0;const h=o.getValueSize();o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(u=h/3);let d=0;const m=c.getValueSize();c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(d=m/3);const g=o.times.length-1;let p;if(s<=o.times[0]){const y=u,M=h-u;p=ne.arraySlice(o.values,y,M)}else if(s>=o.times[g]){const y=g*h+u,M=y+h-u;p=ne.arraySlice(o.values,y,M)}else{const y=o.createInterpolant(),M=u,E=h-u;y.evaluate(s),p=ne.arraySlice(y.resultBuffer,M,E)}l==="quaternion"&&new Me().fromArray(p).normalize().conjugate().toArray(p);const f=c.times.length;for(let y=0;y<f;++y){const M=y*m+d;if(l==="quaternion")Me.multiplyQuaternionsFlat(c.values,M,p,0,c.values,M);else{const E=m-d*2;for(let R=0;R<E;++R)c.values[M+R]-=p[R]}}}return i.blendMode=Od,i}};class ii{constructor(t,e,n,r){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=r!==void 0?r:new e.constructor(n),this.sampleValues=e,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let n=this._cachedIndex,r=e[n],s=e[n-1];t:{e:{let a;n:{i:if(!(t<r)){for(let o=n+2;;){if(r===void 0){if(t<s)break i;return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,t,s)}if(n===o)break;if(s=r,r=e[++n],t<r)break e}a=e.length;break n}if(!(t>=s)){const o=e[1];t<o&&(n=2,s=o);for(let l=n-2;;){if(s===void 0)return this._cachedIndex=0,this.beforeStart_(0,t,r);if(n===l)break;if(r=s,s=e[--n-1],t>=s)break e}a=n,n=0;break n}break t}for(;n<a;){const o=n+a>>>1;t<e[o]?a=o:n=o+1}if(r=e[n],s=e[n-1],s===void 0)return this._cachedIndex=0,this.beforeStart_(0,t,r);if(r===void 0)return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,s,t)}this._cachedIndex=n,this.intervalChanged_(n,s,r)}return this.interpolate_(n,s,t,r)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,n=this.sampleValues,r=this.valueSize,s=t*r;for(let a=0;a!==r;++a)e[a]=n[s+a];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}ii.prototype.beforeStart_=ii.prototype.copySampleValue_;ii.prototype.afterEnd_=ii.prototype.copySampleValue_;class vb extends ii{constructor(t,e,n,r){super(t,e,n,r);this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:ir,endingEnd:ir}}intervalChanged_(t,e,n){const r=this.parameterPositions;let s=t-2,a=t+1,o=r[s],l=r[a];if(o===void 0)switch(this.getSettings_().endingStart){case rr:s=t,o=2*e-n;break;case Ea:s=r.length-2,o=e+r[s]-r[s+1];break;default:s=t,o=n}if(l===void 0)switch(this.getSettings_().endingEnd){case rr:a=t,l=2*n-e;break;case Ea:a=1,l=n+r[1]-r[0];break;default:a=t-1,l=e}const c=(n-e)*.5,u=this.valueSize;this._weightPrev=c/(e-o),this._weightNext=c/(l-n),this._offsetPrev=s*u,this._offsetNext=a*u}interpolate_(t,e,n,r){const s=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=t*o,c=l-o,u=this._offsetPrev,h=this._offsetNext,d=this._weightPrev,m=this._weightNext,g=(n-e)/(r-e),p=g*g,f=p*g,y=-d*f+2*d*p-d*g,M=(1+d)*f+(-1.5-2*d)*p+(-.5+d)*g+1,E=(-1-m)*f+(1.5+m)*p+.5*g,R=m*f-m*p;for(let b=0;b!==o;++b)s[b]=y*a[u+b]+M*a[c+b]+E*a[l+b]+R*a[h+b];return s}}class Ef extends ii{constructor(t,e,n,r){super(t,e,n,r)}interpolate_(t,e,n,r){const s=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=t*o,c=l-o,u=(n-e)/(r-e),h=1-u;for(let d=0;d!==o;++d)s[d]=a[c+d]*h+a[l+d]*u;return s}}class bb extends ii{constructor(t,e,n,r){super(t,e,n,r)}interpolate_(t){return this.copySampleValue_(t-1)}}class xn{constructor(t,e,n,r){if(t===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(e===void 0||e.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=ne.convertArray(e,this.TimeBufferType),this.values=ne.convertArray(n,this.ValueBufferType),this.setInterpolation(r||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let n;if(e.toJSON!==this.toJSON)n=e.toJSON(t);else{n={name:t.name,times:ne.convertArray(t.times,Array),values:ne.convertArray(t.values,Array)};const r=t.getInterpolation();r!==t.DefaultInterpolation&&(n.interpolation=r)}return n.type=t.ValueTypeName,n}InterpolantFactoryMethodDiscrete(t){return new bb(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new Ef(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new vb(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case ka:e=this.InterpolantFactoryMethodDiscrete;break;case Ra:e=this.InterpolantFactoryMethodLinear;break;case xo:e=this.InterpolantFactoryMethodSmooth;break}if(e===void 0){const n="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(t!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(n);return console.warn("THREE.KeyframeTrack:",n),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return ka;case this.InterpolantFactoryMethodLinear:return Ra;case this.InterpolantFactoryMethodSmooth:return xo}}getValueSize(){return this.values.length/this.times.length}shift(t){if(t!==0){const e=this.times;for(let n=0,r=e.length;n!==r;++n)e[n]+=t}return this}scale(t){if(t!==1){const e=this.times;for(let n=0,r=e.length;n!==r;++n)e[n]*=t}return this}trim(t,e){const n=this.times,r=n.length;let s=0,a=r-1;for(;s!==r&&n[s]<t;)++s;for(;a!==-1&&n[a]>e;)--a;if(++a,s!==0||a!==r){s>=a&&(a=Math.max(a,1),s=a-1);const o=this.getValueSize();this.times=ne.arraySlice(n,s,a),this.values=ne.arraySlice(this.values,s*o,a*o)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const n=this.times,r=this.values,s=n.length;s===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let a=null;for(let o=0;o!==s;o++){const l=n[o];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,o,l),t=!1;break}if(a!==null&&a>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,o,l,a),t=!1;break}a=l}if(r!==void 0&&ne.isTypedArray(r))for(let o=0,l=r.length;o!==l;++o){const c=r[o];if(isNaN(c)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,o,c),t=!1;break}}return t}optimize(){const t=ne.arraySlice(this.times),e=ne.arraySlice(this.values),n=this.getValueSize(),r=this.getInterpolation()===xo,s=t.length-1;let a=1;for(let o=1;o<s;++o){let l=!1;const c=t[o],u=t[o+1];if(c!==u&&(o!==1||c!==t[0]))if(r)l=!0;else{const h=o*n,d=h-n,m=h+n;for(let g=0;g!==n;++g){const p=e[h+g];if(p!==e[d+g]||p!==e[m+g]){l=!0;break}}}if(l){if(o!==a){t[a]=t[o];const h=o*n,d=a*n;for(let m=0;m!==n;++m)e[d+m]=e[h+m]}++a}}if(s>0){t[a]=t[s];for(let o=s*n,l=a*n,c=0;c!==n;++c)e[l+c]=e[o+c];++a}return a!==t.length?(this.times=ne.arraySlice(t,0,a),this.values=ne.arraySlice(e,0,a*n)):(this.times=t,this.values=e),this}clone(){const t=ne.arraySlice(this.times,0),e=ne.arraySlice(this.values,0),n=this.constructor,r=new n(this.name,t,e);return r.createInterpolant=this.createInterpolant,r}}xn.prototype.TimeBufferType=Float32Array;xn.prototype.ValueBufferType=Float32Array;xn.prototype.DefaultInterpolation=Ra;class Lr extends xn{}Lr.prototype.ValueTypeName="bool";Lr.prototype.ValueBufferType=Array;Lr.prototype.DefaultInterpolation=ka;Lr.prototype.InterpolantFactoryMethodLinear=void 0;Lr.prototype.InterpolantFactoryMethodSmooth=void 0;class Wf extends xn{}Wf.prototype.ValueTypeName="color";class Na extends xn{}Na.prototype.ValueTypeName="number";class Tb extends ii{constructor(t,e,n,r){super(t,e,n,r)}interpolate_(t,e,n,r){const s=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=(n-e)/(r-e);let c=t*o;for(let u=c+o;c!==u;c+=4)Me.slerpFlat(s,0,a,c-o,a,c,l);return s}}class ws extends xn{InterpolantFactoryMethodLinear(t){return new Tb(this.times,this.values,this.getValueSize(),t)}}ws.prototype.ValueTypeName="quaternion";ws.prototype.DefaultInterpolation=Ra;ws.prototype.InterpolantFactoryMethodSmooth=void 0;class Nr extends xn{}Nr.prototype.ValueTypeName="string";Nr.prototype.ValueBufferType=Array;Nr.prototype.DefaultInterpolation=ka;Nr.prototype.InterpolantFactoryMethodLinear=void 0;Nr.prototype.InterpolantFactoryMethodSmooth=void 0;class Va extends xn{}Va.prototype.ValueTypeName="vector";class Nh{constructor(t,e=-1,n,r=sc){this.name=t,this.tracks=n,this.duration=e,this.blendMode=r,this.uuid=rn(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],n=t.tracks,r=1/(t.fps||1);for(let a=0,o=n.length;a!==o;++a)e.push(wb(n[a]).scale(r));const s=new this(t.name,t.duration,e,t.blendMode);return s.uuid=t.uuid,s}static toJSON(t){const e=[],n=t.tracks,r={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let s=0,a=n.length;s!==a;++s)e.push(xn.toJSON(n[s]));return r}static CreateFromMorphTargetSequence(t,e,n,r){const s=e.length,a=[];for(let o=0;o<s;o++){let l=[],c=[];l.push((o+s-1)%s,o,(o+1)%s),c.push(0,1,0);const u=ne.getKeyframeOrder(l);l=ne.sortedArray(l,1,u),c=ne.sortedArray(c,1,u),!r&&l[0]===0&&(l.push(s),c.push(c[0])),a.push(new Na(".morphTargetInfluences["+e[o].name+"]",l,c).scale(1/n))}return new this(t,-1,a)}static findByName(t,e){let n=t;if(!Array.isArray(t)){const r=t;n=r.geometry&&r.geometry.animations||r.animations}for(let r=0;r<n.length;r++)if(n[r].name===e)return n[r];return null}static CreateClipsFromMorphTargetSequences(t,e,n){const r={},s=/^([\w-]*?)([\d]+)$/;for(let o=0,l=t.length;o<l;o++){const c=t[o],u=c.name.match(s);if(u&&u.length>1){const h=u[1];let d=r[h];d||(r[h]=d=[]),d.push(c)}}const a=[];for(const o in r)a.push(this.CreateFromMorphTargetSequence(o,r[o],e,n));return a}static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(h,d,m,g,p){if(m.length!==0){const f=[],y=[];ne.flattenJSON(m,f,y,g),f.length!==0&&p.push(new h(d,f,y))}},r=[],s=t.name||"default",a=t.fps||30,o=t.blendMode;let l=t.length||-1;const c=t.hierarchy||[];for(let h=0;h<c.length;h++){const d=c[h].keys;if(!(!d||d.length===0))if(d[0].morphTargets){const m={};let g;for(g=0;g<d.length;g++)if(d[g].morphTargets)for(let p=0;p<d[g].morphTargets.length;p++)m[d[g].morphTargets[p]]=-1;for(const p in m){const f=[],y=[];for(let M=0;M!==d[g].morphTargets.length;++M){const E=d[g];f.push(E.time),y.push(E.morphTarget===p?1:0)}r.push(new Na(".morphTargetInfluence["+p+"]",f,y))}l=m.length*a}else{const m=".bones["+e[h].name+"]";n(Va,m+".position",d,"pos",r),n(ws,m+".quaternion",d,"rot",r),n(Va,m+".scale",d,"scl",r)}}return r.length===0?null:new this(s,l,r,o)}resetDuration(){const t=this.tracks;let e=0;for(let n=0,r=t.length;n!==r;++n){const s=this.tracks[n];e=Math.max(e,s.times[s.times.length-1])}return this.duration=e,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function Mb(i){switch(i.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Na;case"vector":case"vector2":case"vector3":case"vector4":return Va;case"color":return Wf;case"quaternion":return ws;case"bool":case"boolean":return Lr;case"string":return Nr}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+i)}function wb(i){if(i.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=Mb(i.type);if(i.times===void 0){const e=[],n=[];ne.flattenJSON(i.keys,e,n,"value"),i.times=e,i.values=n}return t.parse!==void 0?t.parse(i):new t(i.name,i.times,i.values,i.interpolation)}const vr={enabled:!1,files:{},add:function(i,t){this.enabled!==!1&&(this.files[i]=t)},get:function(i){if(this.enabled!==!1)return this.files[i]},remove:function(i){delete this.files[i]},clear:function(){this.files={}}};class Ib{constructor(t,e,n){const r=this;let s=!1,a=0,o=0,l;const c=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=n,this.itemStart=function(u){o++,s===!1&&r.onStart!==void 0&&r.onStart(u,a,o),s=!0},this.itemEnd=function(u){a++,r.onProgress!==void 0&&r.onProgress(u,a,o),a===o&&(s=!1,r.onLoad!==void 0&&r.onLoad())},this.itemError=function(u){r.onError!==void 0&&r.onError(u)},this.resolveURL=function(u){return l?l(u):u},this.setURLModifier=function(u){return l=u,this},this.addHandler=function(u,h){return c.push(u,h),this},this.removeHandler=function(u){const h=c.indexOf(u);return h!==-1&&c.splice(h,2),this},this.getHandler=function(u){for(let h=0,d=c.length;h<d;h+=2){const m=c[h],g=c[h+1];if(m.global&&(m.lastIndex=0),m.test(u))return g}return null}}}const kb=new Ib;class si{constructor(t){this.manager=t!==void 0?t:kb,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const n=this;return new Promise(function(r,s){n.load(t,r,e,s)})}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}const In={};class Rb extends si{constructor(t){super(t)}load(t,e,n,r){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const s=vr.get(t);if(s!==void 0)return this.manager.itemStart(t),setTimeout(()=>{e&&e(s),this.manager.itemEnd(t)},0),s;if(In[t]!==void 0){In[t].push({onLoad:e,onProgress:n,onError:r});return}In[t]=[],In[t].push({onLoad:e,onProgress:n,onError:r});const a=new Request(t,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),o=this.mimeType,l=this.responseType;fetch(a).then(c=>{if(c.status===200||c.status===0){if(c.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream=="undefined"||c.body===void 0||c.body.getReader===void 0)return c;const u=In[t],h=c.body.getReader(),d=c.headers.get("Content-Length"),m=d?parseInt(d):0,g=m!==0;let p=0;const f=new ReadableStream({start(y){M();function M(){h.read().then(({done:E,value:R})=>{if(E)y.close();else{p+=R.byteLength;const b=new ProgressEvent("progress",{lengthComputable:g,loaded:p,total:m});for(let D=0,U=u.length;D<U;D++){const X=u[D];X.onProgress&&X.onProgress(b)}y.enqueue(R),M()}})}}});return new Response(f)}else throw Error(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`)}).then(c=>{switch(l){case"arraybuffer":return c.arrayBuffer();case"blob":return c.blob();case"document":return c.text().then(u=>new DOMParser().parseFromString(u,o));case"json":return c.json();default:if(o===void 0)return c.text();{const h=/charset="?([^;"\s]*)"?/i.exec(o),d=h&&h[1]?h[1].toLowerCase():void 0,m=new TextDecoder(d);return c.arrayBuffer().then(g=>m.decode(g))}}}).then(c=>{vr.add(t,c);const u=In[t];delete In[t];for(let h=0,d=u.length;h<d;h++){const m=u[h];m.onLoad&&m.onLoad(c)}}).catch(c=>{const u=In[t];if(u===void 0)throw this.manager.itemError(t),c;delete In[t];for(let h=0,d=u.length;h<d;h++){const m=u[h];m.onError&&m.onError(c)}this.manager.itemError(t)}).finally(()=>{this.manager.itemEnd(t)}),this.manager.itemStart(t)}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class Cf extends si{constructor(t){super(t)}load(t,e,n,r){this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const s=this,a=vr.get(t);if(a!==void 0)return s.manager.itemStart(t),setTimeout(function(){e&&e(a),s.manager.itemEnd(t)},0),a;const o=ys("img");function l(){u(),vr.add(t,this),e&&e(this),s.manager.itemEnd(t)}function c(h){u(),r&&r(h),s.manager.itemError(t),s.manager.itemEnd(t)}function u(){o.removeEventListener("load",l,!1),o.removeEventListener("error",c,!1)}return o.addEventListener("load",l,!1),o.addEventListener("error",c,!1),t.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(o.crossOrigin=this.crossOrigin),s.manager.itemStart(t),o.src=t,o}}class Eb extends si{constructor(t){super(t)}load(t,e,n,r){const s=new za,a=new Cf(this.manager);a.setCrossOrigin(this.crossOrigin),a.setPath(this.path);let o=0;function l(c){a.load(t[c],function(u){s.images[c]=u,o++,o===6&&(s.needsUpdate=!0,e&&e(s))},void 0,r)}for(let c=0;c<t.length;++c)l(c);return s}}class Lf extends si{constructor(t){super(t)}load(t,e,n,r){const s=new ge,a=new Cf(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(t,function(o){s.image=o,s.needsUpdate=!0,e!==void 0&&e(s)},n,r),s}}class Sn extends Qt{constructor(t,e=1){super();this.type="Light",this.color=new Mt(t),this.intensity=e}dispose(){}copy(t){return super.copy(t),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),e}}Sn.prototype.isLight=!0;class Wb extends Sn{constructor(t,e,n){super(t,n);this.type="HemisphereLight",this.position.copy(Qt.DefaultUp),this.updateMatrix(),this.groundColor=new Mt(e)}copy(t){return Sn.prototype.copy.call(this,t),this.groundColor.copy(t.groundColor),this}}Wb.prototype.isHemisphereLight=!0;const Vh=new It,Uh=new k,Ph=new k;class Tc{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new ct(512,512),this.map=null,this.mapPass=null,this.matrix=new It,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Qa,this._frameExtents=new ct(1,1),this._viewportCount=1,this._viewports=[new Kt(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,n=this.matrix;Uh.setFromMatrixPosition(t.matrixWorld),e.position.copy(Uh),Ph.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(Ph),e.updateMatrixWorld(),Vh.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Vh),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(e.projectionMatrix),n.multiply(e.matrixWorldInverse)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const t={};return this.bias!==0&&(t.bias=this.bias),this.normalBias!==0&&(t.normalBias=this.normalBias),this.radius!==1&&(t.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class Nf extends Tc{constructor(){super(new Te(50,1,.5,500));this.focus=1}updateMatrices(t){const e=this.camera,n=gs*2*t.angle*this.focus,r=this.mapSize.width/this.mapSize.height,s=t.distance||e.far;(n!==e.fov||r!==e.aspect||s!==e.far)&&(e.fov=n,e.aspect=r,e.far=s,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}Nf.prototype.isSpotLightShadow=!0;class Cb extends Sn{constructor(t,e,n=0,r=Math.PI/3,s=0,a=1){super(t,e);this.type="SpotLight",this.position.copy(Qt.DefaultUp),this.updateMatrix(),this.target=new Qt,this.distance=n,this.angle=r,this.penumbra=s,this.decay=a,this.shadow=new Nf}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}Cb.prototype.isSpotLight=!0;const Dh=new It,Gr=new k,$o=new k;class Vf extends Tc{constructor(){super(new Te(90,1,.5,500));this._frameExtents=new ct(4,2),this._viewportCount=6,this._viewports=[new Kt(2,1,1,1),new Kt(0,1,1,1),new Kt(3,1,1,1),new Kt(1,1,1,1),new Kt(3,0,1,1),new Kt(1,0,1,1)],this._cubeDirections=[new k(1,0,0),new k(-1,0,0),new k(0,0,1),new k(0,0,-1),new k(0,1,0),new k(0,-1,0)],this._cubeUps=[new k(0,1,0),new k(0,1,0),new k(0,1,0),new k(0,1,0),new k(0,0,1),new k(0,0,-1)]}updateMatrices(t,e=0){const n=this.camera,r=this.matrix,s=t.distance||n.far;s!==n.far&&(n.far=s,n.updateProjectionMatrix()),Gr.setFromMatrixPosition(t.matrixWorld),n.position.copy(Gr),$o.copy(n.position),$o.add(this._cubeDirections[e]),n.up.copy(this._cubeUps[e]),n.lookAt($o),n.updateMatrixWorld(),r.makeTranslation(-Gr.x,-Gr.y,-Gr.z),Dh.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Dh)}}Vf.prototype.isPointLightShadow=!0;class Lb extends Sn{constructor(t,e,n=0,r=1){super(t,e);this.type="PointLight",this.distance=n,this.decay=r,this.shadow=new Vf}get power(){return this.intensity*4*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}Lb.prototype.isPointLight=!0;class Uf extends Tc{constructor(){super(new cc(-5,5,5,-5,.5,500))}}Uf.prototype.isDirectionalLightShadow=!0;class Nb extends Sn{constructor(t,e){super(t,e);this.type="DirectionalLight",this.position.copy(Qt.DefaultUp),this.updateMatrix(),this.target=new Qt,this.shadow=new Uf}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}Nb.prototype.isDirectionalLight=!0;class Vb extends Sn{constructor(t,e){super(t,e);this.type="AmbientLight"}}Vb.prototype.isAmbientLight=!0;class Ub extends Sn{constructor(t,e,n=10,r=10){super(t,e);this.type="RectAreaLight",this.width=n,this.height=r}get power(){return this.intensity*this.width*this.height*Math.PI}set power(t){this.intensity=t/(this.width*this.height*Math.PI)}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}}Ub.prototype.isRectAreaLight=!0;class Pf{constructor(){this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new k)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const n=t.x,r=t.y,s=t.z,a=this.coefficients;return e.copy(a[0]).multiplyScalar(.282095),e.addScaledVector(a[1],.488603*r),e.addScaledVector(a[2],.488603*s),e.addScaledVector(a[3],.488603*n),e.addScaledVector(a[4],1.092548*(n*r)),e.addScaledVector(a[5],1.092548*(r*s)),e.addScaledVector(a[6],.315392*(3*s*s-1)),e.addScaledVector(a[7],1.092548*(n*s)),e.addScaledVector(a[8],.546274*(n*n-r*r)),e}getIrradianceAt(t,e){const n=t.x,r=t.y,s=t.z,a=this.coefficients;return e.copy(a[0]).multiplyScalar(.886227),e.addScaledVector(a[1],2*.511664*r),e.addScaledVector(a[2],2*.511664*s),e.addScaledVector(a[3],2*.511664*n),e.addScaledVector(a[4],2*.429043*n*r),e.addScaledVector(a[5],2*.429043*r*s),e.addScaledVector(a[6],.743125*s*s-.247708),e.addScaledVector(a[7],2*.429043*n*s),e.addScaledVector(a[8],.429043*(n*n-r*r)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(t.coefficients[n],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let n=0;n<9;n++)this.coefficients[n].lerp(t.coefficients[n],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(t,e=0){const n=this.coefficients;for(let r=0;r<9;r++)n[r].fromArray(t,e+r*3);return this}toArray(t=[],e=0){const n=this.coefficients;for(let r=0;r<9;r++)n[r].toArray(t,e+r*3);return t}static getBasisAt(t,e){const n=t.x,r=t.y,s=t.z;e[0]=.282095,e[1]=.488603*r,e[2]=.488603*s,e[3]=.488603*n,e[4]=1.092548*n*r,e[5]=1.092548*r*s,e[6]=.315392*(3*s*s-1),e[7]=1.092548*n*s,e[8]=.546274*(n*n-r*r)}}Pf.prototype.isSphericalHarmonics3=!0;class Mc extends Sn{constructor(t=new Pf,e=1){super(void 0,e);this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}fromJSON(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this}toJSON(t){const e=super.toJSON(t);return e.object.sh=this.sh.toArray(),e}}Mc.prototype.isLightProbe=!0;class Pb{static decodeText(t){if(typeof TextDecoder!="undefined")return new TextDecoder().decode(t);let e="";for(let n=0,r=t.length;n<r;n++)e+=String.fromCharCode(t[n]);try{return decodeURIComponent(escape(e))}catch{return e}}static extractUrlBase(t){const e=t.lastIndexOf("/");return e===-1?"./":t.slice(0,e+1)}static resolveURL(t,e){return typeof t!="string"||t===""?"":(/^https?:\/\//i.test(e)&&/^\//.test(t)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(t)||/^data:.*,.*$/i.test(t)||/^blob:.*$/i.test(t)?t:e+t)}}class Db extends te{constructor(){super();this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}clone(){return new this.constructor().copy(this)}toJSON(){const t=super.toJSON(this);return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}Db.prototype.isInstancedBufferGeometry=!0;class Fb extends si{constructor(t){super(t);typeof createImageBitmap=="undefined"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch=="undefined"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,e,n,r){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const s=this,a=vr.get(t);if(a!==void 0)return s.manager.itemStart(t),setTimeout(function(){e&&e(a),s.manager.itemEnd(t)},0),a;const o={};o.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",o.headers=this.requestHeader,fetch(t,o).then(function(l){return l.blob()}).then(function(l){return createImageBitmap(l,Object.assign(s.options,{colorSpaceConversion:"none"}))}).then(function(l){vr.add(t,l),e&&e(l),s.manager.itemEnd(t)}).catch(function(l){r&&r(l),s.manager.itemError(t),s.manager.itemEnd(t)}),s.manager.itemStart(t)}}Fb.prototype.isImageBitmapLoader=!0;let ha;const Bb={getContext:function(){return ha===void 0&&(ha=new(window.AudioContext||window.webkitAudioContext)),ha},setContext:function(i){ha=i}};class Hb extends si{constructor(t){super(t)}load(t,e,n,r){const s=this,a=new Rb(this.manager);a.setResponseType("arraybuffer"),a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(t,function(o){try{const l=o.slice(0);Bb.getContext().decodeAudioData(l,function(u){e(u)})}catch(l){r?r(l):console.error(l),s.manager.itemError(t)}},n,r)}}class qb extends Mc{constructor(t,e,n=1){super(void 0,n);const r=new Mt().set(t),s=new Mt().set(e),a=new k(r.r,r.g,r.b),o=new k(s.r,s.g,s.b),l=Math.sqrt(Math.PI),c=l*Math.sqrt(.75);this.sh.coefficients[0].copy(a).add(o).multiplyScalar(l),this.sh.coefficients[1].copy(a).sub(o).multiplyScalar(c)}}qb.prototype.isHemisphereLightProbe=!0;class Jb extends Mc{constructor(t,e=1){super(void 0,e);const n=new Mt().set(t);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}}Jb.prototype.isAmbientLightProbe=!0;class Ob extends Qt{constructor(t){super();this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+t;const e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(t){return t||(t=[]),this._connected===!0?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){if(this.detune=t,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=t,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=t,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}}class Gb{constructor(t,e,n){this.binding=t,this.valueSize=n;let r,s,a;switch(e){case"quaternion":r=this._slerp,s=this._slerpAdditive,a=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(n*6),this._workIndex=5;break;case"string":case"bool":r=this._select,s=this._select,a=this._setAdditiveIdentityOther,this.buffer=new Array(n*5);break;default:r=this._lerp,s=this._lerpAdditive,a=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(n*5)}this._mixBufferRegion=r,this._mixBufferRegionAdditive=s,this._setIdentity=a,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const n=this.buffer,r=this.valueSize,s=t*r+r;let a=this.cumulativeWeight;if(a===0){for(let o=0;o!==r;++o)n[s+o]=n[o];a=e}else{a+=e;const o=e/a;this._mixBufferRegion(n,s,0,o,r)}this.cumulativeWeight=a}accumulateAdditive(t){const e=this.buffer,n=this.valueSize,r=n*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(e,r,0,t,n),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,n=this.buffer,r=t*e+e,s=this.cumulativeWeight,a=this.cumulativeWeightAdditive,o=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,s<1){const l=e*this._origIndex;this._mixBufferRegion(n,r,l,1-s,e)}a>0&&this._mixBufferRegionAdditive(n,r,this._addIndex*e,1,e);for(let l=e,c=e+e;l!==c;++l)if(n[l]!==n[l+e]){o.setValue(n,r);break}}saveOriginalState(){const t=this.binding,e=this.buffer,n=this.valueSize,r=n*this._origIndex;t.getValue(e,r);for(let s=n,a=r;s!==a;++s)e[s]=e[r+s%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=this.valueSize*3;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let n=t;n<e;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[e+n]=this.buffer[t+n]}_select(t,e,n,r,s){if(r>=.5)for(let a=0;a!==s;++a)t[e+a]=t[n+a]}_slerp(t,e,n,r){Me.slerpFlat(t,e,t,e,t,n,r)}_slerpAdditive(t,e,n,r,s){const a=this._workIndex*s;Me.multiplyQuaternionsFlat(t,a,t,e,t,n),Me.slerpFlat(t,e,t,e,t,a,r)}_lerp(t,e,n,r,s){const a=1-r;for(let o=0;o!==s;++o){const l=e+o;t[l]=t[l]*a+t[n+o]*r}}_lerpAdditive(t,e,n,r,s){for(let a=0;a!==s;++a){const o=e+a;t[o]=t[o]+t[n+a]*r}}}const wc="\\[\\]\\.:\\/",jb=new RegExp("["+wc+"]","g"),Ic="[^"+wc+"]",Xb="[^"+wc.replace("\\.","")+"]",Kb=/((?:WC+[\/:])*)/.source.replace("WC",Ic),Zb=/(WCOD+)?/.source.replace("WCOD",Xb),zb=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Ic),Qb=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Ic),_b=new RegExp("^"+Kb+Zb+zb+Qb+"$"),Yb=["material","materials","bones"];class $b{constructor(t,e,n){const r=n||zt.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,r)}getValue(t,e){this.bind();const n=this._targetGroup.nCachedObjects_,r=this._bindings[n];r!==void 0&&r.getValue(t,e)}setValue(t,e){const n=this._bindings;for(let r=this._targetGroup.nCachedObjects_,s=n.length;r!==s;++r)n[r].setValue(t,e)}bind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].bind()}unbind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].unbind()}}class zt{constructor(t,e,n){this.path=e,this.parsedPath=n||zt.parseTrackName(e),this.node=zt.findNode(t,this.parsedPath.nodeName)||t,this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,n){return t&&t.isAnimationObjectGroup?new zt.Composite(t,e,n):new zt(t,e,n)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(jb,"")}static parseTrackName(t){const e=_b.exec(t);if(e===null)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const n={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},r=n.nodeName&&n.nodeName.lastIndexOf(".");if(r!==void 0&&r!==-1){const s=n.nodeName.substring(r+1);Yb.indexOf(s)!==-1&&(n.nodeName=n.nodeName.substring(0,r),n.objectName=s)}if(n.propertyName===null||n.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return n}static findNode(t,e){if(e===void 0||e===""||e==="."||e===-1||e===t.name||e===t.uuid)return t;if(t.skeleton){const n=t.skeleton.getBoneByName(e);if(n!==void 0)return n}if(t.children){const n=function(s){for(let a=0;a<s.length;a++){const o=s[a];if(o.name===e||o.uuid===e)return o;const l=n(o.children);if(l)return l}return null},r=n(t.children);if(r)return r}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){const n=this.resolvedProperty;for(let r=0,s=n.length;r!==s;++r)t[e++]=n[r]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const n=this.resolvedProperty;for(let r=0,s=n.length;r!==s;++r)n[r]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const n=this.resolvedProperty;for(let r=0,s=n.length;r!==s;++r)n[r]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const n=this.resolvedProperty;for(let r=0,s=n.length;r!==s;++r)n[r]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,n=e.objectName,r=e.propertyName;let s=e.propertyIndex;if(t||(t=zt.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(n){let c=e.objectIndex;switch(n){case"materials":if(!t.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!t.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}t=t.material.materials;break;case"bones":if(!t.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}t=t.skeleton.bones;for(let u=0;u<t.length;u++)if(t[u].name===c){c=u;break}break;default:if(t[n]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}t=t[n]}if(c!==void 0){if(t[c]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);return}t=t[c]}}const a=t[r];if(a===void 0){const c=e.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+c+"."+r+" but it wasn't found.",t);return}let o=this.Versioning.None;this.targetObject=t,t.needsUpdate!==void 0?o=this.Versioning.NeedsUpdate:t.matrixWorldNeedsUpdate!==void 0&&(o=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(s!==void 0){if(r==="morphTargetInfluences"){if(!t.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(t.geometry.isBufferGeometry){if(!t.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}t.morphTargetDictionary[s]!==void 0&&(s=t.morphTargetDictionary[s])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}l=this.BindingType.ArrayElement,this.resolvedProperty=a,this.propertyIndex=s}else a.fromArray!==void 0&&a.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=a):Array.isArray(a)?(l=this.BindingType.EntireArray,this.resolvedProperty=a):this.propertyName=r;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][o]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}zt.Composite=$b;zt.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};zt.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};zt.prototype.GetterByBindingType=[zt.prototype._getValue_direct,zt.prototype._getValue_array,zt.prototype._getValue_arrayElement,zt.prototype._getValue_toArray];zt.prototype.SetterByBindingTypeAndVersioning=[[zt.prototype._setValue_direct,zt.prototype._setValue_direct_setNeedsUpdate,zt.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[zt.prototype._setValue_array,zt.prototype._setValue_array_setNeedsUpdate,zt.prototype._setValue_array_setMatrixWorldNeedsUpdate],[zt.prototype._setValue_arrayElement,zt.prototype._setValue_arrayElement_setNeedsUpdate,zt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[zt.prototype._setValue_fromArray,zt.prototype._setValue_fromArray_setNeedsUpdate,zt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class t1{constructor(t,e,n=null,r=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=n,this.blendMode=r;const s=e.tracks,a=s.length,o=new Array(a),l={endingStart:ir,endingEnd:ir};for(let c=0;c!==a;++c){const u=s[c].createInterpolant(null);o[c]=u,u.settings=l}this._interpolantSettings=l,this._interpolants=o,this._propertyBindings=new Array(a),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=Iy,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,n){if(t.fadeOut(e),this.fadeIn(e),n){const r=this._clip.duration,s=t._clip.duration,a=s/r,o=r/s;t.warp(1,a,e),this.warp(o,1,e)}return this}crossFadeTo(t,e,n){return t.crossFadeFrom(this,e,n)}stopFading(){const t=this._weightInterpolant;return t!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,n){const r=this._mixer,s=r.time,a=this.timeScale;let o=this._timeScaleInterpolant;o===null&&(o=r._lendControlInterpolant(),this._timeScaleInterpolant=o);const l=o.parameterPositions,c=o.sampleValues;return l[0]=s,l[1]=s+n,c[0]=t/a,c[1]=e/a,this}stopWarping(){const t=this._timeScaleInterpolant;return t!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,n,r){if(!this.enabled){this._updateWeight(t);return}const s=this._startTime;if(s!==null){const l=(t-s)*n;if(l<0||n===0)return;this._startTime=null,e=n*l}e*=this._updateTimeScale(t);const a=this._updateTime(e),o=this._updateWeight(t);if(o>0){const l=this._interpolants,c=this._propertyBindings;switch(this.blendMode){case Od:for(let u=0,h=l.length;u!==h;++u)l[u].evaluate(a),c[u].accumulateAdditive(o);break;case sc:default:for(let u=0,h=l.length;u!==h;++u)l[u].evaluate(a),c[u].accumulate(r,o)}}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const n=this._weightInterpolant;if(n!==null){const r=n.evaluate(t)[0];e*=r,t>n.parameterPositions[1]&&(this.stopFading(),r===0&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const n=this._timeScaleInterpolant;n!==null&&(e*=n.evaluate(t)[0],t>n.parameterPositions[1]&&(this.stopWarping(),e===0?this.paused=!0:this.timeScale=e))}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,n=this.loop;let r=this.time+t,s=this._loopCount;const a=n===ky;if(t===0)return s===-1?r:a&&(s&1)===1?e-r:r;if(n===wy){s===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(r>=e)r=e;else if(r<0)r=0;else{this.time=r;break t}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(s===-1&&(t>=0?(s=0,this._setEndings(!0,this.repetitions===0,a)):this._setEndings(this.repetitions===0,!0,a)),r>=e||r<0){const o=Math.floor(r/e);r-=e*o,s+=Math.abs(o);const l=this.repetitions-s;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,r=t>0?e:0,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(l===1){const c=t<0;this._setEndings(c,!c,a)}else this._setEndings(!1,!1,a);this._loopCount=s,this.time=r,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:o})}}else this.time=r;if(a&&(s&1)===1)return e-r}return r}_setEndings(t,e,n){const r=this._interpolantSettings;n?(r.endingStart=rr,r.endingEnd=rr):(t?r.endingStart=this.zeroSlopeAtStart?rr:ir:r.endingStart=Ea,e?r.endingEnd=this.zeroSlopeAtEnd?rr:ir:r.endingEnd=Ea)}_scheduleFading(t,e,n){const r=this._mixer,s=r.time;let a=this._weightInterpolant;a===null&&(a=r._lendControlInterpolant(),this._weightInterpolant=a);const o=a.parameterPositions,l=a.sampleValues;return o[0]=s,l[0]=e,o[1]=s+t,l[1]=n,this}}class e1 extends ri{constructor(t){super();this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,e){const n=t._localRoot||this._root,r=t._clip.tracks,s=r.length,a=t._propertyBindings,o=t._interpolants,l=n.uuid,c=this._bindingsByRootAndName;let u=c[l];u===void 0&&(u={},c[l]=u);for(let h=0;h!==s;++h){const d=r[h],m=d.name;let g=u[m];if(g!==void 0)++g.referenceCount,a[h]=g;else{if(g=a[h],g!==void 0){g._cacheIndex===null&&(++g.referenceCount,this._addInactiveBinding(g,l,m));continue}const p=e&&e._propertyBindings[h].binding.parsedPath;g=new Gb(zt.create(n,m,p),d.ValueTypeName,d.getValueSize()),++g.referenceCount,this._addInactiveBinding(g,l,m),a[h]=g}o[h].resultBuffer=g.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(t._cacheIndex===null){const n=(t._localRoot||this._root).uuid,r=t._clip.uuid,s=this._actionsByClip[r];this._bindAction(t,s&&s.knownActions[0]),this._addInactiveAction(t,r,n)}const e=t._propertyBindings;for(let n=0,r=e.length;n!==r;++n){const s=e[n];s.useCount++===0&&(this._lendBinding(s),s.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let n=0,r=e.length;n!==r;++n){const s=e[n];--s.useCount===0&&(s.restoreOriginalState(),this._takeBackBinding(s))}this._takeBackAction(t)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}_isActiveAction(t){const e=t._cacheIndex;return e!==null&&e<this._nActiveActions}_addInactiveAction(t,e,n){const r=this._actions,s=this._actionsByClip;let a=s[e];if(a===void 0)a={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,s[e]=a;else{const o=a.knownActions;t._byClipCacheIndex=o.length,o.push(t)}t._cacheIndex=r.length,r.push(t),a.actionByRoot[n]=t}_removeInactiveAction(t){const e=this._actions,n=e[e.length-1],r=t._cacheIndex;n._cacheIndex=r,e[r]=n,e.pop(),t._cacheIndex=null;const s=t._clip.uuid,a=this._actionsByClip,o=a[s],l=o.knownActions,c=l[l.length-1],u=t._byClipCacheIndex;c._byClipCacheIndex=u,l[u]=c,l.pop(),t._byClipCacheIndex=null;const h=o.actionByRoot,d=(t._localRoot||this._root).uuid;delete h[d],l.length===0&&delete a[s],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){const e=t._propertyBindings;for(let n=0,r=e.length;n!==r;++n){const s=e[n];--s.referenceCount===0&&this._removeInactiveBinding(s)}}_lendAction(t){const e=this._actions,n=t._cacheIndex,r=this._nActiveActions++,s=e[r];t._cacheIndex=r,e[r]=t,s._cacheIndex=n,e[n]=s}_takeBackAction(t){const e=this._actions,n=t._cacheIndex,r=--this._nActiveActions,s=e[r];t._cacheIndex=r,e[r]=t,s._cacheIndex=n,e[n]=s}_addInactiveBinding(t,e,n){const r=this._bindingsByRootAndName,s=this._bindings;let a=r[e];a===void 0&&(a={},r[e]=a),a[n]=t,t._cacheIndex=s.length,s.push(t)}_removeInactiveBinding(t){const e=this._bindings,n=t.binding,r=n.rootNode.uuid,s=n.path,a=this._bindingsByRootAndName,o=a[r],l=e[e.length-1],c=t._cacheIndex;l._cacheIndex=c,e[c]=l,e.pop(),delete o[s],Object.keys(o).length===0&&delete a[r]}_lendBinding(t){const e=this._bindings,n=t._cacheIndex,r=this._nActiveBindings++,s=e[r];t._cacheIndex=r,e[r]=t,s._cacheIndex=n,e[n]=s}_takeBackBinding(t){const e=this._bindings,n=t._cacheIndex,r=--this._nActiveBindings,s=e[r];t._cacheIndex=r,e[r]=t,s._cacheIndex=n,e[n]=s}_lendControlInterpolant(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let n=t[e];return n===void 0&&(n=new Ef(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=e,t[e]=n),n}_takeBackControlInterpolant(t){const e=this._controlInterpolants,n=t.__cacheIndex,r=--this._nActiveControlInterpolants,s=e[r];t.__cacheIndex=r,e[r]=t,s.__cacheIndex=n,e[n]=s}clipAction(t,e,n){const r=e||this._root,s=r.uuid;let a=typeof t=="string"?Nh.findByName(r,t):t;const o=a!==null?a.uuid:t,l=this._actionsByClip[o];let c=null;if(n===void 0&&(a!==null?n=a.blendMode:n=sc),l!==void 0){const h=l.actionByRoot[s];if(h!==void 0&&h.blendMode===n)return h;c=l.knownActions[0],a===null&&(a=c._clip)}if(a===null)return null;const u=new t1(this,a,e,n);return this._bindAction(u,c),this._addInactiveAction(u,o,s),u}existingAction(t,e){const n=e||this._root,r=n.uuid,s=typeof t=="string"?Nh.findByName(n,t):t,a=s?s.uuid:t,o=this._actionsByClip[a];return o!==void 0&&o.actionByRoot[r]||null}stopAllAction(){const t=this._actions,e=this._nActiveActions;for(let n=e-1;n>=0;--n)t[n].stop();return this}update(t){t*=this.timeScale;const e=this._actions,n=this._nActiveActions,r=this.time+=t,s=Math.sign(t),a=this._accuIndex^=1;for(let c=0;c!==n;++c)e[c]._update(r,t,s,a);const o=this._bindings,l=this._nActiveBindings;for(let c=0;c!==l;++c)o[c].apply(a);return this}setTime(t){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(t)}getRoot(){return this._root}uncacheClip(t){const e=this._actions,n=t.uuid,r=this._actionsByClip,s=r[n];if(s!==void 0){const a=s.knownActions;for(let o=0,l=a.length;o!==l;++o){const c=a[o];this._deactivateAction(c);const u=c._cacheIndex,h=e[e.length-1];c._cacheIndex=null,c._byClipCacheIndex=null,h._cacheIndex=u,e[u]=h,e.pop(),this._removeInactiveBindingsForAction(c)}delete r[n]}}uncacheRoot(t){const e=t.uuid,n=this._actionsByClip;for(const a in n){const o=n[a].actionByRoot,l=o[e];l!==void 0&&(this._deactivateAction(l),this._removeInactiveAction(l))}const r=this._bindingsByRootAndName,s=r[e];if(s!==void 0)for(const a in s){const o=s[a];o.restoreOriginalState(),this._removeInactiveBinding(o)}}uncacheAction(t,e){const n=this.existingAction(t,e);n!==null&&(this._deactivateAction(n),this._removeInactiveAction(n))}}e1.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class n1 extends Ts{constructor(t,e,n=1){super(t,e);this.meshPerAttribute=n}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}clone(t){const e=super.clone(t);return e.meshPerAttribute=this.meshPerAttribute,e}toJSON(t){const e=super.toJSON(t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}n1.prototype.isInstancedInterleavedBuffer=!0;class Fh{constructor(t=1,e=0,n=0){return this.radius=t,this.phi=e,this.theta=n,this}set(t,e,n){return this.radius=t,this.phi=e,this.theta=n,this}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+e*e+n*n),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t,n),this.phi=Math.acos(fe(e/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}const jn=new k,da=new It,tl=new It;class i1 extends mc{constructor(t){const e=Df(t),n=new te,r=[],s=[],a=new Mt(0,0,1),o=new Mt(0,1,0);for(let c=0;c<e.length;c++){const u=e[c];u.parent&&u.parent.isBone&&(r.push(0,0,0),r.push(0,0,0),s.push(a.r,a.g,a.b),s.push(o.r,o.g,o.b))}n.setAttribute("position",new me(r,3)),n.setAttribute("color",new me(s,3));const l=new Wr({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(n,l);this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(t){const e=this.bones,n=this.geometry,r=n.getAttribute("position");tl.copy(this.root.matrixWorld).invert();for(let s=0,a=0;s<e.length;s++){const o=e[s];o.parent&&o.parent.isBone&&(da.multiplyMatrices(tl,o.matrixWorld),jn.setFromMatrixPosition(da),r.setXYZ(a,jn.x,jn.y,jn.z),da.multiplyMatrices(tl,o.parent.matrixWorld),jn.setFromMatrixPosition(da),r.setXYZ(a+1,jn.x,jn.y,jn.z),a+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}}function Df(i){const t=[];i.isBone===!0&&t.push(i);for(let e=0;e<i.children.length;e++)t.push.apply(t,Df(i.children[e]));return t}class r1 extends mc{constructor(t=10,e=10,n=4473924,r=8947848){n=new Mt(n),r=new Mt(r);const s=e/2,a=t/e,o=t/2,l=[],c=[];for(let d=0,m=0,g=-o;d<=e;d++,g+=a){l.push(-o,0,g,o,0,g),l.push(g,0,-o,g,0,o);const p=d===s?n:r;p.toArray(c,m),m+=3,p.toArray(c,m),m+=3,p.toArray(c,m),m+=3,p.toArray(c,m),m+=3}const u=new te;u.setAttribute("position",new me(l,3)),u.setAttribute("color",new me(c,3));const h=new Wr({vertexColors:!0,toneMapped:!1});super(u,h);this.type="GridHelper"}}const hn=new Uint32Array(512),dn=new Uint32Array(512);for(let i=0;i<256;++i){const t=i-127;t<-27?(hn[i]=0,hn[i|256]=32768,dn[i]=24,dn[i|256]=24):t<-14?(hn[i]=1024>>-t-14,hn[i|256]=1024>>-t-14|32768,dn[i]=-t-1,dn[i|256]=-t-1):t<=15?(hn[i]=t+15<<10,hn[i|256]=t+15<<10|32768,dn[i]=13,dn[i|256]=13):t<128?(hn[i]=31744,hn[i|256]=64512,dn[i]=24,dn[i|256]=24):(hn[i]=31744,hn[i|256]=64512,dn[i]=13,dn[i|256]=13)}const Ff=new Uint32Array(2048),Is=new Uint32Array(64),s1=new Uint32Array(64);for(let i=1;i<1024;++i){let t=i<<13,e=0;for(;(t&8388608)===0;)t<<=1,e-=8388608;t&=-8388609,e+=947912704,Ff[i]=t|e}for(let i=1024;i<2048;++i)Ff[i]=939524096+(i-1024<<13);for(let i=1;i<31;++i)Is[i]=i<<23;Is[31]=1199570944;Is[32]=2147483648;for(let i=33;i<63;++i)Is[i]=2147483648+(i-32<<23);Is[63]=3347054592;for(let i=1;i<64;++i)i!==32&&(s1[i]=1024);Ze.create=function(i,t){return console.log("THREE.Curve.create() has been deprecated"),i.prototype=Object.create(Ze.prototype),i.prototype.constructor=i,i.prototype.getPoint=t,i};Cl.prototype.fromPoints=function(i){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(i)};r1.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};i1.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};si.prototype.extractUrlBase=function(i){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),Pb.extractUrlBase(i)};si.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}};sn.prototype.center=function(i){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(i)};sn.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()};sn.prototype.isIntersectionBox=function(i){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(i)};sn.prototype.isIntersectionSphere=function(i){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(i)};sn.prototype.size=function(i){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(i)};ki.prototype.toVector3=function(){console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")};Ir.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()};Qa.prototype.setFromMatrix=function(i){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(i)};xe.prototype.flattenToArrayOffset=function(i,t){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(i,t)};xe.prototype.multiplyVector3=function(i){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),i.applyMatrix3(this)};xe.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")};xe.prototype.applyToBufferAttribute=function(i){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),i.applyMatrix3(this)};xe.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")};xe.prototype.getInverse=function(i){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(i).invert()};It.prototype.extractPosition=function(i){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(i)};It.prototype.flattenToArrayOffset=function(i,t){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(i,t)};It.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new k().setFromMatrixColumn(this,3)};It.prototype.setRotationFromQuaternion=function(i){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(i)};It.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")};It.prototype.multiplyVector3=function(i){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),i.applyMatrix4(this)};It.prototype.multiplyVector4=function(i){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),i.applyMatrix4(this)};It.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")};It.prototype.rotateAxis=function(i){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),i.transformDirection(this)};It.prototype.crossVector=function(i){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),i.applyMatrix4(this)};It.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")};It.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")};It.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")};It.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")};It.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")};It.prototype.applyToBufferAttribute=function(i){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),i.applyMatrix4(this)};It.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")};It.prototype.makeFrustum=function(i,t,e,n,r,s){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(i,t,n,e,r,s)};It.prototype.getInverse=function(i){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(i).invert()};pn.prototype.isIntersectionLine=function(i){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(i)};Me.prototype.multiplyVector3=function(i){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),i.applyQuaternion(this)};Me.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()};kr.prototype.isIntersectionBox=function(i){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(i)};kr.prototype.isIntersectionPlane=function(i){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(i)};kr.prototype.isIntersectionSphere=function(i){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(i)};ce.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()};ce.prototype.barycoordFromPoint=function(i,t){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(i,t)};ce.prototype.midpoint=function(i){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(i)};ce.prototypenormal=function(i){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(i)};ce.prototype.plane=function(i){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(i)};ce.barycoordFromPoint=function(i,t,e,n,r){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),ce.getBarycoord(i,t,e,n,r)};ce.normal=function(i,t,e,n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),ce.getNormal(i,t,e,n)};Ms.prototype.extractAllPoints=function(i){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(i)};Ms.prototype.extrude=function(i){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new Cr(this,i)};Ms.prototype.makeGeometry=function(i){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new vc(this,i)};ct.prototype.fromAttribute=function(i,t,e){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(i,t,e)};ct.prototype.distanceToManhattan=function(i){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(i)};ct.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};k.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")};k.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")};k.prototype.getPositionFromMatrix=function(i){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(i)};k.prototype.getScaleFromMatrix=function(i){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(i)};k.prototype.getColumnFromMatrix=function(i,t){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(t,i)};k.prototype.applyProjection=function(i){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(i)};k.prototype.fromAttribute=function(i,t,e){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(i,t,e)};k.prototype.distanceToManhattan=function(i){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(i)};k.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};Kt.prototype.fromAttribute=function(i,t,e){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(i,t,e)};Kt.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};Qt.prototype.getChildByName=function(i){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(i)};Qt.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")};Qt.prototype.translate=function(i,t){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(t,i)};Qt.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")};Qt.prototype.applyMatrix=function(i){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(i)};Object.defineProperties(Qt.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(i){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=i}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});pe.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")};Object.defineProperties(pe.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),Ry},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}});uf.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")};Te.prototype.setLens=function(i,t){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),t!==void 0&&(this.filmGauge=t),this.setFocalLength(i)};Object.defineProperties(Sn.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(i){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=i}},shadowCameraLeft:{set:function(i){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=i}},shadowCameraRight:{set:function(i){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=i}},shadowCameraTop:{set:function(i){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=i}},shadowCameraBottom:{set:function(i){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=i}},shadowCameraNear:{set:function(i){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=i}},shadowCameraFar:{set:function(i){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=i}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(i){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=i}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(i){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=i}},shadowMapHeight:{set:function(i){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=i}}});Object.defineProperties(re.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===Wa},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(Wa)}}});re.prototype.setDynamic=function(i){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(i===!0?Wa:ms),this};re.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},re.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};te.prototype.addIndex=function(i){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(i)};te.prototype.addAttribute=function(i,t){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),!(t&&t.isBufferAttribute)&&!(t&&t.isInterleavedBufferAttribute)?(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(i,new re(arguments[1],arguments[2]))):i==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(t),this):this.setAttribute(i,t)};te.prototype.addDrawCall=function(i,t,e){e!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(i,t)};te.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()};te.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")};te.prototype.removeAttribute=function(i){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(i)};te.prototype.applyMatrix=function(i){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(i)};Object.defineProperties(te.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}});Ts.prototype.setDynamic=function(i){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(i===!0?Wa:ms),this};Ts.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};Cr.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")};Cr.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")};Cr.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")};Ya.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")};Object.defineProperties(he.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new Mt}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(i){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=i===Fd}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(i){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=i}},vertexTangents:{get:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")},set:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}});Object.defineProperties(Le.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(i){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=i}}});_t.prototype.clearTarget=function(i,t,e,n){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(i),this.clear(t,e,n)};_t.prototype.animate=function(i){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(i)};_t.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()};_t.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()};_t.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision};_t.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()};_t.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")};_t.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")};_t.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")};_t.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")};_t.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")};_t.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")};_t.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures};_t.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")};_t.prototype.enableScissorTest=function(i){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(i)};_t.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")};_t.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")};_t.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")};_t.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")};_t.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")};_t.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")};_t.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")};_t.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")};_t.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")};_t.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()};Object.defineProperties(_t.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(i){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=i}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(i){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=i}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(i){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=i===!0?ee:Vn}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}},gammaFactor:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),2},set:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")}}});Object.defineProperties(af.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}});Object.defineProperties(We.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(i){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=i}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(i){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=i}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(i){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=i}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(i){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=i}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(i){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=i}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(i){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=i}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(i){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=i}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(i){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=i}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(i){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=i}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(i){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=i}}});Ob.prototype.load=function(i){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const t=this;return new Hb().load(i,function(n){t.setBuffer(n)}),this};lc.prototype.updateCubeMap=function(i,t){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(i,t)};lc.prototype.clear=function(i,t,e,n){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(i,t,e,n)};Ii.crossOrigin=void 0;Ii.loadTexture=function(i,t,e,n){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const r=new Lf;r.setCrossOrigin(this.crossOrigin);const s=r.load(i,e,void 0,n);return t&&(s.mapping=t),s};Ii.loadTextureCube=function(i,t,e,n){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const r=new Eb;r.setCrossOrigin(this.crossOrigin);const s=r.load(i,e,void 0,n);return t&&(s.mapping=t),s};Ii.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")};Ii.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:rc}}));typeof window!="undefined"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=rc);const Bh={type:"change"},el={type:"start"},Hh={type:"end"};class a1 extends ri{constructor(t,e){super();e===void 0&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),e===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=t,this.domElement=e,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new k,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:Ci.ROTATE,MIDDLE:Ci.DOLLY,RIGHT:Ci.PAN},this.touches={ONE:Li.ROTATE,TWO:Li.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return o.phi},this.getAzimuthalAngle=function(){return o.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(T){T.addEventListener("keydown",st),this._domElementKeyEvents=T},this.saveState=function(){n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=function(){n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(Bh),n.update(),s=r.NONE},this.update=function(){const T=new k,nt=new Me().setFromUnitVectors(t.up,new k(0,1,0)),bt=nt.clone().invert(),mt=new k,W=new Me,pt=2*Math.PI;return function(){const Tt=n.object.position;T.copy(Tt).sub(n.target),T.applyQuaternion(nt),o.setFromVector3(T),n.autoRotate&&s===r.NONE&&dt(U()),n.enableDamping?(o.theta+=l.theta*n.dampingFactor,o.phi+=l.phi*n.dampingFactor):(o.theta+=l.theta,o.phi+=l.phi);let yt=n.minAzimuthAngle,wt=n.maxAzimuthAngle;return isFinite(yt)&&isFinite(wt)&&(yt<-Math.PI?yt+=pt:yt>Math.PI&&(yt-=pt),wt<-Math.PI?wt+=pt:wt>Math.PI&&(wt-=pt),yt<=wt?o.theta=Math.max(yt,Math.min(wt,o.theta)):o.theta=o.theta>(yt+wt)/2?Math.max(yt,o.theta):Math.min(wt,o.theta)),o.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,o.phi)),o.makeSafe(),o.radius*=c,o.radius=Math.max(n.minDistance,Math.min(n.maxDistance,o.radius)),n.enableDamping===!0?n.target.addScaledVector(u,n.dampingFactor):n.target.add(u),T.setFromSpherical(o),T.applyQuaternion(bt),Tt.copy(n.target).add(T),n.object.lookAt(n.target),n.enableDamping===!0?(l.theta*=1-n.dampingFactor,l.phi*=1-n.dampingFactor,u.multiplyScalar(1-n.dampingFactor)):(l.set(0,0,0),u.set(0,0,0)),c=1,h||mt.distanceToSquared(n.object.position)>a||8*(1-W.dot(n.object.quaternion))>a?(n.dispatchEvent(Bh),mt.copy(n.object.position),W.copy(n.object.quaternion),h=!1,!0):!1}}(),this.dispose=function(){n.domElement.removeEventListener("contextmenu",N),n.domElement.removeEventListener("pointerdown",w),n.domElement.removeEventListener("pointercancel",O),n.domElement.removeEventListener("wheel",rt),n.domElement.removeEventListener("pointermove",V),n.domElement.removeEventListener("pointerup",P),n._domElementKeyEvents!==null&&n._domElementKeyEvents.removeEventListener("keydown",st)};const n=this,r={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let s=r.NONE;const a=1e-6,o=new Fh,l=new Fh;let c=1;const u=new k;let h=!1;const d=new ct,m=new ct,g=new ct,p=new ct,f=new ct,y=new ct,M=new ct,E=new ct,R=new ct,b=[],D={};function U(){return 2*Math.PI/60/60*n.autoRotateSpeed}function X(){return Math.pow(.95,n.zoomSpeed)}function dt(T){l.theta-=T}function K(T){l.phi-=T}const v=function(){const T=new k;return function(bt,mt){T.setFromMatrixColumn(mt,0),T.multiplyScalar(-bt),u.add(T)}}(),C=function(){const T=new k;return function(bt,mt){n.screenSpacePanning===!0?T.setFromMatrixColumn(mt,1):(T.setFromMatrixColumn(mt,0),T.crossVectors(n.object.up,T)),T.multiplyScalar(bt),u.add(T)}}(),it=function(){const T=new k;return function(bt,mt){const W=n.domElement;if(n.object.isPerspectiveCamera){const pt=n.object.position;T.copy(pt).sub(n.target);let gt=T.length();gt*=Math.tan(n.object.fov/2*Math.PI/180),v(2*bt*gt/W.clientHeight,n.object.matrix),C(2*mt*gt/W.clientHeight,n.object.matrix)}else n.object.isOrthographicCamera?(v(bt*(n.object.right-n.object.left)/n.object.zoom/W.clientWidth,n.object.matrix),C(mt*(n.object.top-n.object.bottom)/n.object.zoom/W.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}}();function B(T){n.object.isPerspectiveCamera?c/=T:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom*T)),n.object.updateProjectionMatrix(),h=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function G(T){n.object.isPerspectiveCamera?c*=T:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/T)),n.object.updateProjectionMatrix(),h=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function F(T){d.set(T.clientX,T.clientY)}function H(T){M.set(T.clientX,T.clientY)}function L(T){p.set(T.clientX,T.clientY)}function z(T){m.set(T.clientX,T.clientY),g.subVectors(m,d).multiplyScalar(n.rotateSpeed);const nt=n.domElement;dt(2*Math.PI*g.x/nt.clientHeight),K(2*Math.PI*g.y/nt.clientHeight),d.copy(m),n.update()}function lt(T){E.set(T.clientX,T.clientY),R.subVectors(E,M),R.y>0?B(X()):R.y<0&&G(X()),M.copy(E),n.update()}function ut(T){f.set(T.clientX,T.clientY),y.subVectors(f,p).multiplyScalar(n.panSpeed),it(y.x,y.y),p.copy(f),n.update()}function ht(T){T.deltaY<0?G(X()):T.deltaY>0&&B(X()),n.update()}function At(T){let nt=!1;switch(T.code){case n.keys.UP:it(0,n.keyPanSpeed),nt=!0;break;case n.keys.BOTTOM:it(0,-n.keyPanSpeed),nt=!0;break;case n.keys.LEFT:it(n.keyPanSpeed,0),nt=!0;break;case n.keys.RIGHT:it(-n.keyPanSpeed,0),nt=!0;break}nt&&(T.preventDefault(),n.update())}function Lt(){if(b.length===1)d.set(b[0].pageX,b[0].pageY);else{const T=.5*(b[0].pageX+b[1].pageX),nt=.5*(b[0].pageY+b[1].pageY);d.set(T,nt)}}function kt(){if(b.length===1)p.set(b[0].pageX,b[0].pageY);else{const T=.5*(b[0].pageX+b[1].pageX),nt=.5*(b[0].pageY+b[1].pageY);p.set(T,nt)}}function et(){const T=b[0].pageX-b[1].pageX,nt=b[0].pageY-b[1].pageY,bt=Math.sqrt(T*T+nt*nt);M.set(0,bt)}function Nt(){n.enableZoom&&et(),n.enablePan&&kt()}function Rt(){n.enableZoom&&et(),n.enableRotate&&Lt()}function Et(T){if(b.length==1)m.set(T.pageX,T.pageY);else{const bt=St(T),mt=.5*(T.pageX+bt.x),W=.5*(T.pageY+bt.y);m.set(mt,W)}g.subVectors(m,d).multiplyScalar(n.rotateSpeed);const nt=n.domElement;dt(2*Math.PI*g.x/nt.clientHeight),K(2*Math.PI*g.y/nt.clientHeight),d.copy(m)}function ft(T){if(b.length===1)f.set(T.pageX,T.pageY);else{const nt=St(T),bt=.5*(T.pageX+nt.x),mt=.5*(T.pageY+nt.y);f.set(bt,mt)}y.subVectors(f,p).multiplyScalar(n.panSpeed),it(y.x,y.y),p.copy(f)}function Ct(T){const nt=St(T),bt=T.pageX-nt.x,mt=T.pageY-nt.y,W=Math.sqrt(bt*bt+mt*mt);E.set(0,W),R.set(0,Math.pow(E.y/M.y,n.zoomSpeed)),B(R.y),M.copy(E)}function $(T){n.enableZoom&&Ct(T),n.enablePan&&ft(T)}function x(T){n.enableZoom&&Ct(T),n.enableRotate&&Et(T)}function w(T){n.enabled!==!1&&(b.length===0&&(n.domElement.setPointerCapture(T.pointerId),n.domElement.addEventListener("pointermove",V),n.domElement.addEventListener("pointerup",P)),q(T),T.pointerType==="touch"?S(T):Z(T))}function V(T){n.enabled!==!1&&(T.pointerType==="touch"?A(T):Y(T))}function P(T){tt(T),b.length===0&&(n.domElement.releasePointerCapture(T.pointerId),n.domElement.removeEventListener("pointermove",V),n.domElement.removeEventListener("pointerup",P)),n.dispatchEvent(Hh),s=r.NONE}function O(T){tt(T)}function Z(T){let nt;switch(T.button){case 0:nt=n.mouseButtons.LEFT;break;case 1:nt=n.mouseButtons.MIDDLE;break;case 2:nt=n.mouseButtons.RIGHT;break;default:nt=-1}switch(nt){case Ci.DOLLY:if(n.enableZoom===!1)return;H(T),s=r.DOLLY;break;case Ci.ROTATE:if(T.ctrlKey||T.metaKey||T.shiftKey){if(n.enablePan===!1)return;L(T),s=r.PAN}else{if(n.enableRotate===!1)return;F(T),s=r.ROTATE}break;case Ci.PAN:if(T.ctrlKey||T.metaKey||T.shiftKey){if(n.enableRotate===!1)return;F(T),s=r.ROTATE}else{if(n.enablePan===!1)return;L(T),s=r.PAN}break;default:s=r.NONE}s!==r.NONE&&n.dispatchEvent(el)}function Y(T){if(n.enabled!==!1)switch(s){case r.ROTATE:if(n.enableRotate===!1)return;z(T);break;case r.DOLLY:if(n.enableZoom===!1)return;lt(T);break;case r.PAN:if(n.enablePan===!1)return;ut(T);break}}function rt(T){n.enabled===!1||n.enableZoom===!1||s!==r.NONE||(T.preventDefault(),n.dispatchEvent(el),ht(T),n.dispatchEvent(Hh))}function st(T){n.enabled===!1||n.enablePan===!1||At(T)}function S(T){switch(ot(T),b.length){case 1:switch(n.touches.ONE){case Li.ROTATE:if(n.enableRotate===!1)return;Lt(),s=r.TOUCH_ROTATE;break;case Li.PAN:if(n.enablePan===!1)return;kt(),s=r.TOUCH_PAN;break;default:s=r.NONE}break;case 2:switch(n.touches.TWO){case Li.DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;Nt(),s=r.TOUCH_DOLLY_PAN;break;case Li.DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;Rt(),s=r.TOUCH_DOLLY_ROTATE;break;default:s=r.NONE}break;default:s=r.NONE}s!==r.NONE&&n.dispatchEvent(el)}function A(T){switch(ot(T),s){case r.TOUCH_ROTATE:if(n.enableRotate===!1)return;Et(T),n.update();break;case r.TOUCH_PAN:if(n.enablePan===!1)return;ft(T),n.update();break;case r.TOUCH_DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;$(T),n.update();break;case r.TOUCH_DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;x(T),n.update();break;default:s=r.NONE}}function N(T){n.enabled!==!1&&T.preventDefault()}function q(T){b.push(T)}function tt(T){delete D[T.pointerId];for(let nt=0;nt<b.length;nt++)if(b[nt].pointerId==T.pointerId){b.splice(nt,1);return}}function ot(T){let nt=D[T.pointerId];nt===void 0&&(nt=new ct,D[T.pointerId]=nt),nt.set(T.pageX,T.pageY)}function St(T){const nt=T.pointerId===b[0].pointerId?b[1]:b[0];return D[nt.pointerId]}n.domElement.addEventListener("contextmenu",N),n.domElement.addEventListener("pointerdown",w),n.domElement.addEventListener("pointercancel",O),n.domElement.addEventListener("wheel",rt,{passive:!1}),this.update()}}class Bf extends pe{constructor(t,e={}){super(t);const n=this,r=e.textureWidth!==void 0?e.textureWidth:512,s=e.textureHeight!==void 0?e.textureHeight:512,a=e.clipBias!==void 0?e.clipBias:0,o=e.alpha!==void 0?e.alpha:1,l=e.time!==void 0?e.time:0,c=e.waterNormals!==void 0?e.waterNormals:null,u=e.sunDirection!==void 0?e.sunDirection:new k(.70707,.70707,0),h=new Mt(e.sunColor!==void 0?e.sunColor:16777215),d=new Mt(e.waterColor!==void 0?e.waterColor:8355711),m=e.eye!==void 0?e.eye:new k(0,0,0),g=e.distortionScale!==void 0?e.distortionScale:20,p=e.side!==void 0?e.side:gr,f=e.fog!==void 0?e.fog:!1,y=new pn,M=new k,E=new k,R=new k,b=new It,D=new k(0,0,-1),U=new Kt,X=new k,dt=new k,K=new Kt,v=new It,C=new Te,it=new We(r,s),B={uniforms:La.merge([vt.fog,vt.lights,{normalSampler:{value:null},mirrorSampler:{value:null},alpha:{value:1},time:{value:0},size:{value:1},distortionScale:{value:20},textureMatrix:{value:new It},sunColor:{value:new Mt(8355711)},sunDirection:{value:new k(.70707,.70707,0)},eye:{value:new k},waterColor:{value:new Mt(5592405)}}]),vertexShader:`
				uniform mat4 textureMatrix;
				uniform float time;

				varying vec4 mirrorCoord;
				varying vec4 worldPosition;

				#include <common>
				#include <fog_pars_vertex>
				#include <shadowmap_pars_vertex>
				#include <logdepthbuf_pars_vertex>

				void main() {
					mirrorCoord = modelMatrix * vec4( position, 1.0 );
					worldPosition = mirrorCoord.xyzw;
					mirrorCoord = textureMatrix * mirrorCoord;
					vec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );
					gl_Position = projectionMatrix * mvPosition;

				#include <beginnormal_vertex>
				#include <defaultnormal_vertex>
				#include <logdepthbuf_vertex>
				#include <fog_vertex>
				#include <shadowmap_vertex>
			}`,fragmentShader:`
				uniform sampler2D mirrorSampler;
				uniform float alpha;
				uniform float time;
				uniform float size;
				uniform float distortionScale;
				uniform sampler2D normalSampler;
				uniform vec3 sunColor;
				uniform vec3 sunDirection;
				uniform vec3 eye;
				uniform vec3 waterColor;

				varying vec4 mirrorCoord;
				varying vec4 worldPosition;

				vec4 getNoise( vec2 uv ) {
					vec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);
					vec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );
					vec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );
					vec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );
					vec4 noise = texture2D( normalSampler, uv0 ) +
						texture2D( normalSampler, uv1 ) +
						texture2D( normalSampler, uv2 ) +
						texture2D( normalSampler, uv3 );
					return noise * 0.5 - 1.0;
				}

				void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {
					vec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );
					float direction = max( 0.0, dot( eyeDirection, reflection ) );
					specularColor += pow( direction, shiny ) * sunColor * spec;
					diffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;
				}

				#include <common>
				#include <packing>
				#include <bsdfs>
				#include <fog_pars_fragment>
				#include <logdepthbuf_pars_fragment>
				#include <lights_pars_begin>
				#include <shadowmap_pars_fragment>
				#include <shadowmask_pars_fragment>

				void main() {

					#include <logdepthbuf_fragment>
					vec4 noise = getNoise( worldPosition.xz * size );
					vec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );

					vec3 diffuseLight = vec3(0.0);
					vec3 specularLight = vec3(0.0);

					vec3 worldToEye = eye-worldPosition.xyz;
					vec3 eyeDirection = normalize( worldToEye );
					sunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );

					float distance = length(worldToEye);

					vec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;
					vec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );

					float theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );
					float rf0 = 0.3;
					float reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );
					vec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;
					vec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);
					vec3 outgoingLight = albedo;
					gl_FragColor = vec4( outgoingLight, alpha );

					#include <tonemapping_fragment>
					#include <fog_fragment>
				}`},G=new Le({fragmentShader:B.fragmentShader,vertexShader:B.vertexShader,uniforms:La.clone(B.uniforms),lights:!0,side:p,fog:f});G.uniforms.mirrorSampler.value=it.texture,G.uniforms.textureMatrix.value=v,G.uniforms.alpha.value=o,G.uniforms.time.value=l,G.uniforms.normalSampler.value=c,G.uniforms.sunColor.value=h,G.uniforms.waterColor.value=d,G.uniforms.sunDirection.value=u,G.uniforms.distortionScale.value=g,G.uniforms.eye.value=m,n.material=G,n.onBeforeRender=function(F,H,L){if(E.setFromMatrixPosition(n.matrixWorld),R.setFromMatrixPosition(L.matrixWorld),b.extractRotation(n.matrixWorld),M.set(0,0,1),M.applyMatrix4(b),X.subVectors(E,R),X.dot(M)>0)return;X.reflect(M).negate(),X.add(E),b.extractRotation(L.matrixWorld),D.set(0,0,-1),D.applyMatrix4(b),D.add(R),dt.subVectors(E,D),dt.reflect(M).negate(),dt.add(E),C.position.copy(X),C.up.set(0,1,0),C.up.applyMatrix4(b),C.up.reflect(M),C.lookAt(dt),C.far=L.far,C.updateMatrixWorld(),C.projectionMatrix.copy(L.projectionMatrix),v.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),v.multiply(C.projectionMatrix),v.multiply(C.matrixWorldInverse),y.setFromNormalAndCoplanarPoint(M,E),y.applyMatrix4(C.matrixWorldInverse),U.set(y.normal.x,y.normal.y,y.normal.z,y.constant);const z=C.projectionMatrix;K.x=(Math.sign(U.x)+z.elements[8])/z.elements[0],K.y=(Math.sign(U.y)+z.elements[9])/z.elements[5],K.z=-1,K.w=(1+z.elements[10])/z.elements[14],U.multiplyScalar(2/U.dot(K)),z.elements[2]=U.x,z.elements[6]=U.y,z.elements[10]=U.z+1-a,z.elements[14]=U.w,m.setFromMatrixPosition(L.matrixWorld);const lt=F.getRenderTarget(),ut=F.xr.enabled,ht=F.shadowMap.autoUpdate;n.visible=!1,F.xr.enabled=!1,F.shadowMap.autoUpdate=!1,F.setRenderTarget(it),F.state.buffers.depth.setMask(!0),F.autoClear===!1&&F.clear(),F.render(H,C),n.visible=!0,F.xr.enabled=ut,F.shadowMap.autoUpdate=ht,F.setRenderTarget(lt);const At=L.viewport;At!==void 0&&F.state.viewport(At)}}}Bf.prototype.isWater=!0;class ks extends pe{constructor(){const t=ks.SkyShader,e=new Le({name:"SkyShader",fragmentShader:t.fragmentShader,vertexShader:t.vertexShader,uniforms:La.clone(t.uniforms),side:Ke,depthWrite:!1});super(new Rr(1,1,1),e)}}ks.prototype.isSky=!0;ks.SkyShader={uniforms:{turbidity:{value:2},rayleigh:{value:1},mieCoefficient:{value:.005},mieDirectionalG:{value:.8},sunPosition:{value:new k},up:{value:new k(0,1,0)}},vertexShader:`
		uniform vec3 sunPosition;
		uniform float rayleigh;
		uniform float turbidity;
		uniform float mieCoefficient;
		uniform vec3 up;

		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		// constants for atmospheric scattering
		const float e = 2.71828182845904523536028747135266249775724709369995957;
		const float pi = 3.141592653589793238462643383279502884197169;

		// wavelength of used primaries, according to preetham
		const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
		// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
		// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
		const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

		// mie stuff
		// K coefficient for the primaries
		const float v = 4.0;
		const vec3 K = vec3( 0.686, 0.678, 0.666 );
		// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
		const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

		// earth shadow hack
		// cutoffAngle = pi / 1.95;
		const float cutoffAngle = 1.6110731556870734;
		const float steepness = 1.5;
		const float EE = 1000.0;

		float sunIntensity( float zenithAngleCos ) {
			zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
			return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
		}

		vec3 totalMie( float T ) {
			float c = ( 0.2 * T ) * 10E-18;
			return 0.434 * c * MieConst;
		}

		void main() {

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vWorldPosition = worldPosition.xyz;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			gl_Position.z = gl_Position.w; // set z to camera.far

			vSunDirection = normalize( sunPosition );

			vSunE = sunIntensity( dot( vSunDirection, up ) );

			vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

			float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

			// extinction (absorbtion + out scattering)
			// rayleigh coefficients
			vBetaR = totalRayleigh * rayleighCoefficient;

			// mie coefficients
			vBetaM = totalMie( turbidity ) * mieCoefficient;

		}`,fragmentShader:`
		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		uniform float mieDirectionalG;
		uniform vec3 up;

		const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );

		// constants for atmospheric scattering
		const float pi = 3.141592653589793238462643383279502884197169;

		const float n = 1.0003; // refractive index of air
		const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

		// optical length at zenith for molecules
		const float rayleighZenithLength = 8.4E3;
		const float mieZenithLength = 1.25E3;
		// 66 arc seconds -> degrees, and the cosine of that
		const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

		// 3.0 / ( 16.0 * pi )
		const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
		// 1.0 / ( 4.0 * pi )
		const float ONE_OVER_FOURPI = 0.07957747154594767;

		float rayleighPhase( float cosTheta ) {
			return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
		}

		float hgPhase( float cosTheta, float g ) {
			float g2 = pow( g, 2.0 );
			float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
			return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
		}

		void main() {

			vec3 direction = normalize( vWorldPosition - cameraPos );

			// optical length
			// cutoff angle at 90 to avoid singularity in next formula.
			float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
			float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
			float sR = rayleighZenithLength * inverse;
			float sM = mieZenithLength * inverse;

			// combined extinction factor
			vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

			// in scattering
			float cosTheta = dot( direction, vSunDirection );

			float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
			vec3 betaRTheta = vBetaR * rPhase;

			float mPhase = hgPhase( cosTheta, mieDirectionalG );
			vec3 betaMTheta = vBetaM * mPhase;

			vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
			Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

			// nightsky
			float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
			float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
			vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
			vec3 L0 = vec3( 0.1 ) * Fex;

			// composition + solar disc
			float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
			L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

			vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

			vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

			gl_FragColor = vec4( retColor, 1.0 );

			#include <tonemapping_fragment>
			#include <encodings_fragment>

		}`};var o1="data:image/jpeg;base64,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Ak4AAQACOEJJTQQmAAAAAAAOAAAAAAAAAAAAAD+AAAA4QklNBA0AAAAAAAQAAAAeOEJJTQQZAAAAAAAEAAAAHjhCSU0D8wAAAAAACQAAAAAAAAAAAQA4QklNJxAAAAAAAAoAAQAAAAAAAAACOEJJTQP1AAAAAABIAC9mZgABAGxmZgAGAAAAAAABAC9mZgABAKGZmgAGAAAAAAABADIAAAABAFoAAAAGAAAAAAABADUAAAABAC0AAAAGAAAAAAABOEJJTQP4AAAAAABwAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAADhCSU0EAAAAAAAAAgAAOEJJTQQCAAAAAAACAAA4QklNBDAAAAAAAAEBADhCSU0ELQAAAAAABgABAAAADThCSU0ECAAAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4AAAAAAAQAAAAAOEJJTQQaAAAAAANNAAAABgAAAAAAAAAAAAAEAAAABAAAAAAMAHcAYQB0AGUAcgBuAG8AcgBtAGEAbABzAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAABAAAAABAAAAAAAAbnVsbAAAAAIAAAAGYm91bmRzT2JqYwAAAAEAAAAAAABSY3QxAAAABAAAAABUb3AgbG9uZwAAAAAAAAAATGVmdGxvbmcAAAAAAAAAAEJ0b21sb25nAAAEAAAAAABSZ2h0bG9uZwAABAAAAAAGc2xpY2VzVmxMcwAAAAFPYmpjAAAAAQAAAAAABXNsaWNlAAAAEgAAAAdzbGljZUlEbG9uZwAAAAAAAAAHZ3JvdXBJRGxvbmcAAAAAAAAABm9yaWdpbmVudW0AAAAMRVNsaWNlT3JpZ2luAAAADWF1dG9HZW5lcmF0ZWQAAAAAVHlwZWVudW0AAAAKRVNsaWNlVHlwZQAAAABJbWcgAAAABmJvdW5kc09iamMAAAABAAAAAAAAUmN0MQAAAAQAAAAAVG9wIGxvbmcAAAAAAAAAAExlZnRsb25nAAAAAAAAAABCdG9tbG9uZwAABAAAAAAAUmdodGxvbmcAAAQAAAAAA3VybFRFWFQAAAABAAAAAAAAbnVsbFRFWFQAAAABAAAAAAAATXNnZVRFWFQAAAABAAAAAAAGYWx0VGFnVEVYVAAAAAEAAAAAAA5jZWxsVGV4dElzSFRNTGJvb2wBAAAACGNlbGxUZXh0VEVYVAAAAAEAAAAAAAlob3J6QWxpZ25lbnVtAAAAD0VTbGljZUhvcnpBbGlnbgAAAAdkZWZhdWx0AAAACXZlcnRBbGlnbmVudW0AAAAPRVNsaWNlVmVydEFsaWduAAAAB2RlZmF1bHQAAAALYmdDb2xvclR5cGVlbnVtAAAAEUVTbGljZUJHQ29sb3JUeXBlAAAAAE5vbmUAAAAJdG9wT3V0c2V0bG9uZwAAAAAAAAAKbGVmdE91dHNldGxvbmcAAAAAAAAADGJvdHRvbU91dHNldGxvbmcAAAAAAAAAC3JpZ2h0T3V0c2V0bG9uZwAAAAAAOEJJTQQoAAAAAAAMAAAAAj/wAAAAAAAAOEJJTQQUAAAAAAAEAAAADjhCSU0EDAAAAAAb5AAAAAEAAACgAAAAoAAAAeAAASwAAAAbyAAYAAH/2P/tAAxBZG9iZV9DTQAB/+4ADkFkb2JlAGSAAAAAAf/bAIQADAgICAkIDAkJDBELCgsRFQ8MDA8VGBMTFRMTGBEMDAwMDAwRDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAENCwsNDg0QDg4QFA4ODhQUDg4ODhQRDAwMDAwREQwMDAwMDBEMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwM/8AAEQgAoACgAwEiAAIRAQMRAf/dAAQACv/EAT8AAAEFAQEBAQEBAAAAAAAAAAMAAQIEBQYHCAkKCwEAAQUBAQEBAQEAAAAAAAAAAQACAwQFBgcICQoLEAABBAEDAgQCBQcGCAUDDDMBAAIRAwQhEjEFQVFhEyJxgTIGFJGhsUIjJBVSwWIzNHKC0UMHJZJT8OHxY3M1FqKygyZEk1RkRcKjdDYX0lXiZfKzhMPTdePzRieUpIW0lcTU5PSltcXV5fVWZnaGlqa2xtbm9jdHV2d3h5ent8fX5/cRAAICAQIEBAMEBQYHBwYFNQEAAhEDITESBEFRYXEiEwUygZEUobFCI8FS0fAzJGLhcoKSQ1MVY3M08SUGFqKygwcmNcLSRJNUoxdkRVU2dGXi8rOEw9N14/NGlKSFtJXE1OT0pbXF1eX1VmZ2hpamtsbW5vYnN0dXZ3eHl6e3x//aAAwDAQACEQMRAD8ANdXtcN43AbdwIjjvrLUYMH83U4l0TsAEBEucbq9wbNh5gQfk5VvS1a5o2uYZAkyPGP5K6UHiGuhCw6RJkfTI8XnEf9ys1sO2vduaTp2ieyL9ja4bG1CWmII4B48dycvqAh4BbH0vnqxyIMSsEem6XNPtmRofzdxPuSlOupj9NGvLLZo2Bvw1v/eQ42PQwurLTyTG0QD5fyELIp9Mt9Iv26OaAfo/DarT6r68gvbo18ckwHDQt/tJi0kbXNBI7DUJRkbu7BZhfBcpcRMif8GPyNZ7riWvaRA5IEEfHciVve4BrtpiYIBB17f1UQlrmtIEjgiIP8psJPqNZDmEOb4HnzR4hVVXZWTNVmtd1MrY5v0OOddUK7HYW6kODdARrofJWWOa4biC5p5BgSPFn9VT9Gt9bmHdtIIGoPzame4YnVrGZrU6n/moK78mpkB+4NhpYfdA/N91m5F9eYsZW3c2N3ugaoRZ6I2WHcABrBGn8pOysOINLwQBqCRoP5Lf3EiIHWh/e+Xi80gCrOmmsj6dUvqYZdL2thx94aJAP8l6jda1gBa4emNNxOsFQLmCWvaCRILhoNPzYQLMYOB2vD2idHaGPJ6QhGxZP11DLDAMgMpkgb69I/o+lm65vqtsYS7dJ14+785I22MLDJFZ/dEx/Vao491mPsBaH17oO/WD2c0/SRLa6rw8AOG2YAOgTqANEafvMk6lDgiOGIO+524pf9FRzN9YjZZtPuH0dzT5+7a9DNbG37iyGPEiSTB/qj/qkJ9bGQHuI/OYZ58Ycove30BY2w2Na4g7hq0n2w+D+9/JTxAD5dLY5RqhAHQXf93du0NxwSwuLZBEeac4oLJrf6rYMgCHNH7zWfnbVW9cODLtm1/5wLpbp+dWfzUY2W0WzTrBhzXGdDw5h0TDGV2Dr2NVouNnQG9u1cBf/9Czpja1ufZSdTt7d9rmtTv9wDqxuY/UGdR/KbH/AFChV6lTS1oG3lp1geRaiV3MYwurEAGXbfPyculNj+sfz/vNbmso0jEcVj8B+8oW2sq/SBpYD9JoDiJ+W7YpOc7YIG3yEkHuNs+xNcCK22seId7WzEGdCwkQoeozaBO0M4a07gR+7uQAG9edLeWw8UiSLqIs+Mun9ZK51jXiXbCezpIcPl7dqm4b6zqIH7oJ81UdZ7Q3WGzwZ0+asY1lJ1cXAHTcdOf++pSiQL7dm0T+sJl9B9ELoB2iTuMQeT4fTUPXNe0gugGQ1x1+H8pWcims8glswYPBHgqz69rNJLxpDvyOT4kEBgy1xEGyd6ZMzNsb40OjuSO/I+KMc81ENdQ8h/LmgHXj2vf7NyoWuc9p/R88hx8vc10KeJawt9Ik7h3JJAIG33tSliiRdIw4Y8XFMXQ9Mf0f8L+o2n3PEOZLqzq0yCY/qn/qVBmTXaGixsFuh2ANII/ODv6qa2u8dgAdQ6JBP/mSFQ0Os1ewjlszAjttS4Y8N9uoZTCJyxva+n8vmkkde+t49u5g1aSADHhuI3OVptlVjDtjcBo13cHw/NQ/T9RoZZEHVm7Vp8WobKrKHQPoTA1Bj+ruTSIkdpD8V2ScRfQeB/DiZFplpeHbSY3N1Gn8lFre15f6QMj80kA+P5yQcTLXMa1w1M6Bw/fby1Qtr3/pK3g2NGskGR9yG++n/RYsYMjfb5R0/dXe6wNLNggcgwdD/X/76qvotMmQ20j/ADh/35GFlzqwHkNLdCeZ/BQIgHa4T3EaAp8bHh5MkhwDSrrp4/1kNLKa2ltrYbOgJn5SrArxywNBEcCYOng1xQ/swsLnktc6A4gHtGod+btQ2UiXMrD2sOjiPc2f3f8AzhOOutm1uMXEes3L5j+hCA2f/9G8RJHDw8fSmZn4IW21j3VubIP0H87dPoyEzxQ5kV+0gkFkwWmZ4P0kg58jY+XRBA9pH8ks/PXSgdfzaMIGcxIjevm7H5kb6wWFrhq4yQeNf5A9rVJtG6wQ+C4aOBgH+RCnXe4tLDD/AOSRB/e+lruSfdS5h9o9vu2kiRHknXK6r+RdEGUYgRGtD8EVlf2V7S9v6I8mJI/lJ67mOJgkCdrhMtd+6fak41uZxLGkQWTIB19o/O/qoZrDH72y7uCNDH/fv7SduNd2OMOGfFKzL8u6d11ha5jgRHYQP83VAcHvbAJLhpPePNGAc7wfHOsFJ9ctLILHNOhhAEBEjGzQG2pamy4dwzxgGdENwsOljtNRv2iB4Q9harkWMO8OLm6bo1RDW17AXN3N4Lm/e3RP46WTyiIoVfl3RUuLqi0vln/RDh22oe9r7A6sEbuDJjd/1SMWUAizbq07XHvM+12xO4uY8lgaHHVwdoHNPgm3qaXGQiIyIJl2Pp/lNG1trg9u9wLTLqo2gebJUy20t1O7T87y8Ub1ybBvpPuHtI9w0+kChtY4uLDLSfogeXxQs9QB1VrIgGhGz+H91ELMqotJ91bgDEyB/wBFGaAX72d+SCTH9YITK7wHMBcWtOoggie/9VTYHEAxLu41B8/d/wCSSNeHbReJCMQBQJ9Wnh3TBpBLSBB4I5UH7K3S2O2o/i1Epcw+3cd0fQ4M/wBpOdCWOaCOziY+TUy6LWlPiFn5d+yEUAkWVccOA4+TQnDxWdu709IJA2x4FFa/03FjADGjmdx4PbCQey0FlsOsAgEgAuj3D3fRS4j1Fj8VSmTEEj0/ox/ePd//0rD7tp3NDi13YnsddHJy6p4G5pYdA4nQ6cHcPig7WNfuJ2AzuaNWn+rtRWekJFQImRqCJn83XaunIAF6+bHhiOI8IJN8I/dUW2V2exjXyJ5EmOYlQhljg7kdpABHkmBc8jeAO7WkagjRwCI6pxbuHHlrB8NEh4tiZGOJFjjJJtiGGrQtBB0E8/ekGtdofY3w8EVlQLQWmH9xrHySLZI8R3aZ0PbVLia0p6VHUnr4MPe32kyANDp/1SlWRY/a08idTBTekx0GQfI6GQhFzq3iJLBrBPb+S5LfbdWkYgDvcj/L5mVm+p/tMt7kaEfJDc6xoLgfVa3lhMGPL6O5WXj1QdriYGgMAkeTkLa0MG5xcOz4Bj+Q5EHvux0OM/yLIZQhpNQMiC8GQR4Jqg66sNbLTUSBB1H3/m+5R2tYJrA292g7TqOyky2tlw9c7dx2l8NB1+g5w9qBAANDx/kF05RExQ+XTXVGarx/K11JgfPlTayw6u+k3kcFXHUssMNjeRu4Ba8cO2IXpWVvnQDUSdQPLcEPcBHS1TzcA6DbzZUjeIfua4DaDHMeJ/OTPays+naNu7ggaqQ9Vhhx27tIE7TPh+c1NbNjPTcdR+fE/wBlqZZvwPZiHFKBN/yK1jQ1wLg2I1ce6jY8Rs3ECJaJ04+CUOaGtc9vEtkkgj+Vz7kwrrc06uAbzBn56JwrrqyxhEjXY6sHVb9rq3lrm8OiHfP+ShOfdRb74e1wBcwmTLdPY7+qivMDUOLm/IOHk5D9RriGNkPA9u8AiPJ4TxfmEZrkdvL/AH3/05PeHD1mOgO0c1+nP5zf6v56ep1znjeZHZw1H+v9ZH+zUuc4hoDSYcQ32mfov4Tuw/bNQBe0e5jfDyXT8cao/ig5Y4hUR+srt8iQs2tlxB84jlItc1xDCADyJQqrmvqDH6uB2747dvaiejYTGhjxG0gjwTNtywk6cczuBv2R7Q1x2HadDof++qcknWIOkH+CMyqtwILnV2MJBJk/9Ugvqsn3QBzIMtP8rakJAn+K3GRK5nSN7n9jHewzGrQdQpmkugNaSw6t78qTgyRp6e4aOEkT5/yVOm2lzS1zgduj2kmR5t0QMiBYB/NbPLcqANDbr/hNR1VrHCfo/iPmptxWP9zjIdyONf3tFdsx2uq3NtBAH52v/mSpWF+LYHj3s0kAkgg89kY5OMek+r7FcchQj17Mvsjnbq2uO8CWzrI+73KPpsyGBtxDSBG8D/vyha8C9j67D6biQ14Jlrj9HfuChfdYbTvra4P5e3UT4x9FOAkevj/WXY8OSUpa7H1E/ox3CRljKhsadu0nSdAT4bv3kr8i5xJr3BzNHB3BHmqptvpPu3XMOu9sSI7PbopWWWOd6rLRx7pAB07bdydwC7NHxK8Yo8JlKiAbMpa2P30tN+/9DaCx3G6ZaR2/k/8ASTuJYRsluukGQD/VQ/XbUWgv26GD3bH/AFbVP0brLYY4OFgmGE+7vx9FIgA3sF/CDjBl6IXevb9FkbGwC0ls+73AQT3/AKqb7TSf0lf0hodo0IP5pTih9byxzTYw6tJ1I/kv/eSdtDZDASNQ8CRH7rmIenzX3E2dTuyY/wBSdrHH+qN35EG191furYSzXc0CHc86nahvse2yaTtDhyJH4IlXUdlmzJ1rf9Jzmg6HTcncJGoFj91hMDuQN9B/3T//1LteRlVMgP3BsNLDrA/N91m7ai+vMWMrbubG73QNUMsFILLDuAGhgjT+UkysOINLwQBqCRoP5Lf3F0ZEDrQ/vfLxebSAjVnTTWR9OqX1MMul7WkOPvDRIB/kvUbrWsALXD0xpuJ1g8KBcwS17QSJBcNBp+bCBZjBwO14e0To7Qx5PSEI2LJ+uoZYcuMgMpkgb69I/o+lm65vqtsYS7dJ14+785I22VlhkivttEx/Vao491mPsBaH17oO/WD2c0/SRLa6rw8AOG2YAOgTqANEafvMk6lDgiOGIO+524pf9FRzN9Y27LNrvcNW7mnvPu96G6tgv3FkMeJEkmD8B/1SE+tjID3EfnMM8+MOUXvb6AsbYbGtcQdw1aT7YfB/e/kp4gB8ulsco1QgCKF3/d3btDMcEsLiyQRA8U5xQWA1v9VsGQBDmg/nNZ+dtVb1w4Mu2bX/AJwLpbp+dWfzUY2W0WzTrBhzXHseHMdomGMrsHXsarRceI6Xe29VwSQ3VkOHqe6Nu4ERx313NRgwfzdTnExOwRARLnG6vcGzZ3gQfk781VvS1a5o2uYZAkyPGP5KQPENdCF50iTI+mR4vOI/7lTWw7a925pOnaJ7In2NrhsbUJaYgjgdtddycvqAh4BbH0vnqxyIMSsEem6XNPtmRofzdxPuSlOupj9NGvLLZo2Bvw1v/eQ42PQwurLTyTG0AA+XHsQsigVlnpF5YIc0T9H4bVafVfXkF7dGvjkmA4aFv9pMWkja5oJHYahKMjfFdgswvguUuImRP+DH5Gs91xLbGkQOS0QQfE7kSux7gGugxMEAg69v6qIS1zWkCRwREH+U2En1GshzCHN8Dz5o8QqiK7Ky5qs1ruplbXN+jxzrqh20NLeQ7bwRrofJWGOa4biC5p5BgSPFn9VT9Fj63M920ggGQfm1M9wxOrWMzW+p/wCa/wD/1bb7rNHMl1Z1aZBMH+SoMya7Q0WNgt0OwBpBH5wd/VTW13jsADqHRIJQqGh1mr2EctmYEdtq6cRjw326hjMInLG9r6fy/SSOvfW8e3cwatJABjw3EbnK02yqxh2xuA0a7uD4fmofp+o0MsiDqzdq0+LUNlVlDoH0Jgagx/V3JpESO0h+K7JOIvoPA/hxMi0y0vDtpMbm6jT+Si1va8v9IGR+aSAfH85IOJlrmNa4amdA4fvt5aoW17/0lbwbGjWSDI+5DffT/osWMGRvt8o6furvdYGlmwQOQYOh/r/99VX0WmTIbaR/nD/vyMLLnVgPIaW6E8z+CgRAO1wnuI0BT42PDyZJDgGlXXTx/rIaWU1tLbWw2dATPylWBXjlgaCI0DZg6eDXFD+zCwueS1zoDiAe0ah35u1DZSJcysPaw6OI9zZ/d/8AOE4662bW4xcR6zcvmP6EIDZs6Y2tbn2UnU7e3fa5oTv9wDqxuY/UGdR/KbH/AFChV6lTS1oG3lp1geRaiV3MYwurEAGXbfPycozY/rH8/wC8x81lGkYjisfgP3lC21lX6QNLAfpNAcRPy3bFJznbBA2+Qkg9xtn2JrgRW21jxDva2YgzoWEiFD1GbQJ2hnDWncCP3dyAA3rzpby2HikSRdRFnxl0/rJXOsa8S7YT2dJDh8vbtU3DfWdRA/dBPmqjrPaG6w2eDOnzVjGspOri4A6bjpz/AN9SlEgX27Non9YTL6D6IXQDtEncYg8nw+moeua9pBdAMhrjr8P5Ss5FNZ5BLZgweCPBVn17WaSXjSHfkcnxIIDBlriINk70yZmbY3xodHckd+R8UY55rIa6h5D9C9oBE8aPf7Gqha5z2n9HzyHHy9zXQp4lrC30pO4dySQCBt97SlLFEi6Rhwx4uKYuh6Y/o/4X9R//1p0uLqi0vln/AEQ4dtqHva+wOrBG7gyY3f8AVIxZQCLNurTtce8z7XbU7i5jyWBocdXB2gc0+C6m9TXVYZCIjIgmXY+n+UkbW2uD273AtMuqjaB5slTLbS3U7tPzvLxRvXJsG+k+4e0j3DT6QKG1ji4sMtJ+iB5fFCz1AHVWsiAaEbP4f3UQsyqi0n3VuAMTIH/RRmgF+9nfkgkx/WCEyu8BzAXFrTqIIInv/VU2BxAMS7uNQfP3f+SSNeHbReJCMQBQJ9Wnh3TBpBLSBB4I5UH7K3S2O2o/i1Epcw+3cd0fQ4M/2k50JY5oI7OJj5NTLotaU+IWfl37IRQCRZVxw4Dj5NCcPFZ27vT0gkDbHgUVr/TcWMAMaOZ3Hg9sJNey0bLIdYBAJABdHuHu+ilxHqLH4qlMmIJHp/Rj+8e65EkcPDxzMzPwQdtrHurc2QfoP526fRkJnjHcyK/aQSCyYLTM/RP0kg58jY+XRBA9pH8ks/PSA6/mxQgZzEiN6+bsfmRvrBYWuGrjJB41/kD2tUm0brBD4Lho4GAf5EKdd7i0sMP/AJJEH976Wu5J91LmH2j2+7aSJEeSdcrqv5F0QZRiBEa0PwRWV/ZXtL2/ojyYkj+UnruY4mCQJ2uEy137p9qTjW5nEsaRBZMgHX2j87+qhmsMfvbLu4I0Mf8Afv7SduNd2OMOGfFKzL8u6d11ha5jgRHYQP8AN1QHB72wCS4aT3jzRgHO8HxzrBSfXLSyCxzToYQBARIxs0BtqWpsuHcM8YBnRDIs4sdpqN+0QPCH1lquRYw7w4ubpujVENbXsBc3c3gubp5t0T+Olk8oiKFX5d3/17AyhDSagZEF4MiPBNUHXVhrZaaiQIOo+/8AN9yjtawTXG3u0HadRyFJltbLh6527jtL4aDr9Bzh7V05AANDx/kGCcoiYofLQ11Rmq8fytdSYHz5U2ssOrvpN5HBVx1LLDDY3kbuAWvHDtiF6Vlb50A1EnUDy3BD3AR0tU83AOg282VI3iH7muA2gxzHifzkz2srPp2jbu4IGqkPVYYcdu7SBO0z4fnNTWzYz03HUfnxP9lqZZvwPZiHFKBN/wAitY0NcC4NiNXHuo2PEbNxAiWidOPglDmhrXPbxLZJII/lc+5MK63NOrgG8wZ+eicK66ssYRI12OrB1W/a6t5a5vDoh3z/AJKE591FsvAeHAEsJky39x39VFeYGocXN+QcPJyH6jXEMbIsA9u8AiPJ4TxfmEZrkdvL/fSPuDTuaHFjuxOsHXRycuqeBuaWHQOJ0OnB3D4oO1jX7idgM7mjVp/q7UVnpCRUCJkagiZ/N12oEADr5smGI4jwgk3wj91RbZXZ7GNfInkSY5iVCGWODuR2kAEeSYFzyN4A7taRqCNHAIjqnFu4ceWsHw0SHi2JkY4kWOMkm2IYatC0EHQTz96Qa12h9jfDwRWVAtBaYf3GsfJItkjxHdpnQ9tUuJrSnpUdSevgw97faTIA0On/AFSlWRY/a08idTBTekx0GQfI6GQhFzq3iJLBrBPb+S5LfbdWkYgDvcj/AC+ZlZvqf7TLe5GhHyQ3OsbLgfVa3lhMGPL6O5WXj1QdriYGgMAkeTkLY0M97tzezoBj+Q5EHvux0OM/yL//0Lv2Rzt1bXHcBLZ1kfd7lH02ZDA24hpAjeB/35QteBex7LDscSA8TLXH6O+QoX3Wm07q2uD+Xt1E+MfRXTASPXx/rNbHhySkddj6if0Y/MEjLGVDY07dpOk6Anw3fvJX5FziTXuDmaODuCPNVTbfSfduuYdQ9sSI7PbopWWWOd6rLe3ukAH4bdydwC7NHxK8Yo8JlKiAbMpa2P30tN+/9DaCx3G6ZaR2/k/9JO4lhGyW66QZAP8AVQ/XbXtl+3Qw7u2P+rap+lc+2GOBFgmGE+7vx9FIgA3sF/CDjBl6I3evb9FkbGwC0ls+73AQT3/qpvtNJ/SV/SGh2jQg/mlOKH1vLHNNjDq0nUj+S/8AeScGtbOzUah4EiP3XMQ9PmvuJs6ndkx/qTtY4/1Ru/Ig2vurl1VZLNZaAA7nn3Hahvse2yaTtDhyJH4IlXUdlm3J1rf9Nzmg6H85HhI1AB/qsJidyBvoP+6YveHD1q3QHaOa/TQ/nN/d2/np6nXOeN5kdnDUf6/1lY+y1Oc6GiJhxa32n91/CTsPSagC9o9zG9x5IccdvzZTljiFRH6yu3yJCza2XEHziOUi1zXEMIAPIlDqua6oMeDuB2747dvap+jYTEAx4jaQR+6mbblhJ045ncA69ke0Ncdh2nQ6H/vqnJJ1iDpB/gjMqqcCNzq7GEiTJ/6pBfVZOsAcyDLT57UhIH+1bjIlczpG9z+xjvYZjVoOoUzSXQGtJYdW9+VJzWyNPT3DRwkifP8AkqdNtLgWucDt0e0kyI7t0QMiBYB/NbPLcqANDbr/AITUdVaxwn6P4j5qbcVjvc4yHcjjX97RXLMdjq9zbWkAfnGf/MlTfvxrA8e5mkgEkEHnsjHJxj0n1K45ChHr2D//2ThCSU0EIQAAAAAAVQAAAAEBAAAADwBBAGQAbwBiAGUAIABQAGgAbwB0AG8AcwBoAG8AcAAAABMAQQBkAG8AYgBlACAAUABoAG8AdABvAHMAaABvAHAAIABDAFMANQAAAAEAOEJJTQQGAAAAAAAHAAQAAQABAQD/4Q74aHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjAtYzA2MCA2MS4xMzQzNDIsIDIwMTAvMDEvMTAtMTg6MDY6NDMgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzUgKDEyLjB4MjAxMDAxMTUgWzIwMTAwMTE1Lm0uOTk4IDIwMTAvMDEvMTU6MDI6MDA6MDAgY3V0b2ZmOyBtIGJyYW5jaF0pICBXaW5kb3dzIiB4bXA6Q3JlYXRlRGF0ZT0iMjAxMy0xMi0wM1QyMDo0MjoxMyswMTowMCIgeG1wOk1vZGlmeURhdGU9IjIwMTMtMTItMDVUMDA6NTQ6MDkrMDE6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMTMtMTItMDVUMDA6NTQ6MDkrMDE6MDAiIGRjOmZvcm1hdD0iaW1hZ2UvanBlZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgcGhvdG9zaG9wOklDQ1Byb2ZpbGU9InNSR0IgSUVDNjE5NjYtMi4xIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkM2MjFDQjI0M0M1REUzMTFCQ0YxOUQ3MDBBOTQzMEFCIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkM1MjFDQjI0M0M1REUzMTFCQ0YxOUQ3MDBBOTQzMEFCIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6QzUyMUNCMjQzQzVERTMxMUJDRjE5RDcwMEE5NDMwQUIiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOkM1MjFDQjI0M0M1REUzMTFCQ0YxOUQ3MDBBOTQzMEFCIiBzdEV2dDp3aGVuPSIyMDEzLTEyLTAzVDIwOjQyOjEzKzAxOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ1M1ICgxMi4weDIwMTAwMTE1IFsyMDEwMDExNS5tLjk5OCAyMDEwLzAxLzE1OjAyOjAwOjAwIGN1dG9mZjsgbSBicmFuY2hdKSAgV2luZG93cyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY29udmVydGVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJmcm9tIGltYWdlL3BuZyB0byBpbWFnZS9qcGVnIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpDNjIxQ0IyNDNDNURFMzExQkNGMTlENzAwQTk0MzBBQiIgc3RFdnQ6d2hlbj0iMjAxMy0xMi0wNVQwMDo1NDowOSswMTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENTNSAoMTIuMHgyMDEwMDExNSBbMjAxMDAxMTUubS45OTggMjAxMC8wMS8xNTowMjowMDowMCBjdXRvZmY7IG0gYnJhbmNoXSkgIFdpbmRvd3MiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDw/eHBhY2tldCBlbmQ9InciPz7/4gxYSUNDX1BST0ZJTEUAAQEAAAxITGlubwIQAABtbnRyUkdCIFhZWiAHzgACAAkABgAxAABhY3NwTVNGVAAAAABJRUMgc1JHQgAAAAAAAAAAAAAAAQAA9tYAAQAAAADTLUhQICAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABFjcHJ0AAABUAAAADNkZXNjAAABhAAAAGx3dHB0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";let jr,os,fa;function l1(i){const t=new bs(1e4,1e4);os=new Bf(t,{textureWidth:512,textureHeight:512,waterNormals:new Lf().load(o1,function(e){e.wrapS=e.wrapT=zn}),sunDirection:new k,sunColor:16777215,waterColor:7695,distortionScale:3.7,fog:i.fog!==void 0}),os.rotation.x=-Math.PI/2,i.add(os)}function c1(i,t){fa=new k,jr=new ks,jr.scale.setScalar(1e4),i.add(jr);const e={time:6,elevation:-90,azimuth:0,turbidity:10,rayleigh:2};n();function n(){let r=new Date;e.time=r.getHours()+r.getMinutes()*5/300,e.time>=6&&e.time<18?(e.elevation=e.time*15-180,e.turbidity=pa(5,2),e.rayleigh=pa(2.5,1)):(e.elevation=-e.time*15,e.turbidity=pa(.05,.02),e.rayleigh=pa(.005,.002));const s=jr.material.uniforms,a=new kl(t);s.turbidity.value=e.turbidity,s.rayleigh.value=e.rayleigh;const o=Uu.degToRad(e.elevation),l=Uu.degToRad(e.azimuth);fa.setFromSphericalCoords(1,o,l),jr.material.uniforms.sunPosition.value.copy(fa),os.material.uniforms.sunDirection.value.copy(fa).normalize(),i.environment=a.fromScene(i).texture}}function u1(){os.material.uniforms.time.value+=1/60}function pa(i,t){let e=0,n=0,r=0,s=0;do e=Math.random()*2-1,n=Math.random()*2-1,r=e*e+n*n;while(r==0||r>=1);return s=Math.sqrt(-2*Math.log(r)/r),i+e*s*t}function h1(i,t){return l1(i),c1(i,t),u1}class d1{constructor(t,e,n){this.variables=[],this.currentTextureIndex=0;let r=Cn;const s=new Ya,a=new Za;a.position.z=1;const o={passThruTexture:{value:null}},l=h(m(),o),c=new pe(new bs(2,2),l);s.add(c),this.setDataType=function(g){return r=g,this},this.addVariable=function(g,p,f){const y=this.createShaderMaterial(p),M={name:g,initialValueTexture:f,material:y,dependencies:null,renderTargets:[],wrapS:null,wrapT:null,minFilter:ae,magFilter:ae};return this.variables.push(M),M},this.setVariableDependencies=function(g,p){g.dependencies=p},this.init=function(){if(n.capabilities.isWebGL2===!1&&n.extensions.has("OES_texture_float")===!1)return"No OES_texture_float support for float textures.";if(n.capabilities.maxVertexTextures===0)return"No support for vertex shader textures.";for(let g=0;g<this.variables.length;g++){const p=this.variables[g];p.renderTargets[0]=this.createRenderTarget(t,e,p.wrapS,p.wrapT,p.minFilter,p.magFilter),p.renderTargets[1]=this.createRenderTarget(t,e,p.wrapS,p.wrapT,p.minFilter,p.magFilter),this.renderTexture(p.initialValueTexture,p.renderTargets[0]),this.renderTexture(p.initialValueTexture,p.renderTargets[1]);const f=p.material,y=f.uniforms;if(p.dependencies!==null)for(let M=0;M<p.dependencies.length;M++){const E=p.dependencies[M];if(E.name!==p.name){let R=!1;for(let b=0;b<this.variables.length;b++)if(E.name===this.variables[b].name){R=!0;break}if(!R)return"Variable dependency not found. Variable="+p.name+", dependency="+E.name}y[E.name]={value:null},f.fragmentShader=`
uniform sampler2D `+E.name+`;
`+f.fragmentShader}}return this.currentTextureIndex=0,null},this.compute=function(){const g=this.currentTextureIndex,p=this.currentTextureIndex===0?1:0;for(let f=0,y=this.variables.length;f<y;f++){const M=this.variables[f];if(M.dependencies!==null){const E=M.material.uniforms;for(let R=0,b=M.dependencies.length;R<b;R++){const D=M.dependencies[R];E[D.name].value=D.renderTargets[g].texture}}this.doRenderTarget(M.material,M.renderTargets[p])}this.currentTextureIndex=p},this.getCurrentRenderTarget=function(g){return g.renderTargets[this.currentTextureIndex]},this.getAlternateRenderTarget=function(g){return g.renderTargets[this.currentTextureIndex===0?1:0]};function u(g){g.defines.resolution="vec2( "+t.toFixed(1)+", "+e.toFixed(1)+" )"}this.addResolutionDefine=u;function h(g,p){p=p||{};const f=new Le({uniforms:p,vertexShader:d(),fragmentShader:g});return u(f),f}this.createShaderMaterial=h,this.createRenderTarget=function(g,p,f,y,M,E){return g=g||t,p=p||e,f=f||He,y=y||He,M=M||ae,E=E||ae,new We(g,p,{wrapS:f,wrapT:y,minFilter:M,magFilter:E,format:qe,type:r,depthBuffer:!1})},this.createTexture=function(){const g=new Float32Array(t*e*4),p=new hf(g,t,e,qe,Cn);return p.needsUpdate=!0,p},this.renderTexture=function(g,p){o.passThruTexture.value=g,this.doRenderTarget(l,p),o.passThruTexture.value=null},this.doRenderTarget=function(g,p){const f=n.getRenderTarget();c.material=g,n.setRenderTarget(p),n.render(s,a),c.material=l,n.setRenderTarget(f)};function d(){return`void main()	{

	gl_Position = vec4( position, 1.0 );

}
`}function m(){return`uniform sampler2D passThruTexture;

void main() {

	vec2 uv = gl_FragCoord.xy / resolution.xy;

	gl_FragColor = texture2D( passThruTexture, uv );

}
`}}}let qh=performance.now(),je,or,Rn,Kn,ls,Ue;const f1=`
attribute vec2 reference;
attribute float birdVertex;

attribute vec3 birdColor;

uniform sampler2D texturePosition;
uniform sampler2D textureVelocity;

varying vec4 vColor;
varying float z;

uniform float time;

void main() {

  vec4 tmpPos = texture2D( texturePosition, reference );
  vec3 pos = tmpPos.xyz;
  vec3 velocity = normalize(texture2D( textureVelocity, reference ).xyz);

  vec3 newPosition = position;

  if ( birdVertex == 4.0 || birdVertex == 7.0 ) {
    // flap wings
    newPosition.y = sin( tmpPos.w ) * 5.;
  }

  newPosition = mat3( modelMatrix ) * newPosition;


  velocity.z *= -1.;
  float xz = length( velocity.xz );
  float xyz = 1.;
  float x = sqrt( 1. - velocity.y * velocity.y );

  float cosry = velocity.x / xz;
  float sinry = velocity.z / xz;

  float cosrz = x / xyz;
  float sinrz = velocity.y / xyz;

  mat3 maty =  mat3(
    cosry, 0, -sinry,
    0    , 1, 0     ,
    sinry, 0, cosry

  );

  mat3 matz =  mat3(
    cosrz , sinrz, 0,
    -sinrz, cosrz, 0,
    0     , 0    , 1
  );

  newPosition =  maty * matz * newPosition;
  newPosition += pos;

  z = newPosition.z;

  vColor = vec4( birdColor, 1.0 );
  gl_Position = projectionMatrix *  viewMatrix  * vec4( newPosition, 1.0 );
}
`,p1=`
varying vec4 vColor;
varying float z;

uniform vec3 color;

void main() {
  // Fake colors for now
  float z2 = 0.2 + ( 1000. - z ) / 1000. * vColor.x;
  gl_FragColor = vec4( z2, z2, z2, 1. );

}
`,m1=`
uniform float time;
uniform float delta;

void main()	{

  vec2 uv = gl_FragCoord.xy / resolution.xy;
  vec4 tmpPos = texture2D( texturePosition, uv );
  vec3 position = tmpPos.xyz;
  vec3 velocity = texture2D( textureVelocity, uv ).xyz;

  float phase = tmpPos.w;

  phase = mod( ( phase + delta +
    length( velocity.xz ) * delta * 3. +
    max( velocity.y, 0.0 ) * delta * 6. ), 62.83 );

  gl_FragColor = vec4( position + velocity * delta * 15. , phase );

}
`,g1=`
uniform float time;
uniform float testing;
uniform float delta; // about 0.016
uniform float separationDistance; // 20
uniform float alignmentDistance; // 40
uniform float cohesionDistance; //
uniform float freedomFactor;

const float width = resolution.x;
const float height = resolution.y;

const float PI = 3.141592653589793;
const float PI_2 = PI * 2.0;
// const float VISION = PI * 0.55;

float zoneRadius = 40.0;
float zoneRadiusSquared = 1600.0;

float separationThresh = 0.45;
float alignmentThresh = 0.65;

const float UPPER_BOUNDS = BOUNDS;
const float LOWER_BOUNDS = -UPPER_BOUNDS;

const float SPEED_LIMIT = 9.0;

float rand( vec2 co ){
  return fract( sin( dot( co.xy, vec2(12.9898,78.233) ) ) * 43758.5453 );
}

void main() {

  zoneRadius = separationDistance + alignmentDistance + cohesionDistance;
  separationThresh = separationDistance / zoneRadius;
  alignmentThresh = ( separationDistance + alignmentDistance ) / zoneRadius;
  zoneRadiusSquared = zoneRadius * zoneRadius;


  vec2 uv = gl_FragCoord.xy / resolution.xy;
  vec3 birdPosition, birdVelocity;

  vec3 selfPosition = texture2D( texturePosition, uv ).xyz;
  vec3 selfVelocity = texture2D( textureVelocity, uv ).xyz;

  float dist;
  vec3 dir; // direction
  float distSquared;

  float separationSquared = separationDistance * separationDistance;
  float cohesionSquared = cohesionDistance * cohesionDistance;

  float f;
  float percent;

  vec3 velocity = selfVelocity;

  float limit = SPEED_LIMIT;


  // move birds away from Ocean
  dir = vec3( 0., -selfPosition.y, 0. );
  dist = length( dir );
  distSquared = dist * dist;

  float preyRadius = 30.0;
  float preyRadiusSq = preyRadius * preyRadius;
  
  if ( dist < preyRadius ) {

    f = ( distSquared / preyRadiusSq - 1.0 ) * delta * 100.;
    velocity += normalize( dir ) * f;
    limit += 5.0;
  }


  // if (testing == 0.0) {}
  // if ( rand( uv + time ) < freedomFactor ) {}


  // Attract flocks to the center
  vec3 central = vec3( 0., 100., 0. );
  dir = selfPosition - central;
  dist = length( dir );

  dir.y *= 2.5;
  velocity -= normalize( dir ) * delta * 5.;

  for ( float y = 0.0; y < height; y++ ) {
    for ( float x = 0.0; x < width; x++ ) {

      vec2 ref = vec2( x + 0.5, y + 0.5 ) / resolution.xy;
      birdPosition = texture2D( texturePosition, ref ).xyz;

      dir = birdPosition - selfPosition;
      dist = length( dir );

      if ( dist < 0.0001 ) continue;

      distSquared = dist * dist;

      if ( distSquared > zoneRadiusSquared ) continue;

      percent = distSquared / zoneRadiusSquared;

      if ( percent < separationThresh ) { // low

        // Separation - Move apart for comfort
        f = ( separationThresh / percent - 1.0 ) * delta;
        velocity -= normalize( dir ) * f;

      } else if ( percent < alignmentThresh ) { // high

        // Alignment - fly the same direction
        float threshDelta = alignmentThresh - separationThresh;
        float adjustedPercent = ( percent - separationThresh ) / threshDelta;

        birdVelocity = texture2D( textureVelocity, ref ).xyz;

        f = ( 0.5 - cos( adjustedPercent * PI_2 ) * 0.5 + 0.5 ) * delta;
        velocity += normalize( birdVelocity ) * f;

      } else {

        // Attraction / Cohesion - move closer
        float threshDelta = 1.0 - alignmentThresh;
        float adjustedPercent;
        if( threshDelta == 0. ) adjustedPercent = 1.;
        else adjustedPercent = ( percent - alignmentThresh ) / threshDelta;

        f = ( 0.5 - ( cos( adjustedPercent * PI_2 ) * -0.5 + 0.5 ) ) * delta;

        velocity += normalize( dir ) * f;

      }

    }

  }



  // this make tends to fly around than down or up
  // if (velocity.y > 0.) velocity.y *= (1. - 0.2 * delta);

  // Speed Limits
  if ( length( velocity ) > limit ) {
    velocity = normalize( velocity ) * limit;
  }

  gl_FragColor = vec4( velocity, 1.0 );

}
`,lr=32,nl=256,Yr=800;class y1 extends te{constructor(){super();const t=3,e=nl*t,n=e*3,r=new Float32Array(n*3),s=new Float32Array(n*3),a=new Float32Array(n*2),o=new Float32Array(n);let l=0;function c(p){for(let f=0;f<p.length;f++)r[l++]=p[f]}const u=20;for(let p=0;p<nl;p++)c([0,-0,-20,0,4,-20,0,0,30]),c([0,0,-15,-u,0,0,0,0,15]),c([0,0,15,u,0,0,0,0,-15]);for(let p=0;p<e*3;p++){const y=~~(~~(p/3)/t),M=y%lr/lr,E=~~(y/lr)/lr,R=new Mt(4473924+~~(p/9)/nl*6710886);s[p*3+0]=R.r,s[p*3+1]=R.g,s[p*3+2]=R.b,a[p*2]=M,a[p*2+1]=E,o[p]=p%9}const h=new re(r,3),d=new re(s,3),m=new re(a,2),g=new re(o,1);this.setAttribute("position",h),this.setAttribute("birdColor",d),this.setAttribute("reference",m),this.setAttribute("birdVertex",g),this.scale(.2,.2,.2)}}function A1(i){je=new d1(lr,lr,i),i.capabilities.isWebGL2===!1&&je.setDataType(vi);const t=je.createTexture(),e=je.createTexture();S1(t),x1(e),Rn=je.addVariable("textureVelocity",g1,e),Kn=je.addVariable("texturePosition",m1,t),je.setVariableDependencies(Rn,[Kn,Rn]),je.setVariableDependencies(Kn,[Kn,Rn]),ls=Kn.material.uniforms,Ue=Rn.material.uniforms,ls.time={value:0},ls.delta={value:0},Ue.time={value:1},Ue.delta={value:0},Ue.testing={value:1},Ue.separationDistance={value:1},Ue.alignmentDistance={value:1},Ue.cohesionDistance={value:1},Ue.freedomFactor={value:1},Rn.material.defines.BOUNDS=Yr.toFixed(2),Rn.wrapS=zn,Rn.wrapT=zn,Kn.wrapS=zn,Kn.wrapT=zn;const n=je.init();n!==null&&console.error(n)}function S1(i){const t=Yr/2,e=i.image.data;for(let n=0,r=e.length;n<r;n+=4){const s=Math.random()*Yr-t,a=Math.random()*Yr+100,o=Math.random()*Yr-t;e[n+0]=s,e[n+1]=a,e[n+2]=o,e[n+3]=1}}function x1(i){const t=i.image.data;for(let e=0,n=t.length;e<n;e+=4){const r=Math.random()-.5,s=Math.random()-.5,a=Math.random()-.5;t[e+0]=r*10,t[e+1]=s*10,t[e+2]=a*10,t[e+3]=1}}function v1(i){const t=new y1;or={color:{value:new Mt(16720384)},texturePosition:{value:null},textureVelocity:{value:null},time:{value:1},delta:{value:0}};const e=new Le({uniforms:or,vertexShader:f1,fragmentShader:p1,side:Mi}),n=new pe(t,e);n.rotation.y=Math.PI/2,n.matrixAutoUpdate=!1,n.updateMatrix(),i.add(n)}function b1(){const i=performance.now();let t=(i-qh)/1e3;t>1&&(t=1),qh=i,ls.time.value=i,ls.delta.value=t,Ue.time.value=i,Ue.delta.value=t,or.time.value=i,or.delta.value=t,je.compute(),or.texturePosition.value=je.getCurrentRenderTarget(Kn).texture,or.textureVelocity.value=je.getCurrentRenderTarget(Rn).texture}function il(i,t){let e=0,n=0,r=0,s=0;do e=Math.random()*2-1,n=Math.random()*2-1,r=e*e+n*n;while(r==0||r>=1);return s=Math.sqrt(-2*Math.log(r)/r),i+e*s*t}function T1(i,t){A1(t),v1(i);const e={separation:il(50,20),alignment:il(30,10),cohesion:il(30,10),freedom:.75};n();function n(){Ue.separationDistance.value=e.separation,Ue.alignmentDistance.value=e.alignment,Ue.cohesionDistance.value=e.cohesion,Ue.freedomFactor.value=e.freedom}return b1}const M1=Yl({setup(i){let t,e,n,r,s,a;$l(()=>{o(),l(),window.addEventListener("resize",c)});function o(){t=new _t,t.setPixelRatio(window.devicePixelRatio),t.setSize(window.innerWidth-16,window.innerHeight-16),t.toneMapping=qd,document.body.appendChild(t.domElement),e=new Ya,n=new Te(55,(window.innerWidth-16)/(window.innerHeight-16),1,2e4),n.position.set(0,30,100),r=new a1(n,t.domElement),r.target.set(0,50,0),r.minDistance=40,r.maxDistance=200,r.update(),s=h1(e,t),a=T1(e,t)}function l(){requestAnimationFrame(l),s(),a(),t.render(e,n)}function c(){t.setSize(window.innerWidth-16,window.innerHeight-16),n.aspect=(window.innerWidth-16)/(window.innerHeight-16),n.updateProjectionMatrix()}return(u,h)=>null}});const w1=Yl({setup(i){return(t,e)=>(nr(),Zr(tn,null,[nn(Vg),nn(M1)],64))}});Sg(w1).mount("#app");
